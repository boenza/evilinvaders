<!DOCTYPE html>
<html lang="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EVIL INVADERS II - Extended Edition</title>
    <style>
        /* Inline CSS for å unngå path-problemer */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
            background-color: #000;
        }

        #gameCanvas, #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #startScreen, #introScreen, #levelStartScreen, #gameOverScreen, 
        #highscoresScreen, #levelCompleteScreen, #victoryScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 10;
        }

        #startScreen {
            justify-content: flex-end;
            padding-bottom: 10vh;
        }

        #titleBackground {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: -1;
        }

        .press-enter {
            margin-bottom: 5vh;
            z-index: 10;
            font-size: 2rem;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
        }

        .hidden {
            display: none !important;
        }

        #introScreen {
            color: #fff;
            text-align: center;
        }

        #story {
            margin: 20px auto;
            max-width: 80%;
            text-align: left;
        }

        .story-line {
            font-family: monospace;
            font-size: 1.2rem;
            line-height: 1.8;
            margin-bottom: 8px;
            color: #39FF14;
            text-shadow: 0 0 5px #39FF14;
        }

        #levelStartScreen {
            font-size: 3rem;
        }

        #levelTitle {
            font-size: 1.5rem;
            margin-top: 20px;
        }

        #countdownTimer {
            font-size: 5rem;
            margin-top: 20px;
        }

        #gameOverScreen h1 {
            margin-bottom: 30px;
        }

        #gameOverScreen button, #highscoresScreen button {
            display: block;
            margin: 15px auto;
            padding: 10px 20px;
            font-size: 1.2rem;
            background-color: rgba(0, 0, 0, 0.7);
            color: #39FF14;
            border: 2px solid #39FF14;
            border-radius: 5px;
            cursor: pointer;
            text-shadow: 0 0 5px #39FF14;
        }

        #gameOverScreen button:hover, #highscoresScreen button:hover {
            background-color: rgba(57, 255, 20, 0.2);
        }

        #highscoresScreen h1 {
            margin-bottom: 30px;
        }

        #highscoreList {
            width: 90%;
            max-width: 800px;
            margin: 0 auto 30px auto;
            max-height: 70vh;
            overflow-y: auto;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            border: 1px solid rgba(57, 255, 20, 0.3);
        }

        .highscore-item {
            display: grid;
            grid-template-columns: 0.7fr 2fr 1fr 0.7fr;
            padding: 8px 0;
            margin-bottom: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* Styling for scrollbar */
        #highscoreList::-webkit-scrollbar {
            width: 10px;
        }

        #highscoreList::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
        }

        #highscoreList::-webkit-scrollbar-thumb {
            background: #39FF14;
            border-radius: 5px;
        }

        #highscoreList::-webkit-scrollbar-thumb:hover {
            background: #FFFF66;
        }

        #levelCompleteScreen h1 {
            margin-bottom: 30px;
        }

        #levelCompleteScreen div {
            margin: 10px 0;
            font-size: 1.2rem;
        }

        #victoryScreen h1 {
            margin-bottom: 30px;
        }

        #victoryScreen div {
            margin: 15px 0;
            font-size: 1.5rem;
        }

        #mobileControls {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            display: none;
            justify-content: space-around;
            padding: 10px;
            z-index: 15;
        }

        #mobileControls div {
            background-color: rgba(0, 0, 0, 0.6);
            color: #fff;
            padding: 15px 25px;
            border-radius: 50px;
            font-size: 24px;
            border: 2px solid #39FF14;
            text-shadow: 0 0 5px #39FF14;
            user-select: none;
            -webkit-user-select: none;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }

        .blink {
            animation: pulse 1.5s infinite;
        }

        .neon-text {
            text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #0073e6, 0 0 20px #0073e6, 0 0 25px #0073e6;
            color: #fff;
        }

        .neon-green {
            text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #39FF14, 0 0 20px #39FF14, 0 0 25px #39FF14;
            color: #39FF14;
        }

        .neon-pink {
            text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #FF14A3, 0 0 20px #FF14A3, 0 0 25px #FF14A3;
            color: #FF14A3;
        }

        .neon-yellow {
            text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #FFFF66, 0 0 20px #FFFF66, 0 0 25px #FFFF66;
            color: #FFFF66;
        }

        .neon-purple {
            text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #8A2BE2, 0 0 20px #8A2BE2, 0 0 25px #8A2BE2;
            color: #8A2BE2;
        }

        .neon-orange {
            text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #FF8C00, 0 0 20px #FF8C00, 0 0 25px #FF8C00;
            color: #FF8C00;
        }

        #highscoreInput {
            margin-top: 20px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #39FF14;
            border-radius: 10px;
            text-align: center;
        }

        .nameInput {
            display: block;
            margin: 15px auto;
            padding: 10px;
            width: 80%;
            max-width: 300px;
            font-size: 1.2rem;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            border: 2px solid #39FF14;
            border-radius: 5px;
            text-align: center;
        }

        #submitScoreBtn {
            display: block;
            margin: 10px auto;
            padding: 8px 20px;
            font-size: 1.1rem;
            background-color: rgba(0, 0, 0, 0.7);
            color: #39FF14;
            border: 2px solid #39FF14;
            border-radius: 5px;
            cursor: pointer;
            text-shadow: 0 0 5px #39FF14;
        }

        #submitScoreBtn:hover {
            background-color: rgba(57, 255, 20, 0.2);
        }

        @media (max-width: 768px) {
            .press-enter {
                font-size: 1.5rem;
                padding: 10px;
            }
            
            .story-line {
                font-size: 1rem;
            }
            
            #levelStartScreen {
                font-size: 2.5rem;
            }
            
            #countdownTimer {
                font-size: 4rem;
            }
        }

        @media (max-width: 480px) {
            .press-enter {
                font-size: 1.2rem;
                padding: 8px;
            }
            
            .story-line {
                font-size: 0.9rem;
            }
            
            #levelStartScreen {
                font-size: 2rem;
            }
            
            #countdownTimer {
                font-size: 3rem;
            }
        }
        #initialScreen h1 {
        margin-bottom: 40px;
        font-size: 3rem;
    }
    
    #musicPlayButton {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 1000;
        padding: 5px 10px;
        background-color: rgba(0, 0, 0, 0.7);
        color: #39FF14;
        border: 2px solid #39FF14;
        border-radius: 5px;
        cursor: pointer;
        text-shadow: 0 0 5px #39FF14;
    }
    
    /* Add improved animations for text pulsing */
    @keyframes textPulse {
        0% { text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #0073e6, 0 0 20px #0073e6; opacity: 1; }
        50% { text-shadow: 0 0 2px #fff, 0 0 5px #0073e6; opacity: 0.7; }
        100% { text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #0073e6, 0 0 20px #0073e6; opacity: 1; }
    }
    
    .text-pulse {
        animation: textPulse 1.5s infinite;
    }

    /* Progress bar styling */
    .progress-bar {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 200px;
        height: 20px;
        background-color: rgba(0, 0, 0, 0.7);
        border: 2px solid #FFFFFF;
        border-radius: 10px;
        overflow: hidden;
    }

    .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #39FF14, #FFFF66, #FF14A3);
        transition: width 0.3s ease;
    }

    /* Shield effect */
    @keyframes shieldPulse {
        0% { opacity: 0.6; transform: scale(1); }
        50% { opacity: 0.8; transform: scale(1.1); }
        100% { opacity: 0.6; transform: scale(1); }
    }

    .shield-indicator {
        position: absolute;
        top: 120px;
        left: 15px;
        font-size: 16px;
        font-weight: bold;
        color: #00FFFF;
        text-shadow: 0 0 10px #00FFFF;
        animation: shieldPulse 1s infinite;
    }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <canvas id="overlayCanvas" width="800" height="600"></canvas>

        <div id="startScreen">
            <h1 class="neon-pink">EVIL INVADERS II</h1>
            <div class="neon-yellow" style="font-size: 1.5rem; margin-bottom: 20px;">EXTENDED EDITION - 20 LEVELS</div>
            <div class="press-enter neon-text blink">PRESS ENTER TO PLAY</div>
        </div>
        
        <!-- Intro Story Screen -->
        <div id="introScreen" class="hidden">
            <h1>EVIL INVADERS II</h1>
            <div id="story">
                <div class="story-line" id="storyLine1"></div>
                <div class="story-line" id="storyLine2"></div>
                <div class="story-line" id="storyLine3"></div>
                <div class="story-line" id="storyLine4"></div>
                <div class="story-line" id="storyLine5"></div>
                <div class="story-line" id="storyLine6"></div>
                <div class="story-line" id="storyLine7"></div>
                <div class="story-line" id="storyLine8"></div>
                <div class="story-line" id="storyLine9"></div>
                <div class="story-line" id="storyLine10"></div>
                <div class="story-line" id="storyLine11"></div>
            </div>
            <div class="press-enter neon-green hidden" id="startPrompt">PRESS SPACE TO START</div>
        </div>

        <!-- Level Start Screen -->
        <div id="levelStartScreen" class="hidden">
            <div class="neon-text">LEVEL</div>
            <div id="levelNumber" class="neon-text">1</div>
            <div id="levelTitle" class="neon-yellow"></div>
            <div id="countdownTimer" class="neon-text">3</div>
        </div>

        <!-- Game Over Screen -->
        <div id="gameOverScreen" class="hidden">
            <h1 class="neon-pink">GAME OVER</h1>
            <button id="retryBtn">1. RETRY</button>
            <button id="exitBtn">2. EXIT</button>
            <button id="highscoresBtn" style="display: none;">H. HIGHSCORES</button>
            <div id="highscoreInput" class="hidden">
                <div class="neon-text">NEW HIGHSCORE!</div>
                <input type="text" class="nameInput" id="playerNameInput" maxlength="15" placeholder="Enter your name">
                <button id="submitScoreBtn">SUBMIT</button>
            </div>
            <button id="backFromCreditsBtn" style="display: none;">BACK</button>
        </div>
        
        <!-- Highscores Screen -->
        <div id="highscoresScreen" class="hidden">
            <h1>HIGH SCORES</h1>
            <div id="highscoreList"></div>
            <button id="backToGameOverBtn" style="display: none;">BACK</button>
        </div>

        <!-- Level Complete Screen -->
<div id="levelCompleteScreen" class="hidden">
    <h1 class="neon-pink">LEVEL <span id="completedLevel">1</span> COMPLETE!</h1>
    <div class="neon-green">Score: <span id="currentScore">0</span></div>
    <div class="neon-green">Life Bonus: <span id="lifeBonus">0</span></div>
    <div class="neon-green">Time Bonus: <span id="timeBonus">0</span></div>
    <div class="neon-green">Level UFOs Killed: <span id="levelKills">0</span></div>
    <div class="neon-green">Total UFOs Killed: <span id="totalKills">0</span></div>
    <div class="neon-yellow">Total Score: <span id="totalScore">0</span></div>
    <div class="press-enter neon-text blink">PRESS ENTER TO CONTINUE</div>
</div>

        <!-- Victory Screen -->
<div id="victoryScreen" class="hidden">
    <h1 class="neon-text">GALAXY CONQUERED!</h1>
    <div class="neon-green">Current Score: <span id="victoryCurrentScore">0</span></div>
    <div class="neon-green">Final Bonus: <span id="finalBonus">0</span></div>
    <div class="neon-purple">Total UFOs Destroyed: <span id="finalKills">0</span></div>
    <div class="neon-pink">FINAL SCORE: <span id="finalScore">0</span></div>
    <div class="press-enter neon-text blink">PRESS ANY KEY TO CONTINUE</div>
</div>

        <!-- Mobile Controls -->
        <div id="mobileControls">
            <div id="moveLeftBtn">←</div>
            <div id="fireBtn">FIRE</div>
            <div id="moveRightBtn">→</div>
        </div>
    </div>

    <!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>

<script>
  // Din Firebase konfigurasjon
  const firebaseConfig = {
    apiKey: "AIzaSyBHQSa-gRonCbOS-y8eGyq9gQEY9ritBNY",
    authDomain: "evil-invaders-ii.firebaseapp.com",
    projectId: "evil-invaders-ii",
    storageBucket: "evil-invaders-ii.firebasestorage.app",
    messagingSenderId: "354911968962",
    appId: "1:354911968962:web:9dbab52240137e8a85655b"
  };

  // Initialiser Firebase
  firebase.initializeApp(firebaseConfig);

  // Få en Firestore instans
  const db = firebase.firestore();
</script>
    <script>
        // Game Constants - EXTENDED TO 20 LEVELS
        const SCREEN_WIDTH = 800;
        const SCREEN_HEIGHT = 600;
        const PLAYER_WIDTH = 60;
        const PLAYER_HEIGHT = 60;
        const UFO_WIDTH = 50;
        const UFO_HEIGHT = 30;
        const UFO_ROWS = 4;
        const UFO_COLS = 10;
        const BULLET_WIDTH = 7;
        const BULLET_HEIGHT = 15;
        const BULLET_SPEED = 8;
        let BULLET_COOLDOWN = 500; // UPDATED: Made this changeable for power-ups
        const PLAYER_SPEED = 5;
        const UFO_SPEED = 3;
        const LAVA_WIDTH = 5;
        const LAVA_HEIGHT = 10;
        const LAVA_SPEED = 2;
        const POWERUP_SPEED = 4;
        const EXTRALIFE_SPEED = 3;
        const ASTEROID_SIZE = 40;
        const MAX_LEVEL = 20; // EXTENDED: Now 20 levels!
        const BOSS_LEVEL_1 = 5;
        const BOSS_LEVEL_2 = 10;
        const BOSS_LEVEL_3 = 15; // NEW: Third boss
        const BOSS_LEVEL_4 = 20; // NEW: Final boss

        // Color Constants
        const COLORS = {
            BLACK: '#000000',
            WHITE: '#FFFFFF',
            YELLOW: '#FFFF00',
            RED: '#FF0000',
            GREEN: '#008000',
            BLUE: '#0000FF',
            PURPLE: '#800080',
            ORANGE: '#FFA500',
            CYAN: '#00FFFF',
            PINK: '#FFC0CB',
            NEON_YELLOW: '#FFFF66',
            NEON_GREEN: '#39FF14',
            NEON_PINK: '#FF14A3',
            NEON_PURPLE: '#8A2BE2',
            NEON_ORANGE: '#FF8C00'
        };

        // EXTENDED: Level Titles
        const LEVEL_TITLES = {
            1: "FIRST CONTACT", 2: "THE AWAKENING", 3: "POWER SURGE", 4: "ASTEROID FIELD", 
            5: "MOTHERSHIP ALPHA", 6: "REINFORCEMENTS", 7: "CHAOS THEORY", 8: "DOUBLE TROUBLE", 
            9: "QUAD FORCE", 10: "MOTHERSHIP BETA", 11: "BEYOND THE VOID", 12: "METEOR STORM", 
            13: "TRIPLE THREAT", 14: "THE GAUNTLET", 15: "MOTHERSHIP GAMMA", 16: "FINAL APPROACH",
            17: "SHIELD PROTOCOLS", 18: "MAXIMUM OVERDRIVE", 19: "POINT OF NO RETURN", 20: "THE FINAL STAND"
        };

        // Game Variables
        let gameCanvas, gameCtx, overlayCanvas, overlayCtx;
        let gameState = 'start'; // start, intro, playing, levelStart, gameOver, levelComplete, victory, highscores
        let gameLoop, animationFrameId;
        let screenWidth = 800;
        let screenHeight = 600;
        let lastTime = 0;
        let deltaTime = 0;
        let keys = {};
        let level = 1;
        let score = 0;
        let lives = 5;
        let playerX, playerY;
        let lastShot = 0;
        let bullets = [];
        let ufos = [];
        let lavaDrops = [];
        let powerups = [];
        let extraLifeDrops = [];
        let explosions = [];
        let asteroids = [];
        let highscores = [];
        let introTextTimer = 0;
        let currentIntroLine = 0;
        let currentIntroChar = 0;
        let typingSpeed = 50;
        let introTextComplete = false;
        let levelStartCountdown = 3;
        let countdownTimer = null;
        let lavaDragDrop = 1; // 1 in 1000 chance
        let gameImages = {};
        let gameSounds = {};
        let autoFireEnabled = false;
        let laserSpeed = BULLET_SPEED;
        let laserCount = 1;
        let bossShieldActive = false;
        let bossShieldHealth = 0;
        let bossAttackTimer = 0;
        let bossAttackPattern = 0;
        let largeUfoCreated = false;
        let largeUfo2Created = false;
        let largeUfo3Created = false; // NEW: For level 15 boss
        let largeUfo4Created = false; // NEW: For level 20 boss
        let levelExtraLifeDropped = false;
        let levelStartTime = 0;
        let asteroidTimer = 0;
        let asteroidSpawnInterval = 2000;
        let touchActive = false;
        let typingSound = null;
        let typingSoundReady = false;
        let screenRotationTimer = null;
        let currentRotationScreen = 'gameOver';
        let isNewHighscore = false;
        let currentMusicTrack = null;
        let levelUfoKills = 0;
        let totalUfoKills = 0;

        // NEW: Extended game features
        let shieldActive = false;
        let shieldTimer = 0;
        let meteorShowerActive = false;
        let meteorShowerTimer = 0;
        let wavePatternActive = false;
        let spiralPatternActive = false;

        // EXTENDED: Level par times for all 20 levels
        let levelParTimes = {
            1: 30000,  2: 35000,  3: 40000,  4: 45000,  5: 60000,
            6: 50000,  7: 55000,  8: 60000,  9: 65000,  10: 90000,
            11: 55000, 12: 70000, 13: 60000, 14: 75000, 15: 100000,
            16: 65000, 17: 80000, 18: 70000, 19: 85000, 20: 120000
        };

        // Story Text
        const introText = [
            "YEAR 2228",
            "",
            "Two centuries after Belon Smusk and the PayPal Mafia",
            "bailed to Mars, they're back—and they're pissed.",
            "Mars ran out of neural implant fuel.",
            "Now they're coming back to Earth",
            "But this time as EVIL INVADERS.",
            "",
            "HUMANITY'S LAST STAND BEGINS NOW.",
            "YOU ARE THE FINAL DEFENSE.",
            "Lock. Load. Light 'em up!"
        ];

        // Definer backgroundMusic globalt
        let backgroundMusic = new Audio();
        backgroundMusic.loop = true;
        backgroundMusic.volume = 0.5;

        // Initialize the game when the window loads
        window.onload = function() {
            console.log("Window loaded - Evil Invaders II Extended Edition (20 Levels)");
            gameCanvas = document.getElementById('gameCanvas');
            gameCtx = gameCanvas.getContext('2d');
            overlayCanvas = document.getElementById('overlayCanvas');
            overlayCtx = overlayCanvas.getContext('2d');
            gameCtx.imageSmoothingEnabled = false;
            gameCtx.imageSmoothingQuality = 'high';
            overlayCtx.imageSmoothingEnabled = false;
            overlayCtx.imageSmoothingQuality = 'high';
            
            // Initialize event listeners
            initEventListeners();

            // Initialize highscores
            loadHighscores();
            preloadTypingSound();
            
            // Create a very simple initial screen before the actual title screen
            createInitialScreen();
            
            // Setup mobile controls if on a touch device
            if ('ontouchstart' in window) {
                setupMobileControls();
            }
            
            console.log("Game initialized with 20 levels of mayhem!");
        };

        // Add this new function to create the initial screen
        function createInitialScreen() {
            // Create a new div for the initial screen
            const initialScreen = document.createElement('div');
            initialScreen.id = 'initialScreen';
            initialScreen.style.position = 'absolute';
            initialScreen.style.top = '0';
            initialScreen.style.left = '0';
            initialScreen.style.width = '100%';
            initialScreen.style.height = '100%';
            initialScreen.style.backgroundColor = '#000';
            initialScreen.style.display = 'flex';
            initialScreen.style.flexDirection = 'column';
            initialScreen.style.justifyContent = 'center';
            initialScreen.style.alignItems = 'center';
            initialScreen.style.zIndex = '100';
            
            // Add title text
            const title = document.createElement('h1');
            title.textContent = 'EVIL INVADERS II';
            title.className = 'neon-pink';
            title.style.marginBottom = '10px';
            
            // Add subtitle
            const subtitle = document.createElement('div');
            subtitle.textContent = 'EXTENDED EDITION';
            subtitle.className = 'neon-yellow';
            subtitle.style.fontSize = '1.8rem';
            subtitle.style.marginBottom = '10px';
            
            // Add level count
            const levelCount = document.createElement('div');
            levelCount.textContent = '20 LEVELS OF MAYHEM';
            levelCount.className = 'neon-green';
            levelCount.style.fontSize = '1.2rem';
            levelCount.style.marginBottom = '40px';
            
            // Add instruction text
            const instruction = document.createElement('div');
            instruction.textContent = 'CLICK OR PRESS ANY KEY TO START';
            instruction.className = 'press-enter neon-text blink';
            instruction.style.padding = '15px';
            instruction.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            instruction.style.borderRadius = '10px';
            
            // Add elements to the initial screen
            initialScreen.appendChild(title);
            initialScreen.appendChild(subtitle);
            initialScreen.appendChild(levelCount);
            initialScreen.appendChild(instruction);
            
            // Add the initial screen to the game container
            document.getElementById('gameContainer').appendChild(initialScreen);
            
            // Event listeners for the initial screen
            const handleInteraction = function() {
                // Remove the initial screen
                initialScreen.remove();
                
                // Load and prepare game assets
                loadAssets().then(() => {
                    // Show the real title screen
                    showScreen('start');
                    
                    // Play background music (this is now allowed because the user has interacted)
                    playBackgroundMusic(0);
                }).catch(error => {
                    console.error("Asset loading failed:", error);
                    createMockAssets();
                    showScreen('start');
                    playBackgroundMusic(0);
                });
                
                // Remove event listeners
                window.removeEventListener('click', handleInteraction);
                window.removeEventListener('keydown', handleInteraction);
                document.removeEventListener('touchstart', handleInteraction);
            };
            
            // Add event listeners for clicks, key presses, and touches
            window.addEventListener('click', handleInteraction);
            window.addEventListener('keydown', handleInteraction);
            document.addEventListener('touchstart', handleInteraction);
        }

        // EXTENDED: Load assets function with cycling for 20 levels
        async function loadAssets() {
            console.log("Starting to load assets for 20 levels");
            
            // Load images (cycling existing assets for 20 levels)
            const imagesToLoad = [
                { name: 'player', src: 'assets/images/player.png' },
                { name: 'playerLvl3', src: 'assets/images/new_player_ship_lvl3.png' },
                { name: 'playerLvl6', src: 'assets/images/new_player_ship_lvl6.png' },
                { name: 'playerLvl9', src: 'assets/images/new_player_ship_lvl9.png' },
                { name: 'ufo1', src: 'assets/images/ufo1.png' },
                { name: 'ufo2', src: 'assets/images/ufo2.png' },
                { name: 'ufo3', src: 'assets/images/ufo3.png' },
                { name: 'ufo4', src: 'assets/images/ufo4.png' },
                { name: 'bossLvl5', src: 'assets/images/large_ufo_level5.png' },
                { name: 'bossLvl10', src: 'assets/images/large_ufo_level10.png' },
                { name: 'explosion1', src: 'assets/images/explosion1.png' },
                { name: 'explosion2', src: 'assets/images/explosion2.png' },
                { name: 'explosion3', src: 'assets/images/explosion3.png' },
                { name: 'explosion4', src: 'assets/images/explosion4.png' },
                { name: 'explosion5', src: 'assets/images/explosion5.png' },
                { name: 'diamond', src: 'assets/images/diamond.png' },
                { name: 'extralife', src: 'assets/images/extralife.svg' },
                { name: 'asteroid', src: 'assets/images/asteroid.png' }
            ];

            // Add background images - cycle through 1-10 for levels 1-20
            for (let i = 1; i <= 20; i++) {
                const bgIndex = ((i - 1) % 10) + 1; // Cycle 1-10
                imagesToLoad.push({
                    name: `background${i}`,
                    src: `assets/images/background${bgIndex}.webp`
                });
            }

            // Image loading
            const imagePromises = imagesToLoad.map(img => {
                return new Promise((resolve) => {
                    const image = new Image();
                    image.onload = () => {
                        gameImages[img.name] = image;
                        resolve();
                    };
                    image.onerror = () => {
                        createFallbackImage(img.name);
                        resolve();
                    };
                    image.src = img.src;
                });
            });

            await Promise.all(imagePromises);
            console.log("All images processed for 20 levels");

            // Laster alle spill-lyder
            const soundsToLoad = [
                { name: 'shoot', src: 'assets/sounds/shoot.wav' },
                { name: 'explosion', src: 'assets/sounds/explosion.wav' },
                { name: 'hit', src: 'assets/sounds/hit.wav' },
                { name: 'powerup', src: 'assets/sounds/powerup.mp3' },
                { name: 'counter', src: 'assets/sounds/counter.wav' },
                { name: 'morse', src: 'assets/sounds/morse.mp3' }
            ];

            // Last hver lyd separat
soundsToLoad.forEach(sound => {
    try {
        console.log(`Setting up sound: ${sound.name} at ${sound.src}`);
        
        // Spesiell håndtering for counter-lyd med global kontroll
        if (sound.name === 'counter') {
            // Global referanse til counter-lyd
            window.currentCounterAudio = null;
            window.allCounterAudios = []; // Hold styr på alle counter-lyder
            
            gameSounds[sound.name] = {
                play: function() {
                    try {
                        // Stopp og rydd opp ALLE eksisterende counter-lyder
                        window.allCounterAudios.forEach(audio => {
                            if (audio && !audio.paused) {
                                audio.pause();
                                audio.currentTime = 0;
                            }
                        });
                        window.allCounterAudios = [];
                        
                        // Stopp hovedreferansen
                        if (window.currentCounterAudio && !window.currentCounterAudio.paused) {
                            window.currentCounterAudio.pause();
                            window.currentCounterAudio.currentTime = 0;
                        }
                        
                        window.currentCounterAudio = new Audio(sound.src);
                        window.currentCounterAudio.volume = 0.25;
                        window.currentCounterAudio.loop = true; // FIXED: Loop the sound

                        
                        // Legg til i tracking array
                        window.allCounterAudios.push(window.currentCounterAudio);
                        
                        const playPromise = window.currentCounterAudio.play();
                        
                        if (playPromise !== undefined) {
                            playPromise.catch(e => {
                                console.warn(`Could not play ${sound.name} sound: ${e.message}`);
                            });
                        }
                        
                        return window.currentCounterAudio;
                    } catch (e) {
                        console.error(`Error playing ${sound.name} sound:`, e);
                        return null;
                    }
                },
                stop: function() {
    // Clear any running timer
    if (window.counterSoundTimer) {
        clearTimeout(window.counterSoundTimer);
        window.counterSoundTimer = null;
    }
    
    // Stopp ALLE counter-lyder
    window.allCounterAudios.forEach(audio => {
        if (audio) {
            audio.pause();
            audio.currentTime = 0;
        }
    });
    window.allCounterAudios = [];
    
    if (window.currentCounterAudio) {
        window.currentCounterAudio.pause();
        window.currentCounterAudio.currentTime = 0;
        window.currentCounterAudio = null;
    }
    
    window.counterSoundPlaying = false; // FIXED: Reset flag
}
            };
        } else {
            // Opprett en enkel wrapper som lager nye instanser hver gang lyden spilles
            gameSounds[sound.name] = {
                play: function() {
                    try {
                        const audio = new Audio(sound.src);
                        // Justert lydstyrke basert på lydtype
                        if (sound.name === 'morse') {
                            audio.volume = 0.45; // Lavere volum for morse
                        } else if (sound.name === 'shoot' || sound.name === 'hit' || sound.name === 'explosion') {
                            audio.volume = 0.15; // 30% reduksjon for shoot og hit
                        } else {
                            audio.volume = 0.5; // Standard volum for andre lyder
                        }
                        
                        const playPromise = audio.play();
                        
                        if (playPromise !== undefined) {
                            playPromise.catch(e => {
                                console.warn(`Could not play ${sound.name} sound: ${e.message}`);
                            });
                        }
                        
                        return audio;
                    } catch (e) {
                        console.error(`Error playing ${sound.name} sound:`, e);
                        return null;
                    }
                }
            };
        }
    } catch (e) {
        console.error(`Failed to create sound: ${sound.name}`, e);
        createFallbackSound(sound.name);
    }
});
            // Spesifikt oppsett for typing-lyd
            typingSound = new Audio('assets/sounds/morse.mp3');
            typingSound.volume = 0.05;
            typingSound.addEventListener('canplaythrough', function() {
                typingSoundReady = true;
                console.log("Typing sound ready");
            });
            typingSound.addEventListener('error', function(e) {
                console.warn("Error loading typing sound:", e);
                typingSoundReady = false;
            });
            typingSound.load();

            // Oppsett for background music
            setupBackgroundMusic();

            console.log("Asset loading complete for 20-level extended edition");
            return Promise.resolve();
        }

        function createMockAssets() {
            console.log("Creating mock assets for offline play");
            
            // Create basic fallback images for all levels
            for (let i = 1; i <= 20; i++) {
                createFallbackImage(`background${i}`);
            }
            
            // Create basic player images
            createFallbackImage('player');
            createFallbackImage('playerLvl3');
            createFallbackImage('playerLvl6');
            createFallbackImage('playerLvl9');
            
            // Create UFO images
            for (let i = 1; i <= 4; i++) {
                createFallbackImage(`ufo${i}`);
            }
            
            // Create boss images
            createFallbackImage('bossLvl5');
            createFallbackImage('bossLvl10');
            
            // Create explosion images
            for (let i = 1; i <= 5; i++) {
                createFallbackImage(`explosion${i}`);
            }
            
            // Create other assets
            createFallbackImage('diamond');
            createFallbackImage('extralife');
            createFallbackImage('asteroid');
            
            // Create fallback sounds
            createFallbackSound('shoot');
            createFallbackSound('explosion');
            createFallbackSound('hit');
            createFallbackSound('powerup');
            createFallbackSound('counter');
            createFallbackSound('morse');
            
            typingSoundReady = false; // Disable typing sound for fallback
        }

        // Forenklet funksjon for bakgrunnsmusikk med support for 20 nivåer
        function setupBackgroundMusic() {
            console.log("Setting up background music system for 20 levels");
            
            // Opprette nytt Audio-objekt
            backgroundMusic = new Audio();
            backgroundMusic.loop = true;
            backgroundMusic.volume = 0.3;
            
            // Legg til event listeners for bedre debugging
            backgroundMusic.addEventListener('canplay', () => {
                console.log("Background music can play now: " + backgroundMusic.src);
            });
            
            backgroundMusic.addEventListener('playing', () => {
                console.log("Background music started playing: " + backgroundMusic.src);
            });
            
            backgroundMusic.addEventListener('error', (e) => {
                console.error("Background music error:", e);
                console.log("Failed source:", backgroundMusic.src);
            });
            
            // Test tilgjengeligheten av musikkfilene med fetch
            testMusicFiles();
        }

        // Test tilgjengeligheten av musikkfilene
        async function testMusicFiles() {
            const musicFiles = [
                'assets/sounds/Evil Invaders.mp3',
                'assets/sounds/background_music1.mp3',
                'assets/sounds/background_music2.mp3',
                'assets/sounds/background_music3.mp3',
                'assets/sounds/background_music4.mp3',
                'assets/sounds/background_music5.mp3',
                'assets/sounds/background_music6.mp3',
                'assets/sounds/background_music7.mp3',
                'assets/sounds/background_music8.mp3',
                'assets/sounds/background_music9.mp3',
                'assets/sounds/background_music10.mp3'
            ];
            
            console.log("Testing music file availability for 20 levels...");
            
            for (const file of musicFiles) {
                try {
                    const response = await fetch(file, { method: 'HEAD' });
                    console.log(`${file}: ${response.ok ? 'Available' : 'Not available'} (${response.status})`);
                } catch (error) {
                    console.error(`${file}: Error testing - ${error.message}`);
                }
            }
        }

        // EXTENDED: Definer playBackgroundMusic funksjon for 20 nivåer
        function playBackgroundMusic(level) {
            console.log(`Setting up background music for level ${level}`);
            
            // Bestem hvilken musikkfil som skal brukes basert på nivå
            let musicPath;
            if (level === 0) {
                musicPath = 'assets/sounds/Evil Invaders.mp3';
            } else if (level > 0 && level <= 20) {
                // Cycle through background music 1-10 for levels 1-20
                const musicIndex = ((level - 1) % 10) + 1;
                musicPath = `assets/sounds/background_music${musicIndex}.mp3`;
            } else {
                console.warn(`Invalid level ${level} for background music`);
                return;
            }
            
            // Hvis samme sang allerede spilles, ikke gjør noe
            if (currentMusicTrack === musicPath && backgroundMusic && !backgroundMusic.paused) {
                console.log("Same music already playing - continuing");
                return;
            }
            
            // Stopp eksisterende musikk
            if (backgroundMusic && !backgroundMusic.paused) {
                backgroundMusic.pause();
            }
            
            // Oppdater gjeldende spor
            currentMusicTrack = musicPath;
            
            // Reset
            backgroundMusic = new Audio();
            backgroundMusic.currentTime = 0;
            backgroundMusic.loop = true;
            backgroundMusic.volume = 0.3;
            
            console.log(`Loading music from: ${musicPath}`);
            
            // Set the source and load
            backgroundMusic.src = musicPath;
            
            // Play function with error handling
            const playMusic = () => {
                console.log("Playing background music...");
                
                backgroundMusic.play().then(() => {
                    console.log("Background music started successfully");
                }).catch(e => {
                    console.warn("Failed to play background music:", e);
                    
                    // Create a fallback button if playback fails
                    if (!document.getElementById('musicPlayButton')) {
                        const playButton = document.createElement('button');
                        playButton.id = 'musicPlayButton';
                        playButton.innerText = '🔊 ENABLE MUSIC';
                        playButton.style.position = 'absolute';
                        playButton.style.top = '10px';
                        playButton.style.right = '10px';
                        playButton.style.zIndex = '1000';
                        playButton.style.padding = '5px 10px';
                        playButton.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                        playButton.style.color = '#39FF14';
                        playButton.style.border = '2px solid #39FF14';
                        playButton.style.borderRadius = '5px';
                        playButton.style.cursor = 'pointer';
                        
                        playButton.addEventListener('click', () => {
                            backgroundMusic.play().catch(err => console.warn("Still unable to play music:", err));
                            playButton.style.display = 'none';
                        });
                        
                        document.body.appendChild(playButton);
                    }
                });
            };
            
            // Try to play immediately
            backgroundMusic.addEventListener('canplaythrough', () => {
                playMusic();
            }, { once: true });
            
            // Load the audio
            backgroundMusic.load();
            
            // Backup if canplaythrough doesn't fire within 2 seconds
            setTimeout(() => {
                if (backgroundMusic.paused) {
                    playMusic();
                }
            }, 2000);
        }

        // Forenklet fallback for bilder (som tidligere)
        function createFallbackImage(name) {
            console.log(`Creating fallback image for: ${name}`);
            
            let width = 50;
            let height = 50;
            let color = '#FFFFFF';
            let isBackground = false;
            
            // Juster størrelse og farge basert på bildetype
            if (name.includes('player')) {
                width = 60;
                height = 50;
                color = '#39FF14'; // Player: neon green
            } else if (name.includes('ufo')) {
                width = 50;
                height = 30;
                color = '#FF14A3'; // UFOs: neon pink
            } else if (name.includes('boss')) {
                width = name.includes('Lvl10') ? 150 : 100;
                height = name.includes('Lvl10') ? 120 : 80;
                color = '#FF0000'; // Boss: red
            } else if (name.includes('explosion')) {
                width = 50;
                height = 50;
                color = '#FFFF00'; // Explosions: yellow
            } else if (name.includes('background')) {
                width = 800;
                height = 600;
                color = '#000033';
                isBackground = true;
            } else if (name === 'diamond') {
                width = 40;
                height = 40;
                color = '#00FFFF'; // Cyan
            } else if (name === 'extralife') {
                width = 40;
                height = 40;
                color = '#FF3E61'; // Heart red
            } else if (name === 'asteroid') {
                width = 40;
                height = 40;
                color = '#39FF14'; // Neon green
            }
            
            // Lag fallback-bildet
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            
            if (isBackground) {
                // Create a starfield for backgrounds
                ctx.fillStyle = color;
                ctx.fillRect(0, 0, width, height);
                
                // Add stars
                ctx.fillStyle = '#FFFFFF';
                for (let i = 0; i < 100; i++) {
                    const x = Math.random() * width;
                    const y = Math.random() * height;
                    const size = Math.random() * 2 + 1;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else {
                // Simple colored rectangle for other assets
                ctx.fillStyle = color;
                ctx.fillRect(0, 0, width, height);
                
                // Add some details
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2;
                ctx.strokeRect(2, 2, width - 4, height - 4);
                
                // Add asset type text for debugging
                ctx.fillStyle = '#000000';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(name, width / 2, height / 2);
            }
            
            // Lagre fallback-bildet
            gameImages[name] = canvas;
        }

        // Forenklet fallback for lyder
function createFallbackSound(name) {
    console.log(`Creating fallback sound for: ${name}`);
    
    // Spesiell håndtering for counter-lyd
    if (name === 'counter') {
        // Global referanse til counter-lyd
        window.currentCounterAudio = null;
        window.allCounterAudios = [];
        
        gameSounds[name] = {
            play: function() {
    console.log(`[Fallback Sound effect: ${name}] - Would loop if real audio`);
    return null; // Return null since it's just a fallback
},
            stop: function() {
                console.log(`[Fallback Stop sound: ${name}]`);
                // Reset flags even in fallback
                window.counterSoundPlaying = false;
                window.allCounterAudios = [];
                window.currentCounterAudio = null;
            }
        };
    } else {
        // Enkel fallback-lyd som bare logger til konsollen
        gameSounds[name] = {
            play: function() {
                console.log(`[Fallback Sound effect: ${name}]`);
            }
        };
    }
}

        function preloadTypingSound() {
            console.log("Preloading typing sound");
            typingSound = new Audio('assets/sounds/morse.mp3');
            typingSound.volume = 0.05;
            typingSound.addEventListener('canplaythrough', function() {
                typingSoundReady = true;
                console.log("Typing sound ready");
            });
            typingSound.addEventListener('error', function(e) {
                console.warn("Error loading typing sound:", e);
                typingSoundReady = false;
            });
            typingSound.load();
        }

        function initEventListeners() {
            console.log("Initializing event listeners");
            
            // Keyboard event listeners
            window.addEventListener('keydown', (e) => {
                keys[e.key] = true;
                handleKeyPress(e);
            });

            window.addEventListener('keyup', (e) => {
                keys[e.key] = false;
            });

            // Button event listeners
            document.getElementById('retryBtn').addEventListener('click', () => restartGame());
            document.getElementById('exitBtn').addEventListener('click', () => {
                if (screenRotationTimer) {
                    clearInterval(screenRotationTimer);
                }
                location.reload();
            });
            document.getElementById('highscoresBtn').addEventListener('click', () => showHighscores());
            document.getElementById('backToGameOverBtn').addEventListener('click', () => showScreen('gameOver'));
            document.getElementById('submitScoreBtn').addEventListener('click', () => submitHighscore());
        }

        function setupMobileControls() {
            const mobileControls = document.getElementById('mobileControls');
            mobileControls.style.display = 'flex';

            const moveLeftBtn = document.getElementById('moveLeftBtn');
            const moveRightBtn = document.getElementById('moveRightBtn');
            const fireBtn = document.getElementById('fireBtn');

            // Left button
            moveLeftBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys['ArrowLeft'] = true;
            });
            moveLeftBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys['ArrowLeft'] = false;
            });

            // Right button
            moveRightBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys['ArrowRight'] = true;
            });
            moveRightBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys['ArrowRight'] = false;
            });

            // Fire button
            fireBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys[' '] = true;
            });
            fireBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[' '] = false;
            });
        }

        // Show intro screen function
        let introMorseSound = null;
        let morseIsPlaying = false;
        let introStartTime = 0;
        let totalIntroTextLength = 0;

        function showIntroScreen() {
            console.log("Showing intro screen");
            showScreen('intro');
            
            // Forbedre tittel på intro-skjermen
            const introTitle = document.querySelector('#introScreen h1');
            if (introTitle) {
                introTitle.className = 'neon-pink';
                introTitle.style.textShadow = '0 0 5px #fff, 0 0 10px #fff, 0 0 15px #FF14A3, 0 0 20px #FF14A3';
                introTitle.style.marginBottom = '20px';
                introTitle.style.fontSize = '3rem';
            }
            
            // Resten av intro-koden...
            introTextTimer = 0;
            currentIntroLine = 0;
            currentIntroChar = 0;
            introTextComplete = false;
            
            // Hide the start prompt initially
            document.getElementById('startPrompt').classList.add('hidden');
            
            // Beregn total lengde av introteksten
            totalIntroTextLength = introText.reduce((total, line) => total + line.length, 0);
            
            // Sett starttid
            introStartTime = Date.now();
            
            // Start the intro text animation
            animateIntroText();
        }

        function animateIntroText() {
            if (gameState !== 'intro') return;

            requestAnimationFrame(animateIntroText);
            
            const currentTime = Date.now();
            
            // Beregn total tid som skal brukes (19 sekunder)
            const totalDuration = 16000; // 16 sekunder i millisekunder
            
            // Dynamisk beregne typing-hastighet basert på ønsket varighet
            const elapsedTime = currentTime - introStartTime;
            const progress = elapsedTime / totalDuration;
            
            // Totalt antall tegn som skulle vært skrevet ut innen nå
            const expectedChars = Math.floor(progress * totalIntroTextLength);
            
            // Totalt antall tegn som faktisk er skrevet ut
            let totalWrittenChars = 0;
            for (let i = 0; i < currentIntroLine; i++) {
                totalWrittenChars += introText[i].length;
            }
            totalWrittenChars += currentIntroChar;
            
            // Juster typehastigheten dynamisk
            if (expectedChars > totalWrittenChars && !introTextComplete) {
                // Vi er bak skjema - skriv raskere
                if (currentTime - introTextTimer > typingSpeed / 1.5) {
                    introTextTimer = currentTime;
                    typeNextChar();
                }
            } else if (expectedChars < totalWrittenChars && !introTextComplete) {
                // Vi er foran skjema - skriv saktere 
                if (currentTime - introTextTimer > typingSpeed * 1.2) {
                    introTextTimer = currentTime;
                    typeNextChar();
                }
            } else {
                // Vi er i rute
                if (currentTime - introTextTimer > typingSpeed) {
                    introTextTimer = currentTime;
                    typeNextChar();
                }
            }
            
            // Håndter morse-lyd (spilles kontinuerlig under hele animasjonen)
            if (!morseIsPlaying && !introTextComplete && elapsedTime < totalDuration) {
                try {
                    // Start morselyden ved behov
                    if (typingSound && typingSoundReady) {
                        console.log("Starting morse sound for intro text");
                        typingSound.volume = 0.05;
                        typingSound.play().catch(e => {
                            console.warn("Could not play typing sound:", e);
                        });
                        morseIsPlaying = true;
                    }
                } catch (e) {
                    console.warn("Error with morse sound:", e);
                }
            }
            
            // Stopp morselyden når animasjonen er ferdig
            if ((introTextComplete || elapsedTime >= totalDuration) && morseIsPlaying) {
                try {
                    if (typingSound) {
                        typingSound.pause();
                        typingSound.currentTime = 0;
                    }
                    morseIsPlaying = false;
                } catch (e) {
                    console.warn("Error stopping morse sound:", e);
                }
            }
        }

        // Hjelpefunksjon for å skrive neste karakter
        function typeNextChar() {
            if (currentIntroLine < introText.length) {
                const currentLine = introText[currentIntroLine];
                const lineElement = document.getElementById(`storyLine${currentIntroLine + 1}`);
                
                if (currentIntroChar < currentLine.length) {
                    // Add one character
                    lineElement.textContent = currentLine.substring(0, currentIntroChar + 1);
                    currentIntroChar++;
                } else {
                    // Move to next line
                    currentIntroLine++;
                    currentIntroChar = 0;
                    
                    // Check if we've completed all lines
                    if (currentIntroLine >= introText.length) {
                        introTextComplete = true;
                        
                        // Stopp morselyden
                        if (typingSound) {
                            typingSound.pause();
                            typingSound.currentTime = 0;
                        }
                        morseIsPlaying = false;
                        
                        // Show the start prompt
                        setTimeout(() => {
                            document.getElementById('startPrompt').classList.remove('hidden');
                        }, 1000);
                    }
                }
            }
        }

        function completeIntroText() {
            console.log("Completing intro text");
            // Display all intro text immediately
            for (let i = 0; i < introText.length; i++) {
                document.getElementById(`storyLine${i + 1}`).textContent = introText[i];
            }
            
            introTextComplete = true;
            currentIntroLine = introText.length;
            currentIntroChar = 0;
            
            // Show the start prompt
            document.getElementById('startPrompt').classList.remove('hidden');
        }

        function startGame() {
            console.log("Starting game with 20 levels");
            // Initialize game variables
            level = 1;
            score = 0;
            lives = 5;
            playerX = (SCREEN_WIDTH - PLAYER_WIDTH) / 2;
            playerY = SCREEN_HEIGHT - PLAYER_HEIGHT - 10;

            levelUfoKills = 0;
            totalUfoKills = 0;
            
            // Reset power-ups and weapons
            autoFireEnabled = false;
            laserSpeed = BULLET_SPEED;
            laserCount = 1;
            BULLET_COOLDOWN = 500; // UPDATED: Reset firing rate
            shieldActive = false;
            shieldTimer = 0;
            meteorShowerActive = false;
            wavePatternActive = false;
            spiralPatternActive = false;
            
            // Clear all game objects
            bullets = [];
            ufos = [];
            lavaDrops = [];
            powerups = [];
            extraLifeDrops = [];
            explosions = [];
            asteroids = [];
            
            // Reset boss-related variables
            bossShieldActive = false;
            bossShieldHealth = 0;
            bossAttackTimer = 0;
            bossAttackPattern = 0;
            largeUfoCreated = false;
            largeUfo2Created = false;
            largeUfo3Created = false;
            largeUfo4Created = false;
            levelExtraLifeDropped = false;
            
            // Show level start countdown
            startLevelCountdown();
        }

        // EXTENDED: Level countdown with titles for 20 levels
        function startLevelCountdown() {
            console.log("Starting level countdown for level " + level);
            
            // Sett spillstatus til levelStart
            gameState = 'levelStart';
            
            // Vis level-start skjermen
            document.getElementById('levelStartScreen').classList.remove('hidden');
            document.getElementById('levelNumber').textContent = level;
            
            // Show level title if available
            const levelTitleElement = document.getElementById('levelTitle');
            if (LEVEL_TITLES[level]) {
                levelTitleElement.textContent = LEVEL_TITLES[level];
                levelTitleElement.style.display = 'block';
            } else {
                levelTitleElement.style.display = 'none';
            }
            
            // Sett nedtellingen
            levelStartCountdown = 3;
            document.getElementById('countdownTimer').textContent = levelStartCountdown;
            
            // Create UFOs for the current level
            createUfos();
            
            // Rydd opp i eksisterende timer hvis en finnes
            if (countdownTimer) {
                clearInterval(countdownTimer);
            }
            
            // Start nedtelling
            countdownTimer = setInterval(() => {
                levelStartCountdown--;
                document.getElementById('countdownTimer').textContent = levelStartCountdown;
                
                if (levelStartCountdown <= 0) {
                    clearInterval(countdownTimer);
                    
                    // Start the actual gameplay
                    startLevelGameplay();
                }
            }, 1000);
        }

        // FIXED: Check if player can be upgraded before dropping power-ups
function canPlayerBeUpgraded() {
    // Check if any upgrades are possible
    if (!autoFireEnabled) return true;
    if (laserCount < 2) return true;
    if (laserCount < 3) return true;
    if (laserCount < 4) return true;
    if (laserCount < 6 && level >= 10) return true;
    if (laserCount < 8 && level >= 15) return true;
    if (BULLET_COOLDOWN > 200) return true;
    if (laserSpeed < BULLET_SPEED * 2.2) return true;
    if (!shieldActive) return true; // Can always use shield
    
    return false; // Everything is maxed and shield is active
}
        
        function startLevelGameplay() {
    console.log("Starting level gameplay for level " + level);
    // Sikre at game state er riktig
    showScreen('playing');
    gameState = 'playing';
    
    // Set level start time for bonus calculation
    levelStartTime = Date.now();
    
    // Reset level-specific flags
    levelExtraLifeDropped = false;
    levelUfoKills = 0; 
    levelExtraLifeDropped = false;
    
    if ([2, 3, 5, 7, 9, 11, 12, 13, 15, 17, 19].includes(level)) {
        createPowerup();
        console.log(`🎯 Level ${level} power-up created!`);
    }
    
    // NEW: Guaranteed power-ups before boss levels if under-powered
    if (level === 5 && laserCount < 2) { // Ensure at least double laser before first boss
        createPowerup();
        console.log("🎯 Guaranteed power-up before boss level 5!");
    }
    if (level === 10 && laserCount < 4) { // Ensure at least quad laser before second boss
        createPowerup();
        createPowerup(); // Give two power-ups if really behind
        console.log("🎯 Guaranteed power-ups before boss level 10!");
    }
    if (level === 15 && laserCount < 6) { // Ensure hexa laser before third boss
        createPowerup();
        console.log("🎯 Guaranteed power-up before boss level 15!");
    }
    if (level === 20 && laserCount < 8) { // Ensure octa laser before final boss
        createPowerup();
        console.log("🎯 Guaranteed power-up before final boss!");
    }
    
    // Update difficulty based on level
    updateDifficulty();
    
    // Play background music for this level
    playBackgroundMusic(level);
    
    // Start the game loop
    lastTime = Date.now();
    gameLoop = requestAnimationFrame(update);
}

        // EXTENDED: Update difficulty for 20 levels - BALANCED PROGRESSION
        function updateDifficulty() {
            // Adjust difficulty parameters based on level (more gradual for 20 levels)
            let difficultyMultiplier = 1 + (level * 0.05);
            
            // FIXED: Much more gradual difficulty progression
            // Lava speed increases very slowly (max 3.5 for level 20)
            let newLavaSpeed;
            if (level <= 10) {
                newLavaSpeed = Math.min(2 + (level * 0.1), 3); // Slower increase first 10 levels
            } else {
                newLavaSpeed = Math.min(3 + ((level - 10) * 0.05), 3.5); // Very slow increase after level 10
            }
            
            // FIXED: Much lower lava drop chance (max 1.5 in 1000)
            if (level <= 12) {
                lavaDragDrop = Math.min(0.5 + (level * 0.08), 1.5); // Gradual increase
            } else {
                lavaDragDrop = Math.min(1.5 + ((level - 12) * 0.02), 2); // Very slow increase after level 12
            }
            
            // FIXED: Slower UFO speed progression (max 3.2 for level 20)
            let newUfoSpeed;
            if (level <= 10) {
                newUfoSpeed = Math.min(2 + (level * 0.08), 2.8);
            } else {
                newUfoSpeed = Math.min(2.8 + ((level - 10) * 0.04), 3.2); // Cap at 3.2 instead of 4
            }
            
            // Update UFO speeds
            ufos.forEach(ufo => {
                if (!ufo.isLarge) {
                    ufo.speed = newUfoSpeed;
                }
            });
            
            // FIXED: More balanced special events - introduced gradually
            // Meteor showers only occasionally and shorter duration
            if (level >= 12 && Math.random() < 0.15) { // Reduced from 0.3 to 0.15
                meteorShowerActive = true;
                meteorShowerTimer = Date.now() + 3000; // Reduced from 5 to 3 seconds
                console.log("Meteor shower activated!");
            }
            
            // FIXED: Wave pattern less aggressive and only sometimes
            if (level >= 14) {
                wavePatternActive = Math.random() < 0.25; // Reduced from 0.4 to 0.25
                if (wavePatternActive) console.log("Wave pattern activated!");
            }
            
            // FIXED: Spiral pattern even less frequent
            if (level >= 16) {
                spiralPatternActive = Math.random() < 0.2; // Reduced from 0.3 to 0.2
                if (spiralPatternActive) console.log("Spiral pattern activated!");
            }
        }
        // EXTENDED: Create UFOs for 20 levels with enhanced formations
        function createUfos() {
            console.log("Creating UFOs for level " + level);
            ufos = [];
            
            // Grunnleggende UFO-rader (nivå 1-5 har 4 rader)
            const baseRows = UFO_ROWS; // 4
            
            // Ekstra UFO-rader basert på nivå (nivå 6-20)
            let extraRows = 0;
            if (level >= 6) {
                extraRows = Math.min(level - 5, 8); // Max 8 ekstra rader for level 20
            }
            
            const totalRows = baseRows + extraRows;
            
            // Juster plassering basert på nivå
            const levelOffset = Math.min(level - 1, 5) * 8; // Økt Y-offset for hvert nivå, maks 40px
            
            // Vanlige UFO-rader (de originale 4 radene)
            for (let row = 0; row < baseRows; row++) {
                for (let col = 0; col < UFO_COLS; col++) {
                    const ufoX = 50 + col * (UFO_WIDTH + 10);
                    const ufoY = 50 + row * (UFO_HEIGHT + 10) + levelOffset;
                    
                    // Sett helse basert på rad og nivå, fra topp til bunn: 4+level/5, 3+level/5, 2+level/5, 1+level/5
                    let ufoHealth = Math.max(1, (4 - row) + Math.floor(level / 5));
                    
                    // NEW: Special UFO types for levels 12+
                    let ufoType = 'normal';
                    let ufoSpeed = UFO_SPEED;
                    
                    if (level >= 12 && Math.random() < 0.3) {
                        if (Math.random() < 0.5) {
                            ufoType = 'fast';
                            ufoSpeed = UFO_SPEED * 1.5;
                            ufoHealth = Math.max(1, Math.floor(ufoHealth * 0.7)); // Fast but weaker
                        } else {
                            ufoType = 'tank';
                            ufoSpeed = UFO_SPEED * 0.7;
                            ufoHealth = ufoHealth * 2; // Slow but stronger
                        }
                    }
                    
                    ufos.push({
                        x: ufoX,
                        y: ufoY,
                        width: UFO_WIDTH,
                        height: UFO_HEIGHT,
                        health: ufoHealth,
                        maxHealth: ufoHealth,
                        speed: ufoSpeed,
                        direction: 1,
                        isLarge: false,
                        row: row,
                        col: col,
                        image: `ufo${row % 4 + 1}`,
                        isNewRow: false,
                        type: ufoType,
                        waveOffset: Math.random() * Math.PI * 2,
                        spiralOffset: Math.random() * Math.PI * 2
                    });
                }
            }
            
            // NEW: Special formations for advanced levels
            if (level >= 13) {
                createSpecialFormations();
            }
        }

        // NEW: Create special UFO formations for levels 13+
        function createSpecialFormations() {
            if (level >= 13 && level % 3 === 1) {
                // Diamond formation
                const centerX = SCREEN_WIDTH / 2;
                const centerY = 200;
                const diamondSize = 4;
                
                for (let i = 0; i < diamondSize; i++) {
                    for (let j = 0; j <= i; j++) {
                        const x1 = centerX + (j - i/2) * (UFO_WIDTH + 5);
                        const y1 = centerY - i * (UFO_HEIGHT + 5);
                        
                        if (y1 > 0 && x1 > 0 && x1 < SCREEN_WIDTH - UFO_WIDTH) {
                            ufos.push(createSpecialUfo(x1, y1, 'diamond'));
                        }
                        
                        if (i > 0) {
                            const y2 = centerY + (diamondSize - i) * (UFO_HEIGHT + 5);
                            if (y2 < SCREEN_HEIGHT - 200 && x1 > 0 && x1 < SCREEN_WIDTH - UFO_WIDTH) {
                                ufos.push(createSpecialUfo(x1, y2, 'diamond'));
                            }
                        }
                    }
                }
            }
            
            if (level >= 14 && level % 4 === 2) {
                // V-Formation
                const centerX = SCREEN_WIDTH / 2;
                const startY = 150;
                const vWidth = 6;
                
                for (let i = 0; i < vWidth; i++) {
                    const leftX = centerX - i * (UFO_WIDTH + 8);
                    const rightX = centerX + i * (UFO_WIDTH + 8);
                    const y = startY + i * (UFO_HEIGHT + 5);
                    
                    if (leftX > 0) {
                        ufos.push(createSpecialUfo(leftX, y, 'v-formation'));
                    }
                    if (rightX < SCREEN_WIDTH - UFO_WIDTH) {
                        ufos.push(createSpecialUfo(rightX, y, 'v-formation'));
                    }
                }
            }
        }

        function createSpecialUfo(x, y, formation) {
            const health = Math.max(2, Math.floor(level / 3));
            return {
                x: x,
                y: y,
                width: UFO_WIDTH,
                height: UFO_HEIGHT,
                health: health,
                maxHealth: health,
                speed: UFO_SPEED + (level * 0.1),
                direction: Math.random() > 0.5 ? 1 : -1,
                isLarge: false,
                row: -1,
                col: -1,
                image: `ufo${Math.floor(Math.random() * 4) + 1}`,
                isNewRow: false,
                type: 'special',
                formation: formation,
                waveOffset: Math.random() * Math.PI * 2,
                spiralOffset: Math.random() * Math.PI * 2,
                originalX: x,
                originalY: y
            };
        }

        // EXTENDED: Create boss UFOs for levels 5, 10, 15, and 20
        function createLargeUfo(bossLevel) {
            console.log(`Creating boss for level ${bossLevel}`);
            // Remove any remaining regular UFOs
            ufos = ufos.filter(ufo => ufo.isLarge);
            
            // Determine boss properties based on level
            let bossWidth, bossHeight, bossHealth, bossSpeed, bossImage;
            
            if (bossLevel === 5) {
                bossWidth = 100;
                bossHeight = 80;
                bossHealth = 50;
                bossSpeed = 3;
                bossImage = 'bossLvl5';
            } else if (bossLevel === 10) {
                bossWidth = 150;
                bossHeight = 120;
                bossHealth = 200;
                bossSpeed = 4;
                bossImage = 'bossLvl10';
            } else if (bossLevel === 15) {
                bossWidth = 120;
                bossHeight = 100;
                bossHealth = 350; // Stronger than level 10
                bossSpeed = 4.5;
                bossImage = 'bossLvl5'; // Reuse boss image
            } else if (bossLevel === 20) {
                bossWidth = 180;
                bossHeight = 150;
                bossHealth = 500; // Final boss - very strong
                bossSpeed = 5;
                bossImage = 'bossLvl10'; // Reuse boss image
            }
            
            // Create boss UFO
            ufos.push({
                x: (SCREEN_WIDTH - bossWidth) / 2,
                y: 100,
                width: bossWidth,
                height: bossHeight,
                health: bossHealth,
                maxHealth: bossHealth,
                speed: bossSpeed,
                direction: 1,
                verticalDirection: 1,
                isLarge: true,
                attackTimer: Date.now(),
                spawnTimer: Date.now(),
                image: bossImage,
                bossLevel: bossLevel,
                phase: 1,
                shieldTimer: 0,
                isShielded: false
            });
            
            // Set appropriate flags
            if (bossLevel === 5) largeUfoCreated = true;
            else if (bossLevel === 10) largeUfo2Created = true;
            else if (bossLevel === 15) largeUfo3Created = true;
            else if (bossLevel === 20) largeUfo4Created = true;
        }

        function createPowerup() {
            console.log("Creating powerup for level " + level);
            powerups.push({
                x: Math.random() * (SCREEN_WIDTH - 40),
                y: 0,
                width: 40,
                height: 40,
                type: level >= 7 ? (Math.random() < 0.4 ? 'shield' : 'weapon') : 'weapon'
            });
        }

        // NEW: Shield activation
        function activateShield() {
            shieldActive = true;
            shieldTimer = Date.now() + 15000; // 15 seconds
            console.log("Player shield activated!");
            
            if (gameSounds.powerup) {
                gameSounds.powerup.play();
            }
        }

        // FIXED: Level-based power-up progression - predictable upgrades
function applyPowerup() {
    console.log(`Applying level ${level} powerup - Current stats: Laser count: ${laserCount}, Speed: ${laserSpeed}, Cooldown: ${BULLET_COOLDOWN}`);
    
    let upgradeApplied = false;
    
    // Level-based progression system
    if (level === 2) {
        // Level 2: AutoFire
        if (!autoFireEnabled) {
            autoFireEnabled = true;
            laserSpeed = Math.max(laserSpeed, BULLET_SPEED + 2);
            BULLET_COOLDOWN = Math.max(400, BULLET_COOLDOWN);
            console.log("🔥 AUTOFIRE ENABLED!");
            upgradeApplied = true;
        }
    } else if (level === 3) {
        // Level 3: Double Laser
        if (laserCount < 2) {
            laserCount = 2;
            console.log("💥 DOUBLE LASER!");
            upgradeApplied = true;
        }
    } else if (level === 5) {
        // Level 5: Triple Laser
        if (laserCount < 3) {
            laserCount = 3;
            console.log("💥 TRIPLE LASER!");
            upgradeApplied = true;
        }
    } else if (level === 7) {
        // Level 7: Shield
        activateShield();
        upgradeApplied = true;
    } else if (level === 9) {
        // Level 9: Quad Laser
        if (laserCount < 4) {
            laserCount = 4;
            console.log("💥 QUAD LASER!");
            upgradeApplied = true;
        }
    } else if (level === 11) {
        // Level 11: Faster Firing
        if (BULLET_COOLDOWN > 300) {
            BULLET_COOLDOWN = Math.max(300, BULLET_COOLDOWN - 100);
            console.log("⚡ FASTER FIRING!");
            upgradeApplied = true;
        }
    } else if (level === 12) {
        // Level 12: Hexa Laser
        if (laserCount < 6) {
            laserCount = 6;
            console.log("💥 HEXA LASER!");
            upgradeApplied = true;
        }
    } else if (level === 13) {
        // Level 13: Faster Lasers
        if (laserSpeed < BULLET_SPEED * 1.8) {
            laserSpeed = BULLET_SPEED * 1.8;
            console.log("🚀 FASTER LASERS!");
            upgradeApplied = true;
        }
    } else if (level === 15) {
        // Level 15: Even Faster Firing
        if (BULLET_COOLDOWN > 200) {
            BULLET_COOLDOWN = 200;
            console.log("⚡ ULTRA FAST FIRING!");
            upgradeApplied = true;
        }
    } else if (level === 17) {
        // Level 17: Shield
        activateShield();
        upgradeApplied = true;
    } else if (level === 19) {
        // Level 19: Octa Laser + Max Speed
        if (laserCount < 8) {
            laserCount = 8;
            laserSpeed = BULLET_SPEED * 2.2;
            console.log("💥 OCTA LASER - MAXIMUM FIREPOWER!");
            upgradeApplied = true;
        }
    } else {
        // For other levels or if already maxed, give shield
        activateShield();
        console.log("🛡️ SHIELD GRANTED!");
        upgradeApplied = true;
    }
    
    // Always play power-up sound when something is upgraded
    if (upgradeApplied && gameSounds.powerup) {
        gameSounds.powerup.play();
    }
}
        function createBullet(x, y) {
            bullets.push({
                x: x,
                y: y,
                width: BULLET_WIDTH,
                height: BULLET_HEIGHT,
                particles: []
            });
        }

        function dropLava(x, y, color) {
            lavaDrops.push({
                x: x,
                y: y,
                width: LAVA_WIDTH,
                height: LAVA_HEIGHT,
                speed: LAVA_SPEED,
                color: color || '#FF8000', // Default to neon orange
                pulse: Math.random(),
                growing: true,
                rotation: Math.random() * 360,
                rotationSpeed: Math.random() * 10 - 5,
                isFragment: false
            });
        }

        function createAsteroid() {
            const side = Math.random() < 0.33 ? 'left' : (Math.random() < 0.5 ? 'right' : 'top');
            const asteroidSize = 40;
            let x, y, speedX, speedY;
            
            if (side === 'left') {
                x = -asteroidSize;
                y = Math.random() * (SCREEN_HEIGHT / 2);
                speedX = Math.random() * 2 + 1;
                speedY = Math.random() * 1 + 1;
            } else if (side === 'right') {
                x = SCREEN_WIDTH + asteroidSize;
                y = Math.random() * (SCREEN_HEIGHT / 2);
                speedX = -(Math.random() * 2 + 1);
                speedY = Math.random() * 1 + 1;
            } else { // top
                x = Math.random() * (SCREEN_WIDTH - 50);
                y = -asteroidSize;
                speedX = Math.random() * 2 - 1;
                speedY = Math.random() * 1 + 2;
            }
            
            asteroids.push({
                x: x,
                y: y,
                width: asteroidSize,
                height: asteroidSize,
                speedX: speedX,
                speedY: speedY,
                rotation: 0,
                rotationSpeed: Math.random() * 4 - 2,
                color: COLORS.NEON_GREEN
            });
        }

        function createExtraLife() {
            console.log("Creating extra life");
            extraLifeDrops.push({
                x: Math.random() * (SCREEN_WIDTH - 40),
                y: 0,
                width: 40,
                height: 40
            });
        }

        function createExplosion(x, y, isPlayer = false, scale = 1, colorMod = null, durationMultiplier = 1) {
            explosions.push({
                x: x,
                y: y,
                index: 0,
                timer: Date.now(),
                isPlayer: isPlayer,
                scale: scale,
                colorMod: colorMod,
                durationMultiplier: durationMultiplier,
                isBossExplosion: scale > 1
            });
        }

        // Enhanced game update loop
        function update(currentTime) {
            // Calculate delta time
            deltaTime = (currentTime - lastTime) / 1000; // convert to seconds
            lastTime = currentTime;
            
            // SAFEGUARD: Check for unexpected lives changes
            if (lives < 0) {
                console.log(`⚠️ WARNING: Lives went negative (${lives})! Fixing to 0...`);
                lives = 0;
            }
            
            // Clear the canvas
            gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            
            // Draw background
            drawBackground();
            
            // Update shield timer
            if (shieldActive && Date.now() > shieldTimer) {
                shieldActive = false;
                console.log("Player shield deactivated");
            }
            
            // Update meteor shower
            if (meteorShowerActive && Date.now() > meteorShowerTimer) {
                meteorShowerActive = false;
            }
            
            // Update game objects
            updatePlayer();
            updateBullets();
            updateUfos();
            updateLava();
            updatePowerups();
            updateExtraLives();
            updateExplosions();
            updateAsteroids();
            
            // Handle meteor shower
            if (meteorShowerActive && Math.random() < 0.05) {
                createAsteroid();
            }
            
            // Draw game objects
            drawAsteroids();
            drawUfos();
            drawLava();
            drawPowerups();
            drawExtraLives();
            drawBullets();
            drawPlayer();
            drawExplosions();
            
            // Draw shield effect
            if (shieldActive) {
                drawShieldEffect();
            }
            
            // Draw UI
            drawUI();
            
            // Check level completion
            checkLevelCompletion();
            
            // Request next frame
            if (gameState === 'playing') {
                gameLoop = requestAnimationFrame(update);
            }
        }

        // NEW: Draw shield effect
        function drawShieldEffect() {
            const centerX = playerX + PLAYER_WIDTH / 2;
            const centerY = playerY + PLAYER_HEIGHT / 2;
            const radius = 40;
            const pulseIntensity = 0.3 * Math.sin(Date.now() * 0.01) + 0.7;
            
            gameCtx.save();
            gameCtx.globalAlpha = 0.6 * pulseIntensity;
            
            // Draw shield dome
            gameCtx.beginPath();
            gameCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            gameCtx.strokeStyle = '#00FFFF';
            gameCtx.lineWidth = 3;
            gameCtx.stroke();
            
            // Draw shield energy lines
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + Date.now() * 0.005;
                const x1 = centerX + Math.cos(angle) * (radius - 5);
                const y1 = centerY + Math.sin(angle) * (radius - 5);
                const x2 = centerX + Math.cos(angle) * (radius + 5);
                const y2 = centerY + Math.sin(angle) * (radius + 5);
                
                gameCtx.beginPath();
                gameCtx.moveTo(x1, y1);
                gameCtx.lineTo(x2, y2);
                gameCtx.strokeStyle = '#39FF14';
                gameCtx.lineWidth = 2;
                gameCtx.stroke();
            }
            
            gameCtx.restore();
        }

        function drawBackground() {
            // Use the background image for the current level (cycling 1-10 for levels 1-20)
            const bgIndex = ((level - 1) % 10) + 1;
            const bgImage = gameImages[`background${bgIndex}`];
            if (bgImage) {
                gameCtx.drawImage(bgImage, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
            } else {
                // Enhanced fallback with level-based colors
                const baseColor = level <= 5 ? '#000033' : 
                                 level <= 10 ? '#001a33' : 
                                 level <= 15 ? '#330033' : '#331100';
                
                gameCtx.fillStyle = baseColor;
                gameCtx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                
                // Draw stars
                gameCtx.fillStyle = '#FFFFFF';
                for (let i = 0; i < 100; i++) {
                    const x = Math.random() * SCREEN_WIDTH;
                    const y = Math.random() * SCREEN_HEIGHT;
                    const size = Math.random() * 2 + 0.5;
                    gameCtx.beginPath();
                    gameCtx.arc(x, y, size, 0, Math.PI * 2);
                    gameCtx.fill();
                }
            }
        }
        
        function updatePlayer() {
            // Player movement
            if (keys['ArrowLeft'] && playerX > 0) {
                playerX -= PLAYER_SPEED;
            }
            if (keys['ArrowRight'] && playerX < SCREEN_WIDTH - PLAYER_WIDTH) {
                playerX += PLAYER_SPEED;
            }
            
            // Shooting
            const currentTime = Date.now();
            if ((keys[' '] || autoFireEnabled) && currentTime - lastShot > BULLET_COOLDOWN) {
                if (laserCount === 1) {
                    // Single laser
                    createBullet(playerX + PLAYER_WIDTH / 2 - BULLET_WIDTH / 2, playerY);
                } else if (laserCount === 2) {
                    // Double laser
                    const offset = 10;
                    createBullet(playerX + PLAYER_WIDTH / 2 - BULLET_WIDTH / 2 - offset, playerY);
                    createBullet(playerX + PLAYER_WIDTH / 2 - BULLET_WIDTH / 2 + offset, playerY);
                } else if (laserCount === 3) {
                    // Triple laser
                    const offset = 15;
                    createBullet(playerX + PLAYER_WIDTH / 2 - BULLET_WIDTH / 2, playerY);
                    createBullet(playerX + PLAYER_WIDTH / 2 - BULLET_WIDTH / 2 - offset, playerY);
                    createBullet(playerX + PLAYER_WIDTH / 2 - BULLET_WIDTH / 2 + offset, playerY);
                } else if (laserCount === 4) {
                    // Quad laser
                    const offset = 20;
                    createBullet(playerX + PLAYER_WIDTH / 2 - BULLET_WIDTH / 2 - offset, playerY);
                    createBullet(playerX + PLAYER_WIDTH / 2 - BULLET_WIDTH / 2 - offset / 2, playerY);
                    createBullet(playerX + PLAYER_WIDTH / 2 - BULLET_WIDTH / 2 + offset / 2, playerY);
                    createBullet(playerX + PLAYER_WIDTH / 2 - BULLET_WIDTH / 2 + offset, playerY);
                } else if (laserCount >= 6) {
                    // Ultra laser (6+ or 8)
                    const offset = 25;
                    for (let i = 0; i < Math.min(laserCount, 8); i++) { // Cap at 8 for screen space
                        const spread = (i - (Math.min(laserCount, 8) - 1) / 2) * (offset / Math.min(laserCount, 8) * 2);
                        createBullet(playerX + PLAYER_WIDTH / 2 - BULLET_WIDTH / 2 + spread, playerY);
                    }
                }
                
                lastShot = currentTime;
                if (gameSounds.shoot) {
                    gameSounds.shoot.play();
                }
            }
        }

        function drawPlayer() {
            // Use appropriate player image based on level
            let playerImage;
            if (level >= 18) {
                playerImage = gameImages.playerLvl9; // Reuse for 18+
            } else if (level >= 15) {
                playerImage = gameImages.playerLvl6; // Reuse for 15+
            } else if (level >= 12) {
                playerImage = gameImages.playerLvl3; // Reuse for 12+
            } else if (level >= 9) {
                playerImage = gameImages.playerLvl9;
            } else if (level >= 6) {
                playerImage = gameImages.playerLvl6;
            } else if (level >= 3) {
                playerImage = gameImages.playerLvl3;
            } else {
                playerImage = gameImages.player;
            }
            
            if (playerImage) {
                gameCtx.drawImage(playerImage, playerX, playerY, PLAYER_WIDTH, PLAYER_HEIGHT);
            } else {
                // Fallback
                gameCtx.fillStyle = '#39FF14';
                gameCtx.fillRect(playerX, playerY, PLAYER_WIDTH, PLAYER_HEIGHT);
            }
        }

        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // Move bullet
                bullet.y -= laserSpeed;
                
                // Remove if off screen
                if (bullet.y < 0) {
                    bullets.splice(i, 1);
                    continue;
                }
                
                // Check collision with UFOs
                for (let j = ufos.length - 1; j >= 0; j--) {
                    const ufo = ufos[j];
                    
                    if (checkCollision(bullet, ufo)) {
                        // Remove bullet
                        bullets.splice(i, 1);
                        
                        // Handle UFO hit
                        handleUfoHit(ufo);
                        
                        // Break out of inner loop since bullet is removed
                        break;
                    }
                }
            }
        }

        function drawBullets() {
            for (const bullet of bullets) {
                // Draw laser with gradient effect
                const gradient = gameCtx.createLinearGradient(
                    bullet.x + bullet.width / 2,
                    bullet.y,
                    bullet.x + bullet.width / 2,
                    bullet.y + bullet.height
                );
                gradient.addColorStop(0, '#FFFFFF');
                gradient.addColorStop(1, '#FFFF66');
                
                gameCtx.fillStyle = gradient;
                gameCtx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                
                // Add glow effect
                gameCtx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
                gameCtx.lineWidth = 2;
                gameCtx.strokeRect(bullet.x - 1, bullet.y - 1, bullet.width + 2, bullet.height + 2);
            }
        }

        function handleUfoHit(ufo) {
            // Check for boss shield
            if (ufo.isLarge && ufo.isShielded) {
                createExplosion(ufo.x + ufo.width / 2, ufo.y + ufo.height / 2, false, 0.3, '#00FFFF');
                return;
            }
            
            ufo.health--;
            
            // Opprett en mindre treffeffekt
            let hitColor = null;
            if (ufo.type === 'fast') hitColor = '#FF0080';
            else if (ufo.type === 'tank') hitColor = '#8000FF';
            
            createExplosion(ufo.x + ufo.width / 2, ufo.y + ufo.height / 2, false, 0.5, hitColor);
            
            // Sjekk om UFO er ødelagt
            if (ufo.health <= 0) {
                // Fjern UFO
                const ufoIndex = ufos.indexOf(ufo);
                if (ufoIndex > -1) {
                    ufos.splice(ufoIndex, 1);
                }
                if (!ufo.isLarge) { // Don't count boss kills
                    levelUfoKills++;
                    totalUfoKills++;
                }
                
                // Spill eksplosjonslyd
                if (gameSounds.explosion) {
                    gameSounds.explosion.play();
                }
                
                // Legg til poeng
                if (ufo.isLarge) {
                    const bossScore = ufo.bossLevel === 5 ? 200 : 
                                     ufo.bossLevel === 10 ? 400 :
                                     ufo.bossLevel === 15 ? 600 : 800;
                    score += bossScore;
                    
                    // Opprett flere eksplosjoner for boss
                    createBossExplosion(ufo);
                } else {
                    // Calculate score based on UFO type and level
                    let basePoints = 10;
                    
                    if (ufo.type === 'fast') basePoints = 15;
                    else if (ufo.type === 'tank') basePoints = 25;
                    else if (ufo.type === 'special') basePoints = 30;
                    
                    // Level multiplier
                    const levelMultiplier = 1 + (level * 0.05);
                    
                    // Nye rader med høyere helse gir flere poeng
                    if (ufo.isNewRow) {
                        basePoints += 10 + Math.max(0, level - 6) * 2;
                    }
                    
                    score += Math.floor(basePoints * levelMultiplier);
                    
                    // Opprett en vanlig eksplosjon
                    createExplosion(ufo.x + ufo.width / 2, ufo.y + ufo.height / 2);
                    
                    // Enhanced drop chances
                    const extraLifeChance = Math.min(0.015 + (level * 0.001), 0.04);
                    if (Math.random() < extraLifeChance) {
                        extraLifeDrops.push({
                            x: ufo.x + ufo.width / 2 - 20,
                            y: ufo.y + ufo.height / 2 - 20,
                            width: 40,
                            height: 40
                        });
                    }
                    
                    // Power-up drop for special UFOs
                    if (ufo.type === 'special' && Math.random() < 0.3) {
                        powerups.push({
                            x: ufo.x + ufo.width / 2 - 20,
                            y: ufo.y + ufo.height / 2 - 20,
                            width: 40,
                            height: 40,
                            type: Math.random() < 0.5 ? 'weapon' : 'shield'
                        });
                    }
                }
            }
        }

        // EXTENDED: Update UFOs with enhanced behavior for 20 levels
        function updateUfos() {
            const currentTime = Date.now();
            
            // Filtrer ut vanlige UFO-er (ikke bosser) for å telle hvor mange som er igjen
            const regularUfos = ufos.filter(ufo => !ufo.isLarge);
            const remainingUfos = regularUfos.length;
            
            // Telle kun de originale UFO-ene (ikke nye rader)
            const originalUfos = regularUfos.filter(ufo => !ufo.isNewRow).length;
            
            // Sjekk hvor mange nye rader som allerede er lagt til
            const newRowsCreated = Math.max(0, ...regularUfos.filter(ufo => ufo.isNewRow).map(ufo => ufo.newRowBatch || 0));
            
            // For level 6-20, sjekk om vi skal legge til nye rader - FIXED: Better balancing
            if (level >= 6 && level <= 20) {
                // FIXED: Reduced extra rows for better balance
                let extraRowsForLevel;
                if (level <= 8) {
                    extraRowsForLevel = Math.min(level - 5, 2); // Max 2 extra rows for levels 6-8
                } else if (level <= 12) {
                    extraRowsForLevel = Math.min(level - 7, 3); // Max 3 extra rows for levels 9-12
                } else if (level <= 16) {
                    extraRowsForLevel = Math.min(level - 9, 4); // Max 4 extra rows for levels 13-16
                } else {
                    extraRowsForLevel = Math.min(level - 11, 5); // Max 5 extra rows for levels 17-20
                }
                
                // Sjekk om vi har originale UFO-er igjen, og om vi ikke allerede har lagt til nye rader
                if (originalUfos <= UFO_COLS && // kun én original rad igjen
                    newRowsCreated === 0 && // ingen nye rader lagt til ennå
                    !window.addedNewRowsForLevel) { // flagg for å hindre flere tillegg
                    
                    // Legg til alle nye rader på én gang
                    for (let i = 0; i < extraRowsForLevel; i++) {
                        createNewUfoRow(i, extraRowsForLevel);
                    }
                    
                    // Sett flagg for å hindre at vi legger til flere rader
                    window.addedNewRowsForLevel = true;
                    
                    console.log(`Added ${extraRowsForLevel} new UFO rows for level ${level} (BALANCED)`);
                }
            }
            
            // Create boss UFOs at the right levels
            if (level === 5 && !largeUfoCreated && remainingUfos <= 1) {
                createLargeUfo(5);
            } else if (level === 10 && !largeUfo2Created && (remainingUfos <= 5 || (currentTime - levelStartTime > 60000))) {
                createLargeUfo(10);
            } else if (level === 15 && !largeUfo3Created && (remainingUfos <= 3 || (currentTime - levelStartTime > 70000))) {
                createLargeUfo(15);
            } else if (level === 20 && !largeUfo4Created && (remainingUfos <= 2 || (currentTime - levelStartTime > 80000))) {
                createLargeUfo(20);
            }
            
            // Øk hastigheten på UFOene basert på hvor mange som er igjen
            let speedBonus = 0;
            let visualMultiplier = 1.0;
            
            if (remainingUfos <= 5) {
                speedBonus = 3.0;
                visualMultiplier = 2.5;
            } else if (remainingUfos <= 10) {
                speedBonus = 2.0;
                visualMultiplier = 2.0;
            } else if (remainingUfos <= 20) {
                speedBonus = 1.0;
                visualMultiplier = 1.5;
            }
            
            // Oppdater hver UFO
            for (let i = ufos.length - 1; i >= 0; i--) {
                const ufo = ufos[i];
                
                if (ufo.isLarge) {
                    // Boss-UFO-bevegelse
                    updateLargeUfoMovement(ufo);
                } else {
                    // Vanlig UFO-bevegelse med enhanced patterns for higher levels
                    const levelBaseSpeed = UFO_SPEED + (level - 1) * 0.2;
                    let currentSpeed = levelBaseSpeed + speedBonus;
                    
                    // Apply UFO type speed modifiers
                    if (ufo.type === 'fast') {
                        currentSpeed *= 1.8;
                    } else if (ufo.type === 'tank') {
                        currentSpeed *= 0.6;
                    }
                    
                    // NEW: Special movement patterns
                    if (wavePatternActive && level >= 14) {
                        ufo.waveOffset += 0.1;
                        ufo.y += Math.sin(ufo.waveOffset) * 2;
                    }
                    
                    if (spiralPatternActive && level >= 16) {
                        ufo.spiralOffset += 0.05;
                        ufo.x += Math.cos(ufo.spiralOffset) * 1;
                        ufo.y += Math.sin(ufo.spiralOffset) * 0.5;
                    }
                    
                    // Hvis det er en ny rad, la den først falle nedover til riktig posisjon - SLOWER DESCENT
                    if (ufo.isNewRow) {
                        const targetY = 50 + Math.abs(ufo.row) * (UFO_HEIGHT + 10);
                        
                        if (ufo.y < targetY) {
                            // FIXED: Much slower descent for new UFO rows
                            const descentSpeed = Math.max(0.8, 2 - (level * 0.05)); // Slower for higher levels
                            ufo.y += descentSpeed;
                        } else {
                            ufo.y = targetY;
                            // FIXED: Longer wait before they start moving horizontally
                            if (Date.now() - ufo.creationTime > 8000) { // 8 seconds instead of 5
                                ufo.isNewRow = false;
                            }
                        }
                    }
                    
                    // Vanlig horisontal bevegelse
                    ufo.x += currentSpeed * ufo.direction;
                    
                    // NEW: Special movement patterns - TONED DOWN
                    if (wavePatternActive && level >= 14) {
                        ufo.waveOffset += 0.05;
                        ufo.y += Math.sin(ufo.waveOffset) * 1;
                    }
                    
                    if (spiralPatternActive && level >= 16) {
                        ufo.spiralOffset += 0.03;
                        ufo.x += Math.cos(ufo.spiralOffset) * 0.5;
                        ufo.y += Math.sin(ufo.spiralOffset) * 0.3;
                    }
                    // FIXED: Round positions to prevent subpixel flicker
                    ufo.x = Math.round(ufo.x);
                    ufo.y = Math.round(ufo.y);
                    // FIXED: Handle edge collision and direction change AFTER all movement
                    let hitEdge = false;
                    if (ufo.x + ufo.width >= SCREEN_WIDTH) {
                        ufo.x = SCREEN_WIDTH - ufo.width;
                        ufo.direction = -1;
                        hitEdge = true;
                    } else if (ufo.x <= 0) {
                        ufo.x = 0;
                        ufo.direction = 1;
                        hitEdge = true;
                    }
                    
                    // Move down when hitting edge
                     if (hitEdge) {
                        let verticalStep;
                        if (ufo.isNewRow) {
                            verticalStep = Math.max(8, ufo.height / (15 - Math.min(level, 12))); // CHANGED: økt fra 2 til 8
                        } else {
                            const baseDivisor = Math.max(3, 6 - (level * 0.1)); // CHANGED: mye raskere progresjon
                            verticalStep = Math.max(10, ufo.height / baseDivisor); // CHANGED: økt fra 3 til 10
                        }
                        
                        ufo.y += verticalStep;
                    }
                    // Enhanced lava dropping
                    const lavaChance = (lavaDragDrop / 1000) * visualMultiplier;
                    if (Math.random() < lavaChance) {
                        let lavaColor = '#FF8000';
                        if (ufo.type === 'fast') lavaColor = '#FF0080';
                        else if (ufo.type === 'tank') lavaColor = '#8000FF';
                        
                        dropLava(ufo.x + ufo.width / 2, ufo.y + ufo.height, lavaColor);
                    }
                    
                    // Sjekk om UFO har nådd bunnen av skjermen
                    if (ufo.y + ufo.height >= SCREEN_HEIGHT - 10) {
                        ufos.splice(i, 1);
                        lives--;
                        console.log(`🛸 UFO reached bottom! Lives remaining: ${lives} (Level ${level})`);
                        
                        createExplosion(ufo.x + ufo.width / 2, SCREEN_HEIGHT - 20);
                        
                        if (gameSounds.hit) {
                            gameSounds.hit.play();
                        }
                    }
                }
                
                // Sjekk kollisjon med spiller (with shield protection)
                if (checkCollision(ufo, {
                    x: playerX,
                    y: playerY,
                    width: PLAYER_WIDTH,
                    height: PLAYER_HEIGHT
                })) {
                    ufos.splice(i, 1);
                    
                    if (!shieldActive) {
                        lives--;
                        console.log(`💥 Life lost to UFO! Lives remaining: ${lives} (Level ${level})`);
                        createExplosion(playerX + PLAYER_WIDTH / 2, playerY + PLAYER_HEIGHT / 2, true);
                        if (gameSounds.hit) {
                            gameSounds.hit.play();
                        }
                    } else {
                        // Shield absorbs the hit
                        console.log(`🛡️ Shield absorbed UFO hit! Lives still: ${lives} (Level ${level})`);
                        createExplosion(ufo.x + ufo.width / 2, ufo.y + ufo.height / 2);
                        if (gameSounds.explosion) {
                            gameSounds.explosion.play();
                        }
                    }
                }
            }
            
            // Periodisk asteroidespawning for boss-nivåer og høyere nivåer
            if ((level === 5 || level === 10 || level === 15 || level === 20 || level >= 12) && 
                currentTime - asteroidTimer > asteroidSpawnInterval) {
                createAsteroid();
                asteroidTimer = currentTime;
                
                // Increase spawn rate for higher levels
                if (level >= 16) {
                    asteroidSpawnInterval = Math.max(1000, 2000 - (level * 50));
                }
            }
        }

        function updateLargeUfoMovement(ufo) {
            const currentTime = Date.now();
            
            // Horizontal movement
            ufo.x += ufo.speed * ufo.direction;
            
            // Change direction when hitting screen edge
            if (ufo.x + ufo.width >= SCREEN_WIDTH) {
                ufo.x = SCREEN_WIDTH - ufo.width;
                ufo.direction *= -1;
            } else if (ufo.x <= 0) {
                ufo.x = 0;
                ufo.direction *= -1;
            }
            
            // Vertical movement
            ufo.y += ufo.speed / 2 * ufo.verticalDirection;
            
            // Change vertical direction when hitting boundaries
            if (ufo.y + ufo.height >= SCREEN_HEIGHT - 100) {
                ufo.y = SCREEN_HEIGHT - 100 - ufo.height;
                ufo.verticalDirection = -1;
            } else if (ufo.y <= 50) {
                ufo.y = 50;
                ufo.verticalDirection = 1;
            }
            
            // Enhanced boss attacks based on level
            const attackInterval = ufo.bossLevel >= 15 ? 2000 : 3000;
            
            if (currentTime - ufo.attackTimer > attackInterval) {
                // Cycle through attack patterns
                bossAttackPattern = (bossAttackPattern + 1) % (ufo.bossLevel >= 15 ? 5 : 3);
                
                // Determine attack color based on boss level
                const attackColor = ufo.bossLevel === 5 ? COLORS.NEON_GREEN : 
                                   ufo.bossLevel === 10 ? COLORS.NEON_PINK :
                                   ufo.bossLevel === 15 ? COLORS.NEON_PURPLE :
                                   COLORS.NEON_ORANGE;
                
                // Execute attack based on pattern
                if (bossAttackPattern === 0) {
                    // Enhanced burst attack
                    const burstCount = ufo.bossLevel >= 15 ? 5 : 3;
                    for (let i = 0; i < burstCount; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const offsetX = Math.cos(angle) * 30;
                        const offsetY = Math.sin(angle) * 30;
                        dropLava(ufo.x + ufo.width / 2 + offsetX, ufo.y + ufo.height + offsetY, attackColor);
                    }
                } else if (bossAttackPattern === 1) {
                    // Enhanced line attack
                    const lineCount = ufo.bossLevel >= 15 ? 7 : 5;
                    for (let i = -(lineCount-1)/2; i <= (lineCount-1)/2; i++) {
                        dropLava(ufo.x + ufo.width / 2 + (i * 30), ufo.y + ufo.height, attackColor);
                    }
                } else if (bossAttackPattern === 2) {
                    // Enhanced cross attack
                    const crossSize = ufo.bossLevel >= 15 ? 4 : 3;
                    for (let i = -crossSize; i <= crossSize; i++) {
                        dropLava(ufo.x + ufo.width / 2 + (i * 30), ufo.y + ufo.height + (i * 30), attackColor);
                        dropLava(ufo.x + ufo.width / 2 - (i * 30), ufo.y + ufo.height + (i * 30), attackColor);
                    }
                } else if (bossAttackPattern === 3 && ufo.bossLevel >= 15) {
                    // Spiral attack
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2 + (currentTime * 0.01);
                        const radius = 60;
                        const offsetX = Math.cos(angle) * radius;
                        const offsetY = Math.sin(angle) * radius;
                        dropLava(ufo.x + ufo.width / 2 + offsetX, ufo.y + ufo.height / 2 + offsetY, attackColor);
                    }
                } else if (bossAttackPattern === 4 && ufo.bossLevel >= 15) {
                    // Homing attack
                    for (let i = 0; i < 3; i++) {
                        const targetX = playerX + PLAYER_WIDTH / 2;
                        const targetY = playerY + PLAYER_HEIGHT / 2;
                        const startX = ufo.x + ufo.width / 2;
                        const startY = ufo.y + ufo.height;
                        
                        const angle = Math.atan2(targetY - startY, targetX - startX);
                        const offsetAngle = angle + (i - 1) * 0.3;
                        const distance = 40;
                        
                        dropLava(
                            startX + Math.cos(offsetAngle) * distance, 
                            startY + Math.sin(offsetAngle) * distance, 
                            attackColor
                        );
                    }
                }
                
                ufo.attackTimer = currentTime;
            }
            
            // Boss phase transitions for higher level bosses
            if (ufo.bossLevel >= 15) {
                const healthPercent = ufo.health / ufo.maxHealth;
                
                if (healthPercent <= 0.5 && ufo.phase === 1) {
                    ufo.phase = 2;
                    ufo.speed += 1;
                    console.log(`Boss entered phase 2!`);
                }
                
                if (healthPercent <= 0.25 && ufo.phase === 2 && ufo.bossLevel === 20) {
                    ufo.phase = 3;
                    ufo.speed += 1;
                    ufo.isShielded = true;
                    ufo.shieldTimer = currentTime + 10000;
                    console.log(`Final boss entered phase 3 with shield!`);
                }
                
                if (ufo.isShielded && currentTime > ufo.shieldTimer) {
                    ufo.isShielded = false;
                    console.log("Boss shield deactivated");
                }
            }
        }

        // Create new UFO row function
        function createNewUfoRow(rowIndex, totalNewRows) {
            console.log(`Creating UFO row ${rowIndex+1} of ${totalNewRows}`);
            
            const baseHealth = 2;
            const health = baseHealth + rowIndex + Math.floor(level / 5);
            const startY = -20 - (rowIndex * (UFO_HEIGHT + 10));
            
            for (let col = 0; col < UFO_COLS; col++) {
                const ufoX = 50 + col * (UFO_WIDTH + 10);
                const ufoY = startY;
                
                // Determine UFO type for higher levels
                let ufoType = 'normal';
                if (level >= 12 && Math.random() < 0.2) {
                    ufoType = Math.random() < 0.5 ? 'fast' : 'tank';
                }
                
                ufos.push({
                    x: ufoX,
                    y: ufoY,
                    width: UFO_WIDTH,
                    height: UFO_HEIGHT,
                    health: health,
                    maxHealth: health,
                    speed: UFO_SPEED + 0.5,
                    direction: 1,
                    isLarge: false,
                    row: -rowIndex - 1,
                    col: col,
                    image: `ufo${rowIndex % 4 + 1}`,
                    isNewRow: true,
                    newRowBatch: rowIndex + 1,
                    creationTime: Date.now(),
                    type: ufoType,
                    waveOffset: Math.random() * Math.PI * 2,
                    spiralOffset: Math.random() * Math.PI * 2
                });
            }
            
            if (rowIndex === 0 && gameSounds.powerup) {
                gameSounds.powerup.play();
            }
        }

        function updateLava() {
            for (let i = lavaDrops.length - 1; i >= 0; i--) {
                const lava = lavaDrops[i];
                
                if (lava.isFragment) {
                    // Update fragment movement
                    lava.x += lava.velocityX;
                    lava.y += lava.velocityY;
                    
                    // Add gravity
                    lava.velocityY += 0.1;
                    
                    // Update rotation
                    lava.rotation += lava.rotationSpeed;
                    
                    // Reduce lifetime
                    lava.lifetime--;
                    if (lava.lifetime <= 0 || lava.y > SCREEN_HEIGHT || lava.x < 0 || lava.x > SCREEN_WIDTH) {
                        lavaDrops.splice(i, 1);
                    }
                } else {
                    // Regular lava movement
                    lava.y += lava.speed;
                    
                    // Remove if off screen
                    if (lava.y > SCREEN_HEIGHT) {
                        lavaDrops.splice(i, 1);
                        continue;
                    }
                    
                    // Check collision with player (with shield protection)
                    if (checkCollision(lava, {
                        x: playerX,
                        y: playerY,
                        width: PLAYER_WIDTH,
                        height: PLAYER_HEIGHT
                    })) {
                        lavaDrops.splice(i, 1);
                        
                        if (!shieldActive) {
                            lives--;
                            console.log(`🌋 Life lost to lava! Lives remaining: ${lives} (Level ${level})`);
                            createExplosion(playerX + PLAYER_WIDTH / 2, playerY + PLAYER_HEIGHT / 2, true);
                            if (gameSounds.hit) {
                                gameSounds.hit.play();
                            }
                        } else {
                            // Shield absorbs the hit
                            console.log(`🛡️ Shield absorbed lava hit! Lives still: ${lives} (Level ${level})`);
                            createExplosion(lava.x + lava.width / 2, lava.y + lava.height / 2, false, 0.3, '#00FFFF');
                        }
                    }
                    
                    // Update pulsing effect
                    if (lava.growing) {
                        lava.pulse += 0.05;
                        if (lava.pulse >= 1.3) {
                            lava.growing = false;
                        }
                    } else {
                        lava.pulse -= 0.05;
                        if (lava.pulse <= 0.7) {
                            lava.growing = true;
                        }
                    }
                }
            }
        }

        function drawLava() {
            for (const lava of lavaDrops) {
                const centerX = lava.x + lava.width / 2;
                const centerY = lava.y + lava.height / 2;
                
                if (lava.isFragment) {
                    // Fragment tegnes som små glødende biter
                    const radius = lava.width / 2;
                    
                    gameCtx.save();
                    gameCtx.translate(centerX, centerY);
                    gameCtx.rotate(lava.rotation * Math.PI / 180);
                    
                    // Tegn fragment som glødende partikkel
                    gameCtx.beginPath();
                    gameCtx.ellipse(0, 0, radius, radius * 0.5, 0, 0, Math.PI * 2);
                    
                    // Glød-effekt
                    gameCtx.shadowBlur = 15;
                    gameCtx.shadowColor = lava.color || COLORS.NEON_PINK;
                    
                    // Fill
                    gameCtx.fillStyle = lava.color || COLORS.NEON_PINK;
                    gameCtx.fill();
                    
                    // Hvit kjerne for intensitet
                    gameCtx.beginPath();
                    gameCtx.arc(0, 0, radius * 0.3, 0, Math.PI * 2);
                    gameCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    gameCtx.fill();
                    
                    gameCtx.restore();
                } else {
                    // Regulær lava tegnes som skummel glødende dråper
                    const baseRadius = Math.max(4, lava.width * 1.2 * lava.pulse);
                    
                    gameCtx.save();
                    gameCtx.translate(centerX, centerY);
                    gameCtx.rotate(lava.rotation * Math.PI / 180);
                    
                    // Glød-effekt
                    gameCtx.shadowBlur = 20;
                    gameCtx.shadowColor = lava.color || COLORS.ORANGE;
                    
                    // Tegn dråpen som en tåreformet figur
                    gameCtx.beginPath();
                    gameCtx.moveTo(0, -baseRadius * 1.5);
                    gameCtx.quadraticCurveTo(baseRadius, -baseRadius * 0.5, baseRadius, 0);
                    gameCtx.quadraticCurveTo(baseRadius, baseRadius * 1.2, 0, baseRadius);
                    gameCtx.quadraticCurveTo(-baseRadius, baseRadius * 1.2, -baseRadius, 0);
                    gameCtx.quadraticCurveTo(-baseRadius, -baseRadius * 0.5, 0, -baseRadius * 1.5);
                    
                    // Fyll med gradient
                    const gradient = gameCtx.createRadialGradient(0, 0, 0, 0, 0, baseRadius * 1.5);
                    gradient.addColorStop(0, '#FFFFFF');
                    gradient.addColorStop(0.2, '#FFFF00');
                    gradient.addColorStop(0.4, lava.color || '#FF8800');
                    gradient.addColorStop(0.8, '#FF3300');
                    gradient.addColorStop(1, '#AA0000');
                    
                    gameCtx.fillStyle = gradient;
                    gameCtx.fill();
                    
                    gameCtx.strokeStyle = COLORS.NEON_YELLOW;
                    gameCtx.lineWidth = 1;
                    gameCtx.stroke();
                    
                    gameCtx.restore();
                }
            }
        }

        function updatePowerups() {
            for (let i = powerups.length - 1; i >= 0; i--) {
                const powerup = powerups[i];
                
                // Move powerup down
                powerup.y += POWERUP_SPEED;
                
                // Remove if off screen
                if (powerup.y > SCREEN_HEIGHT) {
                    powerups.splice(i, 1);
                    continue;
                }
                
                // Check collision with player
                if (checkCollision(powerup, {
                    x: playerX,
                    y: playerY,
                    width: PLAYER_WIDTH,
                    height: PLAYER_HEIGHT
                })) {
                    // Remove powerup
                    powerups.splice(i, 1);
                    
                    // Apply powerup effect
                    if (powerup.type === 'shield') {
                        activateShield();
                    } else {
                        applyPowerup();
                    }
                    
                    // Play powerup sound
                    if (gameSounds.powerup) {
                        gameSounds.powerup.play();
                    }
                }
            }
        }

        function drawPowerups() {
            for (const powerup of powerups) {
                const centerX = powerup.x + powerup.width / 2;
                const centerY = powerup.y + powerup.height / 2;
                const size = powerup.width * 0.7;
                
                gameCtx.save();
                
                const pulseScale = 1.0 + 0.2 * Math.sin(Date.now() * 0.005);
                
                gameCtx.translate(centerX, centerY);
                gameCtx.rotate(Date.now() * 0.001);
                
                gameCtx.shadowBlur = 15;
                gameCtx.shadowColor = powerup.type === 'shield' ? '#00FFFF' : COLORS.CYAN;
                
                if (powerup.type === 'shield') {
                    // Shield power-up - hexagonal shape
                    gameCtx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = Math.PI * 2 * i / 6;
                        const radius = size * 0.5 * pulseScale;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        
                        if (i === 0) {
                            gameCtx.moveTo(x, y);
                        } else {
                            gameCtx.lineTo(x, y);
                        }
                    }
                    gameCtx.closePath();
                    
                    const gradient = gameCtx.createRadialGradient(0, 0, size * 0.1, 0, 0, size * 0.5);
                    gradient.addColorStop(0, '#FFFFFF');
                    gradient.addColorStop(0.5, '#00FFFF');
                    gradient.addColorStop(1, '#0080FF');
                    
                    gameCtx.fillStyle = gradient;
                    gameCtx.fill();
                    
                    gameCtx.strokeStyle = '#FFFFFF';
                    gameCtx.lineWidth = 2;
                    gameCtx.stroke();
                } else {
                    // Weapon power-up - star shape
                    gameCtx.beginPath();
                    for (let i = 0; i < 12; i++) {
                        const angle = Math.PI * 2 * i / 12;
                        const radius = (i % 2 === 0) ? size * 0.5 * pulseScale : size * 0.2 * pulseScale;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        
                        if (i === 0) {
                            gameCtx.moveTo(x, y);
                        } else {
                            gameCtx.lineTo(x, y);
                        }
                    }
                    gameCtx.closePath();
                    
                    const gradient = gameCtx.createRadialGradient(0, 0, size * 0.1, 0, 0, size * 0.5);
                    gradient.addColorStop(0, '#FFFFFF');
                    gradient.addColorStop(0.5, '#00FFFF');
                    gradient.addColorStop(1, '#0080FF');
                    
                    gameCtx.fillStyle = gradient;
                    gameCtx.fill();
                    
                    gameCtx.strokeStyle = '#FFFFFF';
                    gameCtx.lineWidth = 2;
                    gameCtx.stroke();
                }
                
                // Center point
                gameCtx.beginPath();
                gameCtx.arc(0, 0, size * 0.1, 0, Math.PI * 2);
                gameCtx.fillStyle = '#FFFFFF';
                gameCtx.fill();
                
                gameCtx.restore();
            }
        }

        function updateExtraLives() {
            for (let i = extraLifeDrops.length - 1; i >= 0; i--) {
                const extraLife = extraLifeDrops[i];
                
                // Move extra life down
                extraLife.y += EXTRALIFE_SPEED;
                
                // Remove if off screen
                if (extraLife.y > SCREEN_HEIGHT) {
                    extraLifeDrops.splice(i, 1);
                    continue;
                }
                
                // Check collision with player
                if (checkCollision(extraLife, {
                    x: playerX,
                    y: playerY,
                    width: PLAYER_WIDTH,
                    height: PLAYER_HEIGHT
                })) {
                    // Remove extra life
                    extraLifeDrops.splice(i, 1);
                    
                    // Add a life
                    lives++;
                    
                    // Play powerup sound
                    if (gameSounds.powerup) {
                        gameSounds.powerup.play();
                    }
                }
            }
        }

        function drawExtraLives() {
            for (const extraLife of extraLifeDrops) {
                const centerX = extraLife.x + extraLife.width / 2;
                const centerY = extraLife.y + extraLife.height / 2;
                const size = extraLife.width * 0.7;
                
                const pulseIntensity = 0.2 * Math.sin(Date.now() * 0.006) + 1.0;
                
                gameCtx.save();
                
                gameCtx.shadowBlur = 15;
                gameCtx.shadowColor = '#FF3E61';
                
                gameCtx.translate(centerX, centerY);
                gameCtx.scale(pulseIntensity, pulseIntensity);
                
                // Tegn hjerte
                const heartPath = (size) => {
                    gameCtx.beginPath();
                    gameCtx.moveTo(0, size * 0.3);
                    gameCtx.bezierCurveTo(-size * 0.55, -size * 0.3, -size * 0.85, size * 0.3, 0, size * 0.8);
                    gameCtx.bezierCurveTo(size * 0.85, size * 0.3, size * 0.55, -size * 0.3, 0, size * 0.3);
                };
                
                heartPath(size + 3);
                gameCtx.fillStyle = 'rgba(255, 62, 97, 0.3)';
                gameCtx.fill();
                
                heartPath(size);
                
                const gradient = gameCtx.createRadialGradient(0, size * 0.2, 0, 0, size * 0.2, size);
                gradient.addColorStop(0, '#FF3E61');
                gradient.addColorStop(0.7, '#FF0040');
                gradient.addColorStop(1, '#C00030');
                
                gameCtx.fillStyle = gradient;
                gameCtx.fill();
                
                gameCtx.beginPath();
                gameCtx.ellipse(-size * 0.25, -size * 0.1, size * 0.15, size * 0.1, Math.PI / 4, 0, Math.PI * 2);
                gameCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                gameCtx.fill();
                
                gameCtx.restore();
            }
        }

        function updateExplosions() {
            const currentTime = Date.now();
            
            for (let i = explosions.length - 1; i >= 0; i--) {
                const explosion = explosions[i];
                
                const frameDuration = 50 * (explosion.durationMultiplier || 1);
                
                if (currentTime - explosion.timer > frameDuration) {
                    explosion.index++;
                    explosion.timer = currentTime;
                    
                    if (explosion.isBossExplosion && explosion.index >= 4) {
                        explosion.durationMultiplier *= 2;
                    }
                    
                    if (explosion.index >= 5) {
                        explosions.splice(i, 1);
                    }
                }
            }
        }

        function drawExplosions() {
            for (const explosion of explosions) {
                if (explosion.index < 5) {
                    const explosionImage = gameImages[`explosion${explosion.index + 1}`];
                    
                    if (explosionImage) {
                        const scale = explosion.scale || 1;
                        const width = 50 * scale;
                        const height = 50 * scale;
                        const x = explosion.x - width / 2;
                        const y = explosion.y - height / 2;
                        
                        gameCtx.save();
                        
                        if (explosion.colorMod) {
                            gameCtx.globalAlpha = 0.8;
                            gameCtx.drawImage(explosionImage, x, y, width, height);
                            
                            gameCtx.globalCompositeOperation = 'source-atop';
                            gameCtx.fillStyle = explosion.colorMod;
                            gameCtx.globalAlpha = 0.5;
                            gameCtx.fillRect(x, y, width, height);
                            
                            gameCtx.globalCompositeOperation = 'source-over';
                            gameCtx.globalAlpha = 1.0;
                        } else {
                            gameCtx.drawImage(explosionImage, x, y, width, height);
                        }
                        
                        gameCtx.restore();
                    }
                }
            }
        }

        function updateAsteroids() {
            for (let i = asteroids.length - 1; i >= 0; i--) {
                const asteroid = asteroids[i];
                
                // Move asteroid
                asteroid.x += asteroid.speedX;
                asteroid.y += asteroid.speedY;
                
                // Update rotation
                asteroid.rotation += asteroid.rotationSpeed;
                
                // Remove if off screen
                if (asteroid.y > SCREEN_HEIGHT || asteroid.x < -asteroid.width || asteroid.x > SCREEN_WIDTH + asteroid.width) {
                    asteroids.splice(i, 1);
                    continue;
                }
                
                // Check collision with player (with shield protection)
                if (checkCollision(asteroid, {
                    x: playerX,
                    y: playerY,
                    width: PLAYER_WIDTH,
                    height: PLAYER_HEIGHT
                })) {
                    asteroids.splice(i, 1);
                    
                    if (!shieldActive) {
                        lives--;
                        console.log(`☄️ Life lost to asteroid! Lives remaining: ${lives} (Level ${level})`);
                        createExplosion(playerX + PLAYER_WIDTH / 2, playerY + PLAYER_HEIGHT / 2, true);
                        if (gameSounds.hit) {
                            gameSounds.hit.play();
                        }
                    } else {
                        // Shield absorbs the hit
                        console.log(`🛡️ Shield absorbed asteroid hit! Lives still: ${lives} (Level ${level})`);
                        createExplosion(asteroid.x + asteroid.width / 2, asteroid.y + asteroid.height / 2, false, 0.5, '#00FFFF');
                    }
                    
                    continue;
                }
                
                // Check collision with bullets
                for (let j = bullets.length - 1; j >= 0; j--) {
                    const bullet = bullets[j];
                    
                    if (checkCollision(asteroid, bullet)) {
                        bullets.splice(j, 1);
                        asteroids.splice(i, 1);
                        
                        score += 15;
                        
                        createExplosion(asteroid.x + asteroid.width / 2, asteroid.y + asteroid.height / 2);
                        
                        if (gameSounds.explosion) {
                            gameSounds.explosion.play();
                        }
                        
                        break;
                    }
                }
            }
        }

        function drawAsteroids() {
            for (const asteroid of asteroids) {
                gameCtx.save();
                
                gameCtx.translate(
                    asteroid.x + asteroid.width / 2,
                    asteroid.y + asteroid.height / 2
                );
                
                gameCtx.rotate(asteroid.rotation * Math.PI / 180);
                
                if (gameImages.asteroid) {
                    gameCtx.drawImage(
                        gameImages.asteroid,
                        -asteroid.width / 2,
                        -asteroid.height / 2,
                        asteroid.width,
                        asteroid.height
                    );
                } else {
                    // Fallback: draw a polygon shape
                    const radius = asteroid.width / 2;
                    gameCtx.beginPath();
                    
                    for (let i = 0; i < 12; i++) {
                        const angle = Math.PI * 2 * i / 12;
                        const pointRadius = radius * (0.8 + Math.sin(i * 2.5) * 0.2);
                        const x = Math.cos(angle) * pointRadius;
                        const y = Math.sin(angle) * pointRadius;
                        
                        if (i === 0) {
                            gameCtx.moveTo(x, y);
                        } else {
                            gameCtx.lineTo(x, y);
                        }
                    }
                    
                    gameCtx.closePath();
                    
                    gameCtx.fillStyle = COLORS.NEON_GREEN;
                    gameCtx.fill();
                    
                    gameCtx.shadowBlur = 10;
                    gameCtx.shadowColor = COLORS.NEON_GREEN;
                    gameCtx.strokeStyle = COLORS.WHITE;
                    gameCtx.lineWidth = 2;
                    gameCtx.stroke();
                    gameCtx.shadowBlur = 0;
                    
                    // Add some details (craters)
                    for (let i = 0; i < 3; i++) {
                        const craterX = (Math.random() - 0.5) * radius;
                        const craterY = (Math.random() - 0.5) * radius;
                        const craterSize = Math.random() * 5 + 3;
                        
                        gameCtx.beginPath();
                        gameCtx.arc(craterX, craterY, craterSize, 0, Math.PI * 2);
                        gameCtx.fillStyle = 'rgba(0, 100, 0, 0.8)';
                        gameCtx.fill();
                    }
                }
                
                gameCtx.restore();
            }
        }

        // EXTENDED: Enhanced UI for 20 levels
        function drawUI() {
            // Score med kraftigere neon-effekt
            gameCtx.fillStyle = COLORS.NEON_YELLOW;
            gameCtx.font = 'bold 24px monospace';
            gameCtx.textAlign = 'left';
            gameCtx.shadowBlur = 15;
            gameCtx.shadowColor = COLORS.NEON_YELLOW;
            gameCtx.fillText(`Score: ${score}`, 15, 30);
            
            // Level med sterkere neon-effekt og progress
            gameCtx.fillStyle = COLORS.NEON_PINK;
            gameCtx.shadowBlur = 15;
            gameCtx.shadowColor = COLORS.NEON_PINK;
            gameCtx.fillText(`Level: ${level}/20`, 15, 60);
            
            // Lives med sterkere neon-effekt
            gameCtx.fillStyle = COLORS.NEON_GREEN;
            gameCtx.shadowBlur = 15;
            gameCtx.shadowColor = COLORS.NEON_GREEN;
            gameCtx.fillText('Lives:', 15, 90);
            
            // Fjern shadow-effekten for resten av tegningen
            gameCtx.shadowBlur = 0;
            
            // Tegn hjertene litt lengre til høyre
            for (let i = 0; i < 5; i++) {
                if (i < lives) {
                    // Active life med sterkere glødende effekt
                    gameCtx.save();
                    gameCtx.shadowBlur = 15;
                    gameCtx.shadowColor = '#FF3E61';
                    if (gameImages.extralife) {
                        gameCtx.drawImage(gameImages.extralife, 95 + i * 25, 70, 20, 20);
                    } else {
                        gameCtx.fillStyle = '#FF3E61';
                        gameCtx.fillRect(95 + i * 25, 70, 20, 20);
                    }
                    gameCtx.restore();
                } else {
                    // Inactive life
                    gameCtx.globalAlpha = 0.3;
                    if (gameImages.extralife) {
                        gameCtx.drawImage(gameImages.extralife, 95 + i * 25, 70, 20, 20);
                    } else {
                        gameCtx.fillStyle = '#FF3E61';
                        gameCtx.fillRect(95 + i * 25, 70, 20, 20);
                    }
                    gameCtx.globalAlpha = 1.0;
                }
            }
            
            // Vis ekstra liv-indikator hvis spilleren har mer enn 5 liv
            if (lives > 5) {
                const extraLives = lives - 5;
                gameCtx.save();
                
                const textX = 80 + 5 * 25 + 5;
                const textY = 85;
                
                gameCtx.shadowBlur = 15;
                gameCtx.shadowColor = '#FF3E61';
                gameCtx.font = 'bold 18px monospace';
                gameCtx.fillStyle = '#FF3E61';
                gameCtx.textAlign = 'left';
                gameCtx.fillText(`+${extraLives}`, textX, textY);
                
                gameCtx.restore();
            }
            
            // NEW: Level progress bar (top right)
            const progressBarX = SCREEN_WIDTH - 220;
            const progressBarY = 20;
            const progressBarWidth = 200;
            const progressBarHeight = 20;
            const progress = level / MAX_LEVEL;
            
            // Progress bar background
            gameCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            gameCtx.fillRect(progressBarX, progressBarY, progressBarWidth, progressBarHeight);
            
            // Progress bar fill
            const gradient = gameCtx.createLinearGradient(progressBarX, progressBarY, progressBarX + progressBarWidth, progressBarY);
            gradient.addColorStop(0, '#39FF14');
            gradient.addColorStop(0.5, '#FFFF66');
            gradient.addColorStop(1, '#FF14A3');
            gameCtx.fillStyle = gradient;
            gameCtx.fillRect(progressBarX, progressBarY, progressBarWidth * progress, progressBarHeight);
            
            // Progress bar border
            gameCtx.strokeStyle = '#FFFFFF';
            gameCtx.lineWidth = 2;
            gameCtx.strokeRect(progressBarX, progressBarY, progressBarWidth, progressBarHeight);
            
            // Progress text
            gameCtx.fillStyle = '#FFFFFF';
            gameCtx.font = '12px monospace';
            gameCtx.textAlign = 'center';
            gameCtx.fillText(`${level}/${MAX_LEVEL}`, progressBarX + progressBarWidth / 2, progressBarY + 15);
            
            // NEW: Shield status indicator
            if (shieldActive) {
                const shieldTimeLeft = Math.max(0, shieldTimer - Date.now()) / 1000;
                gameCtx.fillStyle = '#00FFFF';
                gameCtx.font = 'bold 16px monospace';
                gameCtx.textAlign = 'left';
                gameCtx.shadowBlur = 10;
                gameCtx.shadowColor = '#00FFFF';
                gameCtx.fillText(`SHIELD: ${Math.ceil(shieldTimeLeft)}s`, 15, 120);
                gameCtx.shadowBlur = 0;
            }
            
            // NEW: Power-up indicators
            let powerUpY = shieldActive ? 150 : 120;
            if (autoFireEnabled) {
                gameCtx.fillStyle = '#FFFF66';
                gameCtx.font = 'bold 14px monospace';
                gameCtx.textAlign = 'left';
                gameCtx.fillText('AUTO-FIRE', 15, powerUpY);
                powerUpY += 20;
            }
            
            if (laserCount > 1) {
                gameCtx.fillStyle = '#FF14A3';
                gameCtx.font = 'bold 14px monospace';
                gameCtx.textAlign = 'left';
                let laserText = `${laserCount}X LASER`;
                if (laserCount >= 8) laserText = 'MAX LASER!'; // Special text for max
                gameCtx.fillText(laserText, 15, powerUpY);
                powerUpY += 20;
            }
            
            if (laserSpeed > BULLET_SPEED) {
                gameCtx.fillStyle = '#39FF14';
                gameCtx.font = 'bold 14px monospace';
                gameCtx.textAlign = 'left';
                gameCtx.fillText('FAST LASER', 15, powerUpY);
            }
            
            // NEW: Special event indicators
            if (meteorShowerActive) {
                gameCtx.fillStyle = '#FF8C00';
                gameCtx.font = 'bold 20px monospace';
                gameCtx.textAlign = 'center';
                gameCtx.shadowBlur = 15;
                gameCtx.shadowColor = '#FF8C00';
                gameCtx.fillText('METEOR SHOWER!', SCREEN_WIDTH / 2, 50);
                gameCtx.shadowBlur = 0;
            }
            
            if (wavePatternActive) {
                gameCtx.fillStyle = '#39FF14';
                gameCtx.font = 'bold 16px monospace';
                gameCtx.textAlign = 'right';
                gameCtx.fillText('WAVE PATTERN', SCREEN_WIDTH - 15, SCREEN_HEIGHT - 60);
            }
            
            if (spiralPatternActive) {
                gameCtx.fillStyle = '#FF14A3';
                gameCtx.font = 'bold 16px monospace';
                gameCtx.textAlign = 'right';
                gameCtx.fillText('SPIRAL PATTERN', SCREEN_WIDTH - 15, SCREEN_HEIGHT - 40);
            }
        }

        function drawUfos() {
            for (const ufo of ufos) {
                // Draw UFO
                let ufoImage;
                if (ufo.isLarge) {
                    ufoImage = gameImages[ufo.image];
                } else {
                    ufoImage = gameImages[ufo.image] || gameImages.ufo1;
                }
                
                if (ufoImage) {
                    gameCtx.drawImage(ufoImage, ufo.x, ufo.y, ufo.width, ufo.height);
                } else {
                    // Fallback
                    let color = '#FF14A3';
                    if (ufo.type === 'fast') color = '#FF0080';
                    else if (ufo.type === 'tank') color = '#8000FF';
                    else if (ufo.type === 'special') color = '#00FFFF';
                    
                    gameCtx.fillStyle = color;
                    gameCtx.fillRect(ufo.x, ufo.y, ufo.width, ufo.height);
                }
                
                // Draw health bar for boss UFOs and damaged regular UFOs
                if (ufo.isLarge) {
                    drawBossHealthBar(ufo);
                } else if (ufo.health < ufo.maxHealth && ufo.maxHealth > 1) {
                    drawUfoHealthBar(ufo);
                }
            }
        }

        function drawBossHealthBar(ufo) {
            const barWidth = ufo.width * 1.2;
            const barHeight = 16;
            const barX = ufo.x + (ufo.width - barWidth) / 2;
            const barY = ufo.y - 25;
            
            // Determine max health and colors based on boss level
            const maxHealth = ufo.maxHealth;
            const primaryColor = ufo.bossLevel === 5 ? COLORS.NEON_GREEN : 
                               ufo.bossLevel === 10 ? COLORS.NEON_PINK :
                               ufo.bossLevel === 15 ? COLORS.NEON_PURPLE :
                               COLORS.NEON_ORANGE;
            
            // Calculate health ratio
            const healthRatio = Math.max(0, Math.min(ufo.health / maxHealth, 1.0));
            const currentBarWidth = barWidth * healthRatio;
            
            // Draw background
            gameCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            gameCtx.fillRect(barX, barY, barWidth, barHeight);
            
            // Draw health bar with gradient
            const gradient = gameCtx.createLinearGradient(barX, barY, barX + currentBarWidth, barY);
            gradient.addColorStop(0, primaryColor);
            gradient.addColorStop(1, COLORS.NEON_YELLOW);
            
            gameCtx.fillStyle = gradient;
            gameCtx.fillRect(barX, barY, currentBarWidth, barHeight);
            
            // Draw shield indicator if active
            if (ufo.isShielded) {
                gameCtx.strokeStyle = '#00FFFF';
                gameCtx.lineWidth = 3;
                gameCtx.strokeRect(barX - 2, barY - 2, barWidth + 4, barHeight + 4);
            }
            
            // Draw border
            gameCtx.strokeStyle = COLORS.WHITE;
            gameCtx.lineWidth = 2;
            gameCtx.strokeRect(barX, barY, barWidth, barHeight);
            
            // Draw health percentage
            const healthPercent = Math.floor(healthRatio * 100);
            gameCtx.fillStyle = healthPercent > 70 ? COLORS.NEON_GREEN : 
                                (healthPercent > 30 ? COLORS.NEON_YELLOW : COLORS.RED);
            gameCtx.font = '12px monospace';
            gameCtx.textAlign = 'center';
            gameCtx.fillText(`${healthPercent}%`, barX + barWidth / 2, barY + barHeight / 2 + 4);
        }

        // IMPROVED: Sleeker UFO health bars with rounded corners
function drawUfoHealthBar(ufo) {
    const barWidth = ufo.width * 0.8; // FIXED: Smaller width (was full width)
    const barHeight = 4; // FIXED: Thinner bar (was 6)
    const barX = ufo.x + (ufo.width - barWidth) / 2; // FIXED: Centered
    const barY = ufo.y - 8; // FIXED: Closer to UFO (was -10)
    
    const healthRatio = ufo.health / ufo.maxHealth;
    const currentBarWidth = barWidth * healthRatio;
    
    // FIXED: More subtle curved background using rounded rectangle
    gameCtx.save();
    
    // Background with rounded corners
    gameCtx.fillStyle = 'rgba(0, 0, 0, 0.6)'; // More transparent
    drawRoundedRect(gameCtx, barX, barY, barWidth, barHeight, 2);
    gameCtx.fill();
    
    // Health bar with rounded corners and gradient
    if (currentBarWidth > 0) {
        let healthColor;
        if (healthRatio <= 0.3) healthColor = '#FF4444'; // Softer red
        else if (healthRatio <= 0.6) healthColor = '#FFDD44'; // Softer yellow
        else healthColor = '#44FF44'; // Softer green
        
        // Create subtle gradient
        const gradient = gameCtx.createLinearGradient(barX, barY, barX, barY + barHeight);
        gradient.addColorStop(0, healthColor);
        gradient.addColorStop(1, '#FFFFFF');
        
        gameCtx.fillStyle = gradient;
        drawRoundedRect(gameCtx, barX, barY, currentBarWidth, barHeight, 2);
        gameCtx.fill();
    }
    
    // FIXED: Much more subtle border - semi-transparent white
    gameCtx.strokeStyle = 'rgba(255, 255, 255, 0.4)'; // Very subtle
    gameCtx.lineWidth = 0.5; // Thinner line
    drawRoundedRect(gameCtx, barX, barY, barWidth, barHeight, 2);
    gameCtx.stroke();
    
    gameCtx.restore();
}

// Helper function for rounded rectangles
function drawRoundedRect(ctx, x, y, width, height, radius) {
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
}
        function checkCollision(obj1, obj2) {
            return (
                obj1.x < obj2.x + obj2.width &&
                obj1.x + obj1.width > obj2.x &&
                obj1.y < obj2.y + obj2.height &&
                obj1.y + obj1.height > obj2.y
            );
        }

        // EXTENDED: Level completion check for all 20 levels - WITH DEBUGGING
        function checkLevelCompletion() {
            // Check if player has lost all lives - ADD DEBUGGING
            if (lives <= 0) {
                console.log(`🚨 GAME OVER TRIGGERED: Lives = ${lives}, Level = ${level}, Score = ${score}`);
                console.log(`🕐 Game time: ${((Date.now() - levelStartTime) / 1000).toFixed(1)}s on level ${level}`);
                
                // FIXED: Stop game loop immediately to prevent multiple game over calls
                if (gameLoop) {
                    cancelAnimationFrame(gameLoop);
                    gameLoop = null;
                }
                
                gameOver();
                return;
            }
            
            // Ignorer level completion check hvis vi allerede er i boss explosion eller andre slutttilstander
            if (gameState !== 'playing') {
                return;
            }
            
            // Check if all UFOs are destroyed
            if (ufos.length === 0) {
                console.log("All UFOs defeated - showing level victory animation");
                
                // For boss levels, håndterer vi fullføring i boss explosion handler
                if ((level === 5 && largeUfoCreated) || 
                    (level === 10 && largeUfo2Created) ||
                    (level === 15 && largeUfo3Created) ||
                    (level === 20 && largeUfo4Created)) {
                    return; // Boss explosion handler will call levelComplete
                }
                
                // Stop gameloop first
                if (gameLoop) {
                    cancelAnimationFrame(gameLoop);
                    gameLoop = null;
                }
                
                // Reset all key states to prevent accidental dismissal
                keys = {};
                
                // Create a temporary victory message overlay
                const victoryOverlay = document.createElement('div');
                victoryOverlay.style.position = 'absolute';
                victoryOverlay.style.top = '0';
                victoryOverlay.style.left = '0';
                victoryOverlay.style.width = '100%';
                victoryOverlay.style.height = '100%';
                victoryOverlay.style.display = 'flex';
                victoryOverlay.style.justifyContent = 'center';
                victoryOverlay.style.alignItems = 'center';
                victoryOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                victoryOverlay.style.zIndex = '15';
                victoryOverlay.style.flexDirection = 'column';
                
                // Add victory text
                const victoryText = document.createElement('div');
                victoryText.textContent = 'LEVEL CLEARED!';
                victoryText.style.fontSize = '5rem';
                victoryText.style.color = '#FF14A3'; // NEON_PINK
                victoryText.style.textShadow = '0 0 10px #fff, 0 0 20px #fff, 0 0 30px #FF14A3, 0 0 40px #FF14A3';
                victoryText.style.animation = 'textPulse 1.5s infinite';
                victoryOverlay.appendChild(victoryText);
                
                // Add level title if available
                const levelText = document.createElement('div');
                levelText.textContent = `${LEVEL_TITLES[level] || `LEVEL ${level}`} COMPLETE`;
                levelText.style.marginTop = '10px';
                levelText.style.fontSize = '2rem';
                levelText.style.color = '#FFFF66'; // NEON_YELLOW
                levelText.style.textShadow = '0 0 5px #fff, 0 0 10px #FFFF66';
                victoryOverlay.appendChild(levelText);
                
                // Add "press space/enter" text
                const pressKeyText = document.createElement('div');
                pressKeyText.textContent = 'PRESS SPACE OR ENTER TO CONTINUE';
                pressKeyText.style.marginTop = '40px';
                pressKeyText.style.fontSize = '1.5rem';
                pressKeyText.style.color = '#fff';
                pressKeyText.style.textShadow = '0 0 5px #fff, 0 0 10px #39FF14';
                pressKeyText.style.animation = 'pulse 1.5s infinite';
                victoryOverlay.appendChild(pressKeyText);
                
                // Add overlay to the game container
                document.getElementById('gameContainer').appendChild(victoryOverlay);
                
                // Play a victory sound if available
                if (gameSounds.powerup) {
                    gameSounds.powerup.play();
                }
                
                // Set up event listener for specific key press (Space or Enter only)
                const handleKeyPress = function(e) {
                    if (e.key === ' ' || e.key === 'Enter') {
                        // Remove overlay
                        victoryOverlay.remove();
                        
                        // Remove event listener
                        window.removeEventListener('keydown', handleKeyPress);
                        
                        // Go to level complete screen
                        levelComplete();
                    }
                };
                
                // Wait a short time before enabling key listener to prevent accidental skipping
                setTimeout(() => {
                    // Listen for Space or Enter key press
                    window.addEventListener('keydown', handleKeyPress);
                    
                    // Update the instruction text to show it's now active
                    pressKeyText.style.opacity = '1';
                }, 500);
                
                // Auto-continue after 10 seconds if no key press (longer delay)
                setTimeout(() => {
                    if (document.getElementById('gameContainer').contains(victoryOverlay)) {
                        victoryOverlay.remove();
                        window.removeEventListener('keydown', handleKeyPress);
                        levelComplete();
                    }
                }, 10000);
                
                // Update game state to prevent multiple calls
                gameState = 'levelVictory';
            }
        }

        // Rest of the functions (levelComplete, nextLevel, victory, etc.)
        // For brevity, I'll add the key remaining functions...

        function levelComplete() {
            if (gameLoop) {
                cancelAnimationFrame(gameLoop);
                gameLoop = null;
            }
    
    gameState = 'levelComplete';
    console.log("Level complete! Starting score animation for level " + level);
    
    // Calculate bonuses
    const currentTime = Date.now();
    const levelTime = currentTime - levelStartTime;
    const parTime = levelParTimes[level] || 60000;
    
    let timeBonus = 0;
    let baseBonusMultiplier = Math.floor((level - 1) / 5) + 1;
    
    if (level <= 5) {
        const baseBonus = 50 * baseBonusMultiplier;
        if (levelTime < parTime) {
            const multiplier = 6 - level;
            timeBonus = baseBonus + Math.floor((parTime - levelTime) / 1000) * 10 * multiplier;
        } else {
            timeBonus = baseBonus;
        }
    } else {
        if (levelTime < parTime) {
            timeBonus = Math.floor((parTime - levelTime) / 1000) * 10 * baseBonusMultiplier;
        }
    }
    
    const lifeBonus = lives * (50 + (level * 5));
    const totalBonus = timeBonus + lifeBonus;
    
    // Show level completion with initial values
document.getElementById('completedLevel').textContent = level;
document.getElementById('currentScore').textContent = '0';
document.getElementById('lifeBonus').textContent = '0';
document.getElementById('timeBonus').textContent = '0';
document.getElementById('levelKills').textContent = '0';
document.getElementById('totalKills').textContent = '0';
document.getElementById('totalScore').textContent = '0';

document.getElementById('levelCompleteScreen').classList.remove('hidden');

// Calculate final total score
const finalTotalScore = score + totalBonus;

// Sequential animation with 6 phases
const totalAnimationDuration = 6000; // 6 seconds total
const phaseCount = 6;
const phaseDuration = totalAnimationDuration / phaseCount; // 1 second per phase

let currentPhase = 0;
let phaseStartTime = Date.now();
let lastSoundTime = 0;
const soundInterval = 200;


// Animation sequence: Score -> Life bonus -> Time bonus -> Level kills -> Total kills -> Total score
const animationSequence = [
    {
        element: 'currentScore',
        targetValue: score,
        currentValue: 0
    },
    {
        element: 'lifeBonus',
        targetValue: lifeBonus,
        currentValue: 0
    },
    {
        element: 'timeBonus',
        targetValue: timeBonus,
        currentValue: 0
    },
    {
        element: 'levelKills',
        targetValue: levelUfoKills,
        currentValue: 0
    },
    {
        element: 'totalKills',
        targetValue: totalUfoKills,
        currentValue: totalUfoKills - levelUfoKills // Start from previous total
    },
    {
        element: 'totalScore',
        targetValue: finalTotalScore,
        currentValue: 0
    }
];

let animationStopped = false; // FIXED: Add control flag


function animateScoresSequentially() {
    const now = Date.now();
    const totalElapsed = now - (phaseStartTime - currentPhase * phaseDuration);
    
    // Play counter sound - only start once, let it loop
// Start counter sound once at beginning
if (currentPhase === 0 && !window.counterSoundPlaying) {
    console.log("🔊 Starting counter sound for score animation");
    window.counterSoundPlaying = true;
    if (gameSounds.counter) {
        gameSounds.counter.play();
    }
 window.counterSoundTimer = setTimeout(() => {
        console.log("⏰ Timer stopping counter sound after 6 seconds");
        if (gameSounds.counter && gameSounds.counter.stop) {
            gameSounds.counter.stop();
        }
    }, 6000); // Stop after 6 seconds
}
    
    // Check if we should move to the next phase
    const phaseElapsed = now - phaseStartTime;
    if (phaseElapsed >= phaseDuration && currentPhase < phaseCount - 1) {
        // Complete current phase
        const currentAnim = animationSequence[currentPhase];
        document.getElementById(currentAnim.element).textContent = currentAnim.targetValue;
        
        // Move to next phase
        currentPhase++;
        phaseStartTime = now;
    }
    
    if (currentPhase < phaseCount) {
        // Animate current phase
        const currentAnim = animationSequence[currentPhase];
        const phaseProgress = Math.min((now - phaseStartTime) / phaseDuration, 1);
        
        const currentValue = Math.floor(
            currentAnim.currentValue + 
            (currentAnim.targetValue - currentAnim.currentValue) * phaseProgress
        );
        
        document.getElementById(currentAnim.element).textContent = currentValue;
        
        requestAnimationFrame(animateScoresSequentially);
    } else {
    // Animation complete - stop counter sound and set final values
    console.log("🔇 Animation complete - stopping counter sound");
    if (gameSounds.counter && gameSounds.counter.stop) {
        gameSounds.counter.stop();
    }
    
    // Ensure all values are set to their final targets
    animationSequence.forEach(anim => {
        document.getElementById(anim.element).textContent = anim.targetValue;
    });
    
    // Update the actual game score
    score = finalTotalScore;
}
}
window.stopLevelCompleteAnimation = function() {
    animationStopped = true;
    if (gameSounds.counter && gameSounds.counter.stop) {
        gameSounds.counter.stop();
    }
};

// Start animation after a short delay
setTimeout(animateScoresSequentially, 500);
}
        // EXTENDED: Next level for 20 levels
        function nextLevel() {
            console.log("Advancing to next level");
            if (window.stopLevelCompleteAnimation) {
    window.stopLevelCompleteAnimation();
}
if (window.stopVictoryAnimation) {
    window.stopVictoryAnimation();
}
            
            // Skjul level complete screen først
            document.getElementById('levelCompleteScreen').classList.add('hidden');
            
            // Clear all game objects
            bullets = [];
            lavaDrops = [];
            powerups = [];
            extraLifeDrops = [];
            explosions = [];
            asteroids = [];
            
            // Reset level-specific flags
            levelExtraLifeDropped = false;
            window.addedNewRowsForLevel = false;
            
            // Reset special effects
            meteorShowerActive = false;
            wavePatternActive = false;
            spiralPatternActive = false;
            
            // Move to next level
            level++;
            
            console.log("Starting level " + level);
            
            if (level <= MAX_LEVEL) {
                // Start next level
                startLevelCountdown();
            } else {
                // Game completed!
                victory();
            }
        }

        function victory() {
    console.log("All 20 levels completed! Ultimate Victory!");
    
    if (gameLoop) {
        cancelAnimationFrame(gameLoop);
        gameLoop = null;
    }
    
    gameState = 'victory';
    
    // Clear remaining objects
    bullets = [];
    lavaDrops = [];
    powerups = [];
    extraLifeDrops = [];
    explosions = [];
    asteroids = [];
    
    // Massive final bonus for completing all 20 levels
    const finalBonus = lives * 200 + 10000;
    const finalScore = score + finalBonus;
    score = finalScore;

    
    // Show victory screen with initial values
document.getElementById('victoryCurrentScore').textContent = '0';
document.getElementById('finalBonus').textContent = '0';
document.getElementById('finalKills').textContent = '0';
document.getElementById('finalScore').textContent = '0';

showScreen('victory');
playBackgroundMusic(0);

// Sequential animation with 4 phases for victory
const totalAnimationDuration = 5000; // 5 seconds total
const phaseCount = 4;
const phaseDuration = totalAnimationDuration / phaseCount; // 1.25 seconds per phase

let currentPhase = 0;
let phaseStartTime = Date.now();
let lastSoundTime = 0;
const soundInterval = 250;

// Animation sequence: Current Score -> Final Bonus -> Total UFOs -> Final Score
const victoryAnimationSequence = [
    {
        element: 'victoryCurrentScore',
        targetValue: score,
        currentValue: 0
    },
    {
        element: 'finalBonus',
        targetValue: finalBonus,
        currentValue: 0
    },
    {
        element: 'finalKills',
        targetValue: totalUfoKills,
        currentValue: 0
    },
    {
        element: 'finalScore',
        targetValue: finalScore,
        currentValue: 0
    }
];

let victoryAnimationStopped = false;

function animateVictoryScoresSequentially() {
    const now = Date.now();
    
    // Play counter sound - only start once, let it loop
// Start counter sound once at beginning
if (currentPhase === 0 && !window.counterSoundPlaying) {
    console.log("🔊 Starting counter sound for score animation");
    window.counterSoundPlaying = true;
    if (gameSounds.counter) {
        gameSounds.counter.play();
    }
// FIXED: Set timer to stop sound after animation duration
window.counterSoundTimer = setTimeout(() => {
    console.log("⏰ Timer stopping victory counter sound after 5 seconds");
    if (gameSounds.counter && gameSounds.counter.stop) {
        gameSounds.counter.stop();
    }
}, 5000); // Stop after 5 seconds for victory
}
    
    // Check if we should move to the next phase
    const phaseElapsed = now - phaseStartTime;
    if (phaseElapsed >= phaseDuration && currentPhase < phaseCount - 1) {
        // Complete current phase
        const currentAnim = victoryAnimationSequence[currentPhase];
        document.getElementById(currentAnim.element).textContent = currentAnim.targetValue;
        
        // Move to next phase
        currentPhase++;
        phaseStartTime = now;
    }
    
    if (currentPhase < phaseCount) {
        // Animate current phase
        const currentAnim = victoryAnimationSequence[currentPhase];
        const phaseProgress = Math.min((now - phaseStartTime) / phaseDuration, 1);
        
        const currentValue = Math.floor(
            currentAnim.currentValue + 
            (currentAnim.targetValue - currentAnim.currentValue) * phaseProgress
        );
        
        document.getElementById(currentAnim.element).textContent = currentValue;
        
        requestAnimationFrame(animateVictoryScoresSequentially);
    } else {
    // Animation complete - stop counter sound and set final values
    console.log("🔇 Animation complete - stopping counter sound");
    if (gameSounds.counter && gameSounds.counter.stop) {
        gameSounds.counter.stop();
    }
    
    // Ensure all values are set to their final targets
    animationSequence.forEach(anim => {
        document.getElementById(anim.element).textContent = anim.targetValue;
    });
    
    // Update the actual game score
    score = finalTotalScore;

        
        // Victory sounds after animation
        if (gameSounds.powerup) {
            setTimeout(() => gameSounds.powerup.play(), 500);
            setTimeout(() => gameSounds.powerup.play(), 1000);
            setTimeout(() => gameSounds.powerup.play(), 1500);
        }
    }
}

window.stopVictoryAnimation = function() {
    victoryAnimationStopped = true;
    if (gameSounds.counter && gameSounds.counter.stop) {
        gameSounds.counter.stop();
    }
};
// Start animation after a short delay
setTimeout(animateVictoryScoresSequentially, 1000);
}

        // EXTENDED: Boss explosion for all 4 boss levels
        function createBossExplosion(boss) {
            if (!boss) {
                console.error("Invalid boss object in createBossExplosion");
                return;
            }
            
            const bossX = boss.x + boss.width / 2;
            const bossY = boss.y + boss.height / 2;
            const bossWidth = boss.width;
            const bossHeight = boss.height;
            const bossLevel = boss.bossLevel || level;
            
            console.log(`Creating boss explosion for level ${bossLevel}`);
            
            // Boss-specific colors
            let primaryColor, secondaryColor, tertiaryColor;
            if (bossLevel === 5) {
                primaryColor = COLORS.NEON_GREEN;
                secondaryColor = COLORS.NEON_YELLOW;
                tertiaryColor = COLORS.CYAN;
            } else if (bossLevel === 10) {
                primaryColor = COLORS.NEON_PINK;
                secondaryColor = COLORS.NEON_YELLOW;
                tertiaryColor = COLORS.PURPLE;
            } else if (bossLevel === 15) {
                primaryColor = COLORS.NEON_PURPLE;
                secondaryColor = COLORS.NEON_PINK;
                tertiaryColor = COLORS.NEON_YELLOW;
            } else if (bossLevel === 20) {
                primaryColor = COLORS.NEON_ORANGE;
                secondaryColor = COLORS.NEON_PINK;
                tertiaryColor = COLORS.NEON_GREEN;
            }
            
            if (gameLoop) {
                cancelAnimationFrame(gameLoop);
                gameLoop = null;
            }
            
            keys = {};
            gameState = 'bossExplosion';
            
            const explosionCanvas = overlayCanvas;
            const explosionCtx = overlayCtx;
            explosionCtx.drawImage(gameCanvas, 0, 0);
            
            // Play explosion sounds
            try {
                if (gameSounds.explosion) {
                    gameSounds.explosion.play();
                }
            } catch (e) {}
            
            let soundCount = 0;
            const maxSounds = bossLevel >= 15 ? 8 : 6;
            
            const playStaggedSound = () => {
                if (soundCount < maxSounds) {
                    try {
                        if (gameSounds.explosion) {
                            gameSounds.explosion.play();
                        }
                        soundCount++;
                        setTimeout(playStaggedSound, 300);
                    } catch (e) {}
                }
            };
            
            setTimeout(playStaggedSound, 300);
            
            const overlayDiv = document.createElement('div');
            overlayDiv.id = 'bossExplosionOverlay';
            overlayDiv.style.position = 'absolute';
            overlayDiv.style.top = '0';
            overlayDiv.style.left = '0';
            overlayDiv.style.width = '100%';
            overlayDiv.style.height = '100%';
            overlayDiv.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
            overlayDiv.style.zIndex = '5';
            document.getElementById('gameContainer').appendChild(overlayDiv);
            
            let explosionStep = 0;
            const totalSteps = bossLevel >= 15 ? 80 : 60;
            
            function animateBossExplosion() {
                explosionCtx.clearRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                explosionCtx.drawImage(gameCanvas, 0, 0);
                
                // Enhanced shockwave
                if (explosionStep < 40) {
                    const radius = explosionStep * bossWidth / 8;
                    explosionCtx.beginPath();
                    explosionCtx.arc(bossX, bossY, radius, 0, Math.PI * 2);
                    explosionCtx.strokeStyle = primaryColor;
                    explosionCtx.lineWidth = bossLevel >= 15 ? 8 : 5;
                    explosionCtx.globalAlpha = 1 - (explosionStep / 40);
                    explosionCtx.stroke();
                    explosionCtx.globalAlpha = 1;
                }
                
                // Enhanced random explosions
                const explosionCount = bossLevel >= 15 ? 5 : 3;
                for (let i = 0; i < explosionCount; i++) {
                    const offsetX = (Math.random() - 0.5) * bossWidth * 3 * (explosionStep / 20);
                    const offsetY = (Math.random() - 0.5) * bossHeight * 3 * (explosionStep / 20);
                    const size = Math.random() * 50 + 20;
                    const color = [primaryColor, secondaryColor, tertiaryColor][Math.floor(Math.random() * 3)];
                    
                    explosionCtx.beginPath();
                    explosionCtx.arc(bossX + offsetX, bossY + offsetY, size, 0, Math.PI * 2);
                    explosionCtx.fillStyle = color;
                    explosionCtx.globalAlpha = 0.8;
                    explosionCtx.fill();
                    explosionCtx.globalAlpha = 1;
                }
                
                // Enhanced fragment creation
                if (explosionStep % 2 === 0 && explosionStep < 50) {
                    const fragmentCount = bossLevel >= 15 ? 12 : 8;
                    for (let i = 0; i < fragmentCount; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = Math.random() * 20 + 8;
                        const lifetime = Math.random() * 350 + 300;
                        const fragmentSize = Math.random() * 20 + 12;
                        const fragmentX = bossX + (Math.random() - 0.5) * 40;
                        const fragmentY = bossY + (Math.random() - 0.5) * 40;
                        
                        let fragmentColor;
                        if (Math.random() < 0.6) {
                            fragmentColor = primaryColor;
                        } else if (Math.random() < 0.5) {
                            fragmentColor = secondaryColor;
                        } else {
                            fragmentColor = tertiaryColor;
                        }
                        
                        lavaDrops.push({
                            x: fragmentX,
                            y: fragmentY,
                            width: fragmentSize,
                            height: fragmentSize,
                            speed: 0,
                            velocityX: Math.cos(angle) * speed,
                            velocityY: Math.sin(angle) * speed,
                            pulse: Math.random() + 0.8,
                            growing: Math.random() < 0.5,
                            rotation: Math.random() * 360,
                            rotationSpeed: Math.random() * 60 - 30,
                            lifetime: lifetime,
                            isFragment: true,
                            color: fragmentColor,
                            level: bossLevel
                        });
                    }
                }
                
                // Enhanced flash effects
                if (explosionStep === 8 || explosionStep === 18 || explosionStep === 28 || 
                    (bossLevel >= 15 && explosionStep === 38)) {
                    explosionCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    explosionCtx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                }
                
                // Boss defeated text
                if (explosionStep >= 35) {
                    explosionCtx.font = bossLevel >= 15 ? '50px monospace' : '40px monospace';
                    explosionCtx.textAlign = 'center';
                    explosionCtx.fillStyle = primaryColor;
                    explosionCtx.shadowColor = 'white';
                    explosionCtx.shadowBlur = 20;
                    
                    let defeatedText = 'BOSS DEFEATED';
                    if (bossLevel === 20) defeatedText = 'FINAL BOSS DEFEATED!';
                    else if (bossLevel >= 15) defeatedText = 'MEGA BOSS DEFEATED!';
                    
                    explosionCtx.fillText(defeatedText, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 - 20);
                    
                    if (explosionStep >= 50) {
                        explosionCtx.font = '24px monospace';
                        explosionCtx.fillStyle = secondaryColor;
                        explosionCtx.fillText('PRESS SPACE OR ENTER TO CONTINUE', SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 + 40);
                    }
                }
                
                explosionStep++;
                
                if (explosionStep < totalSteps) {
                    requestAnimationFrame(animateBossExplosion);
                } else {
                    const handleKeyPress = function(e) {
                        if (e.key === ' ' || e.key === 'Enter') {
                            overlayDiv.remove();
                            explosionCtx.clearRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                            window.removeEventListener('keydown', handleKeyPress);
                            
                            if (level === 20 && bossLevel === 20) {
                                victory();
                            } else {
                                levelComplete();
                            }
                        }
                    };
                    
                    setTimeout(() => {
                        window.addEventListener('keydown', handleKeyPress);
                    }, 500);
                    
                    setTimeout(() => {
                        if (document.getElementById('bossExplosionOverlay')) {
                            overlayDiv.remove();
                            explosionCtx.clearRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                            window.removeEventListener('keydown', handleKeyPress);
                            
                            if (level === 20 && bossLevel === 20) {
                                victory();
                            } else {
                                levelComplete();
                            }
                        }
                    }, 12000);
                }
            }
            
            animateBossExplosion();
        }

        // For å håndtere tastetrykk under alle screens
        function handleKeyPress(e) {
            console.log(`Key pressed: ${e.key} in game state: ${gameState}`);
            
            // Sjekk først om highscore input er åpen og aktiv
            const highscoreInput = document.getElementById('highscoreInput');
            const nameInput = document.getElementById('playerNameInput');
            
            // Hvis vi er i input-modus, avbryt all vanlig tastenavigasjon
            if (highscoreInput && !highscoreInput.classList.contains('hidden') && 
                document.activeElement === nameInput) {
                // Tillat bare Enter eller Escape for å sende/avbryte
                if (e.key === 'Enter') {
                    // Sende skår
                    submitHighscore();
                } else if (e.key === 'Escape') {
                    // Eventuelt avbryt, eller bare la vanlig inputboks-atferd håndtere dette
                }
                // Ikke prosesser andre taster for spillnavigasjon
                return;
            }
            
            // Vanlig spillnavigasjon fortsetter kun hvis vi ikke er i input-modus
            switch(gameState) {
            case 'start':
                // Aksepter alle taster i stedet for bare Enter og Space
                showIntroScreen();
                break;
            case 'intro':
                if (!introTextComplete) {
                    // Skip til slutten av teksten med hvilken som helst tast
                    completeIntroText();
                } else {
                    // Start spillet med hvilken som helst tast
                    startGame();
                }
                break;
            case 'levelStart':
                // Fortsatt ingen mulighet til å hoppe over dette
                break;
            case 'playing':
                // Spillkontrollene håndteres i spillets hovedløkke
                break;
            case 'levelComplete':
                // Hvilken som helst tast for å fortsette til neste nivå
                nextLevel();
                break;
            case 'gameOver':
                // Beholder spesifikke taster for ulike handlinger
                if (e.key === '1' || e.key === 'r' || e.key === 'R') {
                    restartGame();
                } else if (e.key === '2' || e.key === 'Escape') {
                    location.reload();
                } else if (e.key === 'h' || e.key === 'H') {
                    showHighscores();
                }
                break;
            case 'credits':
                // Hvilken som helst tast går tilbake til highscores
                showHighscores();
                break;
            case 'highscores':
                // Hvilken som helst tast går tilbake til game over-skjermen
                showScreen('gameOver');
                break;
            case 'victory':
                // Any key to continue
                endGame();
                break;
            }
        }

        function showScreen(screenName) {
            console.log(`Showing screen: ${screenName} (current state: ${gameState})`);
            if (gameSounds.counter && gameSounds.counter.stop) {
            gameSounds.counter.stop();
            }
            // Save previous state for music handling
            const previousState = gameState;
            
            // Hide all screens first
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('introScreen').classList.add('hidden');
            document.getElementById('levelStartScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('highscoresScreen').classList.add('hidden');
            document.getElementById('levelCompleteScreen').classList.add('hidden');
            document.getElementById('victoryScreen').classList.add('hidden');
            
            
            const creditsScreen = document.getElementById('creditsScreen');
            if (creditsScreen) {
                creditsScreen.classList.add('hidden');
            }
            // Show the specified screen
            if (screenName === 'start') {
                const startScreen = document.getElementById('startScreen');
                startScreen.classList.remove('hidden');
                gameState = 'start';
            } else if (screenName === 'intro') {
                document.getElementById('introScreen').classList.remove('hidden');
                gameState = 'intro';
            } else if (screenName === 'levelStart') {
                document.getElementById('levelStartScreen').classList.remove('hidden');
                document.getElementById('levelNumber').textContent = level;
                gameState = 'levelStart';
            } else if (screenName === 'gameOver') {
                document.getElementById('gameOverScreen').classList.remove('hidden');
                gameState = 'gameOver';
                
                // Play title music on game over
                playBackgroundMusic(0);
            } else if (screenName === 'highscores') {
                document.getElementById('highscoresScreen').classList.remove('hidden');
                gameState = 'highscores';
            } else if (screenName === 'levelComplete') {
                document.getElementById('levelCompleteScreen').classList.remove('hidden');
                gameState = 'levelComplete';
            } else if (screenName === 'victory') {
                document.getElementById('victoryScreen').classList.remove('hidden');
                gameState = 'victory';
                
                // Play victory music (use title music for now)
                playBackgroundMusic(0);
            } else if (screenName === 'playing') {
                // Just update the game state for playing, no specific screen to show
                gameState = 'playing';
            }
            
            // Show mobile controls only during gameplay
            if (screenName === 'playing' && 'ontouchstart' in window) {
                document.getElementById('mobileControls').style.display = 'flex';
            } else {
                document.getElementById('mobileControls').style.display = 'none';
            }
        }

        function gameOver() {
            console.log(`🚨 GAME OVER CALLED: Lives = ${lives}, Level = ${level}, Score = ${score}`);
            console.log(`📊 Game stats: gameState = ${gameState}, UFOs remaining = ${ufos.length}`);
            
            // FIXED: Prevent multiple calls to gameOver
            if (gameState === 'gameOver') {
                console.log("Game Over already called, ignoring duplicate call");
                return;
            }
            
            gameState = 'gameOver'; // Set immediately to prevent multiple calls
            
            if (gameLoop) {
                cancelAnimationFrame(gameLoop);
                gameLoop = null;
            }
            
            loadHighscores();
            
            setTimeout(() => {
                const isHighscore = checkHighscore(score);
                
                if (isHighscore) {
                    if (!document.getElementById('highscore-animation-style')) {
                        const style = document.createElement('style');
                        style.id = 'highscore-animation-style';
                        style.textContent = `
                            @keyframes textPulse {
                                0% { text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #39FF14, 0 0 20px #39FF14; opacity: 1; }
                                50% { text-shadow: 0 0 2px #fff, 0 0 5px #39FF14; opacity: 0.7; }
                                100% { text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #39FF14, 0 0 20px #39FF14; opacity: 1; }
                            }
                            
                            .highscore-animation {
                                font-size: 1.5rem;
                                text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #39FF14, 0 0 20px #39FF14;
                                animation: textPulse 0.8s infinite alternate;
                                margin-bottom: 15px;
                                letter-spacing: 2px;
                            }
                        `;
                        document.head.appendChild(style);
                    }
                    
                    document.getElementById('highscoreInput').classList.remove('hidden');
                    
                    const highscoreText = document.querySelector('#highscoreInput .neon-text');
                    highscoreText.textContent = 'GLOBAL HIGHSCORE!';
                    highscoreText.classList.add('highscore-animation');
                    
                    if (gameSounds.powerup) {
                        gameSounds.powerup.play();
                    }
                    
                    setTimeout(() => {
                        document.getElementById('playerNameInput').focus();
                    }, 200);
                } else {
                    showHighscores();
                    startScreenRotation();
                }
                
                showScreen('gameOver');
            }, 500);
        }

        function restartGame() {
            console.log("Restarting game");
            // FIXED: Stop any running animations
if (window.stopLevelCompleteAnimation) {
    window.stopLevelCompleteAnimation();
}
if (window.stopVictoryAnimation) {
    window.stopVictoryAnimation();
}
            
            if (screenRotationTimer) {
                clearInterval(screenRotationTimer);
                screenRotationTimer = null;
            }
            
            level = 1;
            score = 0;
            lives = 5;
            
            startGame();
        }

        function endGame() {
            console.log("Ending game");
            // FIXED: Stop any running animations
if (window.stopLevelCompleteAnimation) {
    window.stopLevelCompleteAnimation();
}
if (window.stopVictoryAnimation) {
    window.stopVictoryAnimation();
}
            const isHighscore = highscores.length < 10 || score > highscores[highscores.length - 1].score;
            
            if (isHighscore) {
                document.getElementById('highscoreInput').classList.remove('hidden');
                document.getElementById('playerNameInput').focus();
                showScreen('gameOver');
            } else {
                showHighscores();
                startScreenRotation();
            }
        }

        function loadHighscores() {
            console.log("Loading highscores from Firebase");
            
            const highscoreList = document.getElementById('highscoreList');
            if (highscoreList) {
                highscoreList.innerHTML = '<div style="text-align: center; color: #39FF14;">LOADING HIGHSCORES...</div>';
            }
            
            db.collection("highscores")
              .orderBy("score", "desc")
              .limit(20)
              .get()
              .then((querySnapshot) => {
                  highscores = [];
                  querySnapshot.forEach((doc) => {
                      highscores.push(doc.data());
                  });
                  console.log("Loaded " + highscores.length + " highscores from Firebase");
                  
                  if (gameState === 'highscores') {
                      displayHighscores();
                  }
              })
              .catch((error) => {
                  console.error("Error loading highscores:", error);
                  const savedHighscores = localStorage.getItem('evilInvadersHighscores');
                  if (savedHighscores) {
                      try {
                          highscores = JSON.parse(savedHighscores);
                      } catch (e) {
                          console.error("Error parsing local highscores:", e);
                          createDefaultHighscores();
                      }
                  } else {
                      createDefaultHighscores();
                  }
              });
        }

        function createDefaultHighscores() {
            highscores = [
                { name: 'BOENZA', score: 10000, level: 20 },
                { name: 'CHAMPION', score: 8000, level: 18 },
                { name: 'MASTER', score: 6000, level: 15 },
                { name: 'EXPERT', score: 4000, level: 12 },
                { name: 'ROOKIE', score: 2000, level: 10 }
            ];              
            saveHighscores();
        }

        function checkHighscore(score) {
            if (highscores.length < 20) return true;
            const lowestScore = Math.min(...highscores.map(hs => hs.score));
            return score > lowestScore;
        }

        function saveHighscores() {
            localStorage.setItem('evilInvadersHighscores', JSON.stringify(highscores));
        }

        function submitHighscore() {
            const playerName = document.getElementById('playerNameInput').value.trim() || 'PLAYER';
            const timestamp = new Date().toISOString();
            
            const sanitizedName = playerName.replace(/[^a-zA-ZæøåÆØÅ0-9\s]/gi, '').substring(0, 15);

            const highscoreData = {
                name: sanitizedName,
                score: score,
                level: level,
                date: timestamp,
                gameVersion: "Extended-20-Levels"
            };
            
            console.log("Submitting highscore:", highscoreData);
            
            db.collection("highscores").add(highscoreData)
                .then((docRef) => {
                    console.log("Highscore saved with ID:", docRef.id);
                    loadHighscores();
                    document.getElementById('highscoreInput').classList.add('hidden');
                    isNewHighscore = false;
                    showHighscores();
                    startScreenRotation();
                })
                .catch((error) => {
                    console.error("Error adding highscore:", error);
                    highscores.push(highscoreData);
                    highscores.sort((a, b) => b.score - a.score);
                    highscores = highscores.slice(0, 20);
                    localStorage.setItem('evilInvadersHighscores', JSON.stringify(highscores));
                    
                    document.getElementById('highscoreInput').classList.add('hidden');
                    isNewHighscore = false;
                    showHighscores();
                    startScreenRotation();
                });
        }

        function showHighscores() {
            console.log("Showing highscores screen");
            displayHighscores();
            showScreen('highscores');
            
            const highscoreTitle = document.querySelector('#highscoresScreen h1');
            if (highscoreTitle) {
                highscoreTitle.className = 'neon-pink';
                highscoreTitle.style.textShadow = '0 0 5px #fff, 0 0 10px #fff, 0 0 15px #FF14A3, 0 0 20px #FF14A3';
                highscoreTitle.style.animation = 'textPulse 1.5s infinite';
                highscoreTitle.style.marginBottom = '30px';
                highscoreTitle.style.fontSize = '3rem';
            }
        }

        function displayHighscores() {
            console.log("Displaying highscores");
            
            const highscoreList = document.getElementById('highscoreList');
            if (!highscoreList) {
                console.error("Highscore list element not found!");
                return;
            }
            
            highscoreList.innerHTML = '';
            
            // Create header
            const header = document.createElement('div');
            header.className = 'highscore-item';
            header.innerHTML = '<span>RANK</span><span>NAME</span><span>SCORE</span><span>LEVEL</span>';
            header.style.color = COLORS.NEON_GREEN;
            header.style.textShadow = `0 0 8px ${COLORS.NEON_GREEN}, 0 0 12px ${COLORS.NEON_GREEN}`;
            header.style.marginBottom = '10px';
            header.style.borderBottom = `2px solid ${COLORS.NEON_GREEN}`;
            header.style.fontWeight = 'bold';
            header.style.display = 'grid';
            header.style.gridTemplateColumns = '0.7fr 2fr 1fr 0.7fr';
            highscoreList.appendChild(header);
            
            // Neon colors for top 20
            const neonColors = [
                COLORS.NEON_PINK, COLORS.NEON_YELLOW, COLORS.NEON_GREEN, COLORS.CYAN, COLORS.NEON_YELLOW,
                COLORS.NEON_PINK, COLORS.NEON_GREEN, COLORS.CYAN, COLORS.NEON_YELLOW, COLORS.NEON_PINK,
                '#FF9966', '#66FFFF', '#CCFF99', '#FF99CC', '#99CCFF',
                '#FFCC99', '#CCFFFF', '#FFFFCC', '#FFCCFF', '#CCCCFF'
            ];
            
            // Add each highscore
            highscores.forEach((scoreEntry, index) => {
                if (index >= 20) return;
                
                const item = document.createElement('div');
                item.className = 'highscore-item';
                
                item.style.display = 'grid';
                item.style.gridTemplateColumns = '0.7fr 2fr 1fr 0.7fr';
                item.style.padding = '8px 0';
                item.style.marginBottom = '5px';
                item.style.borderBottom = '1px solid rgba(255, 255, 255, 0.2)';
                
                // Format rank
                let rankText;
                if (index === 0) rankText = '1ST';
                else if (index === 1) rankText = '2ND';
                else if (index === 2) rankText = '3RD';
                else rankText = `${index + 1}TH`;
                
                const neonColor = neonColors[index % neonColors.length];
                item.style.color = neonColor;
                item.style.textShadow = `0 0 5px ${neonColor}, 0 0 10px ${neonColor}, 0 0 15px rgba(255,255,255,0.5)`;
                
                const levelText = scoreEntry.level ? `${scoreEntry.level}` : '-';
                
                item.innerHTML = `
                    <span>${rankText}</span>
                    <span>${scoreEntry.name}</span>
                    <span>${scoreEntry.score.toLocaleString()}</span>
                    <span>${levelText}</span>
                `;
                
                highscoreList.appendChild(item);
            });
            
            if (highscores.length === 0) {
                const noScores = document.createElement('div');
                noScores.textContent = 'LOADING GLOBAL HIGHSCORES...';
                noScores.style.color = COLORS.NEON_YELLOW;
                noScores.style.textShadow = `0 0 5px ${COLORS.NEON_YELLOW}, 0 0 10px ${COLORS.NEON_YELLOW}`;
                noScores.style.textAlign = 'center';
                noScores.style.marginTop = '20px';
                highscoreList.appendChild(noScores);
            }
        }

        function startScreenRotation() {
            if (screenRotationTimer) {
                clearInterval(screenRotationTimer);
            }
            
            currentRotationScreen = 'gameOver';
            showScreen('gameOver');
            
            if (!backgroundMusic || backgroundMusic.paused || 
                !backgroundMusic.src.endsWith('Evil Invaders.mp3')) {
                playBackgroundMusic(0);
            }
            
            function rotateToNextScreen() {
                const highscoreInput = document.getElementById('highscoreInput');
                if (highscoreInput && !highscoreInput.classList.contains('hidden')) {
                    screenRotationTimer = setTimeout(rotateToNextScreen, 30000);
                    return;
                }
                
                if (currentRotationScreen === 'gameOver') {
                    currentRotationScreen = 'highscores';
                    showHighscores();
                    screenRotationTimer = setTimeout(rotateToNextScreen, 10000);
                } else {
                    currentRotationScreen = 'gameOver';
                    showScreen('gameOver');
                    screenRotationTimer = setTimeout(rotateToNextScreen, 5000);
                }
            }
            
            screenRotationTimer = setTimeout(rotateToNextScreen, 5000);
        }

        console.log("Evil Invaders II Extended Edition - 20 Levels Ready!");
    </script>
</body>
</html>
