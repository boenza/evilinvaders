<!DOCTYPE html>
<html lang="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EVIL INVADERS II</title>
    <style>
        /* Inline CSS for å unngå path-problemer */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
            background-color: #000;
        }

        #gameCanvas, #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #startScreen, #introScreen, #levelStartScreen, #gameOverScreen, 
        #highscoresScreen, #levelCompleteScreen, #victoryScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 10;
        }

        #startScreen {
            justify-content: flex-end;
            padding-bottom: 10vh;
        }

        #titleBackground {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: -1;
        }

        .press-enter {
            margin-bottom: 5vh;
            z-index: 10;
            font-size: 2rem;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
        }

        .hidden {
            display: none !important;
        }

        #introScreen {
            color: #fff;
            text-align: center;
        }

        #story {
            margin: 20px auto;
            max-width: 80%;
            text-align: left;
        }

        .story-line {
            font-family: monospace;
            font-size: 1.2rem;
            line-height: 1.8;
            margin-bottom: 8px;
            color: #39FF14;
            text-shadow: 0 0 5px #39FF14;
        }

        #levelStartScreen {
            font-size: 3rem;
        }

        #countdownTimer {
            font-size: 5rem;
            margin-top: 20px;
        }

        #gameOverScreen h1 {
            margin-bottom: 30px;
        }

        #gameOverScreen button, #highscoresScreen button {
            display: block;
            margin: 15px auto;
            padding: 10px 20px;
            font-size: 1.2rem;
            background-color: rgba(0, 0, 0, 0.7);
            color: #39FF14;
            border: 2px solid #39FF14;
            border-radius: 5px;
            cursor: pointer;
            text-shadow: 0 0 5px #39FF14;
        }

        #gameOverScreen button:hover, #highscoresScreen button:hover {
            background-color: rgba(57, 255, 20, 0.2);
        }

        #highscoresScreen h1 {
            margin-bottom: 30px;
        }

        #highscoreList {
            width: 80%;
            max-width: 600px;
            margin: 0 auto 30px auto;
        }

        .highscore-item {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            padding: 8px 0;
            margin-bottom: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        #levelCompleteScreen h1 {
            margin-bottom: 30px;
        }

        #levelCompleteScreen div {
            margin: 10px 0;
            font-size: 1.2rem;
        }

        #victoryScreen h1 {
            margin-bottom: 30px;
        }

        #victoryScreen div {
            margin: 15px 0;
            font-size: 1.5rem;
        }

        #mobileControls {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            display: none;
            justify-content: space-around;
            padding: 10px;
            z-index: 15;
        }

        #mobileControls div {
            background-color: rgba(0, 0, 0, 0.6);
            color: #fff;
            padding: 15px 25px;
            border-radius: 50px;
            font-size: 24px;
            border: 2px solid #39FF14;
            text-shadow: 0 0 5px #39FF14;
            user-select: none;
            -webkit-user-select: none;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }

        .blink {
            animation: pulse 1.5s infinite;
        }

        .neon-text {
            text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #0073e6, 0 0 20px #0073e6, 0 0 25px #0073e6;
            color: #fff;
        }

        .neon-green {
            text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #39FF14, 0 0 20px #39FF14, 0 0 25px #39FF14;
            color: #39FF14;
        }

        .neon-pink {
            text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #FF14A3, 0 0 20px #FF14A3, 0 0 25px #FF14A3;
            color: #FF14A3;
        }

        .neon-yellow {
            text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #FFFF66, 0 0 20px #FFFF66, 0 0 25px #FFFF66;
            color: #FFFF66;
        }

        #highscoreInput {
            margin-top: 20px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #39FF14;
            border-radius: 10px;
            text-align: center;
        }

        .nameInput {
            display: block;
            margin: 15px auto;
            padding: 10px;
            width: 80%;
            max-width: 300px;
            font-size: 1.2rem;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            border: 2px solid #39FF14;
            border-radius: 5px;
            text-align: center;
        }

        #submitScoreBtn {
            display: block;
            margin: 10px auto;
            padding: 8px 20px;
            font-size: 1.1rem;
            background-color: rgba(0, 0, 0, 0.7);
            color: #39FF14;
            border: 2px solid #39FF14;
            border-radius: 5px;
            cursor: pointer;
            text-shadow: 0 0 5px #39FF14;
        }

        #submitScoreBtn:hover {
            background-color: rgba(57, 255, 20, 0.2);
        }

        @media (max-width: 768px) {
            .press-enter {
                font-size: 1.5rem;
                padding: 10px;
            }
            
            .story-line {
                font-size: 1rem;
            }
            
            #levelStartScreen {
                font-size: 2.5rem;
            }
            
            #countdownTimer {
                font-size: 4rem;
            }
        }

        @media (max-width: 480px) {
            .press-enter {
                font-size: 1.2rem;
                padding: 8px;
            }
            
            .story-line {
                font-size: 0.9rem;
            }
            
            #levelStartScreen {
                font-size: 2rem;
            }
            
            #countdownTimer {
                font-size: 3rem;
            }
        }
        #initialScreen h1 {
        margin-bottom: 40px;
        font-size: 3rem;
    }
    
    #musicPlayButton {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 1000;
        padding: 5px 10px;
        background-color: rgba(0, 0, 0, 0.7);
        color: #39FF14;
        border: 2px solid #39FF14;
        border-radius: 5px;
        cursor: pointer;
        text-shadow: 0 0 5px #39FF14;
    }
    #highscoreList {
    width: 90%;
    max-width: 800px;
    margin: 0 auto 30px auto;
    max-height: 70vh;
    overflow-y: auto;
    padding: 10px;
    background-color: rgba(0, 0, 0, 0.5);
    border-radius: 10px;
    border: 1px solid rgba(57, 255, 20, 0.3);
}

.highscore-item {
    display: grid;
    grid-template-columns: 0.7fr 2fr 1fr 0.7fr;
    padding: 8px 0;
    margin-bottom: 5px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.2);
}

/* Styling for scrollbar */
#highscoreList::-webkit-scrollbar {
    width: 10px;
}

#highscoreList::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.5);
    border-radius: 5px;
}

#highscoreList::-webkit-scrollbar-thumb {
    background: #39FF14;
    border-radius: 5px;
}

#highscoreList::-webkit-scrollbar-thumb:hover {
    background: #FFFF66;
}
    
    /* Add improved animations for text pulsing */
    @keyframes textPulse {
        0% { text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #0073e6, 0 0 20px #0073e6; opacity: 1; }
        50% { text-shadow: 0 0 2px #fff, 0 0 5px #0073e6; opacity: 0.7; }
        100% { text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #0073e6, 0 0 20px #0073e6; opacity: 1; }
    }
    
    .text-pulse {
        animation: textPulse 1.5s infinite;
    }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <canvas id="overlayCanvas" width="800" height="600"></canvas>

        <div id="startScreen">
            <h1 class="neon-pink">EVIL INVADERS II</h1>
            <div class="press-enter neon-text blink">PRESS ENTER TO PLAY</div>
        </div>
        
        <!-- Intro Story Screen -->
        <div id="introScreen" class="hidden">
            <h1>EVIL INVADERS II</h1>
            <div id="story">
                <div class="story-line" id="storyLine1"></div>
                <div class="story-line" id="storyLine2"></div>
                <div class="story-line" id="storyLine3"></div>
                <div class="story-line" id="storyLine4"></div>
                <div class="story-line" id="storyLine5"></div>
                <div class="story-line" id="storyLine6"></div>
                <div class="story-line" id="storyLine7"></div>
                <div class="story-line" id="storyLine8"></div>
                <div class="story-line" id="storyLine9"></div>
                <div class="story-line" id="storyLine10"></div>
                <div class="story-line" id="storyLine11"></div>
            </div>
            <div class="press-enter neon-green hidden" id="startPrompt">PRESS SPACE TO START</div>
        </div>

        <!-- Level Start Screen -->
        <div id="levelStartScreen" class="hidden">
            <div class="neon-text">LEVEL</div>
            <div id="levelNumber" class="neon-text">1</div>
            <div id="countdownTimer" class="neon-text">3</div>
        </div>

        <!-- Game Over Screen -->
        <div id="gameOverScreen" class="hidden">
            <h1 class="neon-pink">GAME OVER</h1>
            <button id="retryBtn">1. RETRY</button>
            <button id="exitBtn">2. EXIT</button>
            <button id="highscoresBtn" style="display: none;">H. HIGHSCORES</button>
            <div id="highscoreInput" class="hidden">
                <div class="neon-text">NEW HIGHSCORE!</div>
                <input type="text" class="nameInput" id="playerNameInput" maxlength="15" placeholder="Enter your name">
                <button id="submitScoreBtn">SUBMIT</button>
            </div>
        </div>
            <button id="backFromCreditsBtn" style="display: none;">BACK</button>
        </div>
        <!-- Highscores Screen -->
        <div id="highscoresScreen" class="hidden">
            <h1>HIGH SCORES</h1>
            <div id="highscoreList"></div>
            <button id="backToGameOverBtn" style="display: none;">BACK</button>
        </div>

        <!-- Level Complete Screen -->
        <div id="levelCompleteScreen" class="hidden">
            <h1 class="neon-pink">LEVEL <span id="completedLevel">1</span> COMPLETE!</h1>
            <div class="neon-green">Score: <span id="currentScore">0</span></div>
            <div class="neon-green">Time Bonus: <span id="timeBonus">0</span></div>
            <div class="neon-green">Life Bonus: <span id="lifeBonus">0</span></div>
            <div class="neon-yellow">Total Bonus: <span id="totalBonus">0</span></div>
            <div class="press-enter neon-text blink">PRESS ENTER TO CONTINUE</div>
        </div>

        <!-- Victory Screen -->
        <div id="victoryScreen" class="hidden">
            <h1 class="neon-text">YOU WON THE GAME!</h1>
            <div class="neon-green">FINAL BONUS: <span id="finalBonus">0</span></div>
            <div class="neon-pink">FINAL SCORE: <span id="finalScore">0</span></div>
            <div class="press-enter neon-text blink">PRESS ANY KEY TO CONTINUE</div>
        </div>
    

        <!-- Mobile Controls -->
        <div id="mobileControls">
            <div id="moveLeftBtn">←</div>
            <div id="fireBtn">FIRE</div>
            <div id="moveRightBtn">→</div>
        </div>
    </div>
    <!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>

<script>
  // Din Firebase konfigurasjon
  const firebaseConfig = {
    apiKey: "AIzaSyBHQSa-gRonCbOS-y8eGyq9gQEY9ritBNY",
    authDomain: "evil-invaders-ii.firebaseapp.com",
    projectId: "evil-invaders-ii",
    storageBucket: "evil-invaders-ii.firebasestorage.app",
    messagingSenderId: "354911968962",
    appId: "1:354911968962:web:9dbab52240137e8a85655b"
  };

  // Initialiser Firebase
  firebase.initializeApp(firebaseConfig);

  // Få en Firestore instans
  const db = firebase.firestore();
</script>
    <script>
        // Game Constants
        const SCREEN_WIDTH = 800;
        const SCREEN_HEIGHT = 600;
        const PLAYER_WIDTH = 60;
        const PLAYER_HEIGHT = 60;
        const UFO_WIDTH = 50;
        const UFO_HEIGHT = 30;
        const UFO_ROWS = 4;
        const UFO_COLS = 10;
        const BULLET_WIDTH = 7;
        const BULLET_HEIGHT = 15;
        const BULLET_SPEED = 8;
        const BULLET_COOLDOWN = 500;
        const PLAYER_SPEED = 5;
        const UFO_SPEED = 3;
        const LAVA_WIDTH = 5;
        const LAVA_HEIGHT = 10;
        const LAVA_SPEED = 2;
        const POWERUP_SPEED = 4;
        const EXTRALIFE_SPEED = 3;
        const ASTEROID_SIZE = 40;
        const MAX_LEVEL = 10;
        const BOSS_LEVEL_1 = 5;
        const BOSS_LEVEL_2 = 10;

        // Color Constants
        const COLORS = {
            BLACK: '#000000',
            WHITE: '#FFFFFF',
            YELLOW: '#FFFF00',
            RED: '#FF0000',
            GREEN: '#008000',
            BLUE: '#0000FF',
            PURPLE: '#800080',
            ORANGE: '#FFA500',
            CYAN: '#00FFFF',
            PINK: '#FFC0CB',
            NEON_YELLOW: '#FFFF66',
            NEON_GREEN: '#39FF14',
            NEON_PINK: '#FF14A3'
        };

        // Game Variables
        let gameCanvas, gameCtx, overlayCanvas, overlayCtx;
        let gameState = 'start'; // start, intro, playing, levelStart, gameOver, levelComplete, victory, highscores
        let gameLoop, animationFrameId;
        let screenWidth = 800;
        let screenHeight = 600;
        let lastTime = 0;
        let deltaTime = 0;
        let keys = {};
        let level = 1;
        let score = 0;
        let lives = 5;
        let playerX, playerY;
        let lastShot = 0;
        let bullets = [];
        let ufos = [];
        let lavaDrops = [];
        let powerups = [];
        let extraLifeDrops = [];
        let explosions = [];
        let asteroids = [];
        let highscores = [];
        let introTextTimer = 0;
        let currentIntroLine = 0;
        let currentIntroChar = 0;
        let typingSpeed = 50;
        let introTextComplete = false;
        let levelStartCountdown = 3;
        let countdownTimer = null;
        let lavaDragDrop = 1; // 1 in 1000 chance
        let gameImages = {};
        let gameSounds = {};
        let autoFireEnabled = false;
        let laserSpeed = BULLET_SPEED;
        let laserCount = 1;
        let bossShieldActive = false;
        let bossShieldHealth = 0;
        let bossAttackTimer = 0;
        let bossAttackPattern = 0;
        let largeUfoCreated = false;
        let largeUfo2Created = false;
        let levelExtraLifeDropped = false;
        let levelStartTime = 0;
        let asteroidTimer = 0;
        let asteroidSpawnInterval = 2000;
        let levelParTimes = {
            1: 30000,
            2: 35000,
            3: 40000,
            4: 45000,
            5: 60000,
            6: 50000,
            7: 55000,
            8: 60000,
            9: 65000,
            10: 90000
        };
        let touchActive = false;
        let typingSound = null;
        let typingSoundReady = false;
        let screenRotationTimer = null;
        let currentRotationScreen = 'gameOver';
        let isNewHighscore = false;
        let currentMusicTrack = null;


        // Story Text
        const introText = [
            "YEAR 2228",
            "",
            "Two centuries after Belon Smusk and the PayPal Mafia",
            "bailed to Mars, they're back—and they're pissed.",
            "Mars ran out of neural implant fuel.",
            "Now they're coming back to Earth",
            "But this time as EVIL INVADERS.",
            "",
            "HUMANITY'S LAST STAND BEGINS NOW.",
            "YOU ARE THE FINAL DEFENSE.",
            "Lock. Load. Light 'em up!"
        ];

        // Definer backgroundMusic globalt
        let backgroundMusic = new Audio();
        backgroundMusic.loop = true;
        backgroundMusic.volume = 0.5;

        // Initialize the game when the window loads
        // Endrer window.onload for å bruke loadAssets i stedet for createMockAssets
        window.onload = function() {
    console.log("Window loaded");
    gameCanvas = document.getElementById('gameCanvas');
    gameCtx = gameCanvas.getContext('2d');
    overlayCanvas = document.getElementById('overlayCanvas');
    overlayCtx = overlayCanvas.getContext('2d');
    gameCtx.imageSmoothingEnabled = false;
    gameCtx.imageSmoothingQuality = 'high';
    overlayCtx.imageSmoothingEnabled = false;
    overlayCtx.imageSmoothingQuality = 'high';
    // Initialize event listeners
    initEventListeners();

    // Initialize highscores
    loadHighscores();
    preloadTypingSound();
    
    // Create a very simple initial screen before the actual title screen
    createInitialScreen();
    
    // Setup mobile controls if on a touch device
    if ('ontouchstart' in window) {
        setupMobileControls();
    }
    
    console.log("Game initialized");
};

// Add this new function to create the initial screen
function createInitialScreen() {
    // Create a new div for the initial screen
    const initialScreen = document.createElement('div');
    initialScreen.id = 'initialScreen';
    initialScreen.style.position = 'absolute';
    initialScreen.style.top = '0';
    initialScreen.style.left = '0';
    initialScreen.style.width = '100%';
    initialScreen.style.height = '100%';
    initialScreen.style.backgroundColor = '#000';
    initialScreen.style.display = 'flex';
    initialScreen.style.flexDirection = 'column';
    initialScreen.style.justifyContent = 'center';
    initialScreen.style.alignItems = 'center';
    initialScreen.style.zIndex = '100';
    
    // Add title text
    const title = document.createElement('h1');
    title.textContent = 'EVIL INVADERS II';
    title.className = 'neon-pink';
    title.style.marginBottom = '20px';
    
    // Add instruction text
    const instruction = document.createElement('div');
    instruction.textContent = 'CLICK OR PRESS ANY KEY TO START';
    instruction.className = 'press-enter neon-text blink';
    instruction.style.padding = '15px';
    instruction.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
    instruction.style.borderRadius = '10px';
    
    // Add elements to the initial screen
    initialScreen.appendChild(title);
    initialScreen.appendChild(instruction);
    
    // Add the initial screen to the game container
    document.getElementById('gameContainer').appendChild(initialScreen);
    
    // Event listeners for the initial screen
    const handleInteraction = function() {
        // Remove the initial screen
        initialScreen.remove();
        
        // Load and prepare game assets
        loadAssets().then(() => {
            // Show the real title screen
            showScreen('start');
            
            // Play background music (this is now allowed because the user has interacted)
            playBackgroundMusic(0);
        }).catch(error => {
            console.error("Asset loading failed:", error);
            createMockAssets();
            showScreen('start');
            playBackgroundMusic(0);
        });
        
        // Remove event listeners
        window.removeEventListener('click', handleInteraction);
        window.removeEventListener('keydown', handleInteraction);
        document.removeEventListener('touchstart', handleInteraction);
    };
    
    // Add event listeners for clicks, key presses, and touches
    window.addEventListener('click', handleInteraction);
    window.addEventListener('keydown', handleInteraction);
    document.addEventListener('touchstart', handleInteraction);
}


// Oppdatert loadAssets funksjon med spesifikk fokus på lydfeilsøking
// Oppdatert loadAssets-funksjon fokusert på de spesifikke lydfilene dine
async function loadAssets() {
    console.log("Starting to load assets");
    
    // Load images (uendret)
    const imagesToLoad = [
        { name: 'player', src: 'assets/images/player.png' },
        { name: 'playerLvl3', src: 'assets/images/new_player_ship_lvl3.png' },
        { name: 'playerLvl6', src: 'assets/images/new_player_ship_lvl6.png' },
        { name: 'playerLvl9', src: 'assets/images/new_player_ship_lvl9.png' },
        { name: 'ufo1', src: 'assets/images/ufo1.png' },
        { name: 'ufo2', src: 'assets/images/ufo2.png' },
        { name: 'ufo3', src: 'assets/images/ufo3.png' },
        { name: 'ufo4', src: 'assets/images/ufo4.png' },
        { name: 'bossLvl5', src: 'assets/images/large_ufo_level5.png' },
        { name: 'bossLvl10', src: 'assets/images/large_ufo_level10.png' },
        { name: 'explosion1', src: 'assets/images/explosion1.png' },
        { name: 'explosion2', src: 'assets/images/explosion2.png' },
        { name: 'explosion3', src: 'assets/images/explosion3.png' },
        { name: 'explosion4', src: 'assets/images/explosion4.png' },
        { name: 'explosion5', src: 'assets/images/explosion5.png' },
        { name: 'diamond', src: 'assets/images/diamond.png' },
        { name: 'extralife', src: 'assets/images/extralife.svg' },
        { name: 'asteroid', src: 'assets/images/asteroid.png' },
        { name: 'background1', src: 'assets/images/background1.webp' },
        { name: 'background2', src: 'assets/images/background2.webp' },
        { name: 'background3', src: 'assets/images/background3.webp' },
        { name: 'background4', src: 'assets/images/background4.webp' },
        { name: 'background5', src: 'assets/images/background5.webp' },
        { name: 'background6', src: 'assets/images/background6.webp' },
        { name: 'background7', src: 'assets/images/background7.webp' },
        { name: 'background8', src: 'assets/images/background8.webp' },
        { name: 'background9', src: 'assets/images/background9.webp' },
        { name: 'background10', src: 'assets/images/background10.webp' }
    ];

    // Image loading (uendret)
    const imagePromises = imagesToLoad.map(img => {
        return new Promise((resolve) => {
            const image = new Image();
            image.onload = () => {
                gameImages[img.name] = image;
                resolve();
            };
            image.onerror = () => {
                createFallbackImage(img.name);
                resolve();
            };
            image.src = img.src;
        });
    });

    await Promise.all(imagePromises);
    console.log("All images processed");

    // Laster alle spill-lyder
    const soundsToLoad = [
        { name: 'shoot', src: 'assets/sounds/shoot.wav' },
        { name: 'explosion', src: 'assets/sounds/explosion.wav' },
        { name: 'hit', src: 'assets/sounds/hit.wav' },
        { name: 'powerup', src: 'assets/sounds/powerup.mp3' },
        // Legg til spesifikt counter og morse lyder
        { name: 'counter', src: 'assets/sounds/counter.wav' },
        { name: 'morse', src: 'assets/sounds/morse.mp3' }
    ];

    // Last hver lyd separat
    soundsToLoad.forEach(sound => {
        try {
            console.log(`Setting up sound: ${sound.name} at ${sound.src}`);
            
            // Opprett en enkel wrapper som lager nye instanser hver gang lyden spilles
            gameSounds[sound.name] = {
                play: function() {
                    try {
                        const audio = new Audio(sound.src);
                        // Justert lydstyrke basert på lydtype
                        if (sound.name === 'morse') {
                            audio.volume = 0.45; // Lavere volum for morse
                        } else if (sound.name === 'shoot' || sound.name === 'hit' || sound.name === 'explosion') {
                            audio.volume = 0.15; // 30% reduksjon for shoot og hit
                        } else {
                            audio.volume = 0.5; // Standard volum for andre lyder
                        }
                        
                        const playPromise = audio.play();
                        
                        if (playPromise !== undefined) {
                            playPromise.catch(e => {
                                console.warn(`Could not play ${sound.name} sound: ${e.message}`);
                            });
                        }
                        
                        return audio;
                    } catch (e) {
                        console.error(`Error playing ${sound.name} sound:`, e);
                        return null;
                    }
                }
            };
        } catch (e) {
            console.error(`Failed to create sound: ${sound.name}`, e);
            createFallbackSound(sound.name);
        }
    });

    // Spesifikt oppsett for typing-lyd
    typingSound = new Audio('assets/sounds/morse.mp3');
    typingSound.volume = 0.05;
    typingSound.addEventListener('canplaythrough', function() {
        typingSoundReady = true;
        console.log("Typing sound ready");
    });
    typingSound.addEventListener('error', function(e) {
        console.warn("Error loading typing sound:", e);
        typingSoundReady = false;
    });
    typingSound.load();

    // Oppsett for background music
    setupBackgroundMusic();

    console.log("Asset loading complete");
    return Promise.resolve();
}

// En mer pålitelig implementasjon av showCredits-funksjonen
function showCredits() {
    console.log("Showing credits screen");
    
    // Skjul alle andre skjermer først
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('introScreen').classList.add('hidden');
    document.getElementById('levelStartScreen').classList.add('hidden');
    document.getElementById('gameOverScreen').classList.add('hidden');
    document.getElementById('highscoresScreen').classList.add('hidden');
    document.getElementById('levelCompleteScreen').classList.add('hidden');
    document.getElementById('victoryScreen').classList.add('hidden');
    
    // Fjern eksisterende credits-skjerm hvis den finnes
    const oldCredits = document.getElementById('creditsScreen');
    if (oldCredits) {
        oldCredits.remove();
    }
    
    // Opprett en helt ny credits-skjerm
    const creditsScreen = document.createElement('div');
    creditsScreen.id = 'creditsScreen';
    creditsScreen.style.position = 'absolute';
    creditsScreen.style.top = '0';
    creditsScreen.style.left = '0';
    creditsScreen.style.width = '100%';
    creditsScreen.style.height = '100%';
    creditsScreen.style.display = 'flex';
    creditsScreen.style.flexDirection = 'column';
    creditsScreen.style.justifyContent = 'center';
    creditsScreen.style.alignItems = 'center';
    creditsScreen.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    creditsScreen.style.zIndex = '10';
    
    // Lag tittel
    const title = document.createElement('h1');
    title.textContent = 'CREDITS';
    title.style.fontSize = '3rem';
    title.style.color = '#39FF14'; // NEON_GREEN
    title.style.textShadow = '0 0 10px #fff, 0 0 20px #39FF14';
    title.style.marginBottom = '40px';
    creditsScreen.appendChild(title);
    
    // Opprett credits-innhold
    const creditsContent = document.createElement('div');
    creditsContent.style.display = 'flex';
    creditsContent.style.flexDirection = 'column';
    creditsContent.style.gap = '30px';
    creditsContent.style.alignItems = 'center';
    creditsContent.style.marginBottom = '40px';
    
    // Credits-oppføringer
    const creditItems = [
        { title: 'GAME DESIGN & PROGRAMMING', name: 'BOENZA' },
        { title: 'RELEASED', name: '2025' },
        { title: 'REMEMBER', name: 'Don\'t Make Fashion Of Our Heavy Metal Passion' }
    ];
    
    creditItems.forEach((item, index) => {
        const creditItem = document.createElement('div');
        creditItem.style.textAlign = 'center';
        creditItem.style.marginBottom = '15px';
        
        const titleElem = document.createElement('div');
        titleElem.textContent = item.title;
        titleElem.style.fontSize = '1.2rem';
        titleElem.style.color = '#FFFF66'; // NEON_YELLOW
        titleElem.style.marginBottom = '5px';
        
        const nameElem = document.createElement('div');
        nameElem.textContent = item.name;
        nameElem.style.fontSize = '2rem';
        nameElem.style.color = '#FF14A3'; // NEON_PINK
        nameElem.style.textShadow = '0 0 5px #fff, 0 0 10px #FF14A3';
        nameElem.style.animation = `textPulse 1.5s infinite`;
        nameElem.style.animationDelay = `${index * 0.3}s`;
        
        creditItem.appendChild(titleElem);
        creditItem.appendChild(nameElem);
        creditsContent.appendChild(creditItem);
    });
    
    creditsScreen.appendChild(creditsContent);
    
    
    // Legg til i DOM
    document.getElementById('gameContainer').appendChild(creditsScreen);
    
    gameState = 'credits';
}
function preloadTypingSound() {
    console.log("Preloading typing sound");
    typingSound = new Audio('assets/sounds/morse.mp3');
    typingSound.volume = 0.05;
    typingSound.addEventListener('canplaythrough', function() {
        typingSoundReady = true;
        console.log("Typing sound ready");
    });
    typingSound.addEventListener('error', function(e) {
        console.warn("Error loading typing sound:", e);
        typingSoundReady = false;
    });
    typingSound.load();
}
// Forenklet funksjon for bakgrunnsmusikk
function setupBackgroundMusic() {
    console.log("Setting up background music system");
    
    // Opprette nytt Audio-objekt
    backgroundMusic = new Audio();
    backgroundMusic.loop = true;
    backgroundMusic.volume = 0.3;
    
    // Legg til event listeners for bedre debugging
    backgroundMusic.addEventListener('canplay', () => {
        console.log("Background music can play now: " + backgroundMusic.src);
    });
    
    backgroundMusic.addEventListener('playing', () => {
        console.log("Background music started playing: " + backgroundMusic.src);
    });
    
    backgroundMusic.addEventListener('error', (e) => {
        console.error("Background music error:", e);
        console.log("Failed source:", backgroundMusic.src);
    });
    
    // Test tilgjengeligheten av musikkfilene med fetch
    testMusicFiles();
}
// Test tilgjengeligheten av musikkfilene
async function testMusicFiles() {
    const musicFiles = [
        'assets/sounds/Evil Invaders.mp3',
        'assets/sounds/background_music1.mp3',
        'assets/sounds/background_music2.mp3'
    ];
    
    console.log("Testing music file availability...");
    
    for (const file of musicFiles) {
        try {
            const response = await fetch(file, { method: 'HEAD' });
            console.log(`${file}: ${response.ok ? 'Available' : 'Not available'} (${response.status})`);
        } catch (error) {
            console.error(`${file}: Error testing - ${error.message}`);
        }
    }
}


// Forenklet fallback for bilder (som tidligere)
function createFallbackImage(name) {
    console.log(`Creating fallback image for: ${name}`);
    
    let width = 50;
    let height = 50;
    let color = '#FFFFFF';
    let isBackground = false;
    
    // Juster størrelse og farge basert på bildetype
    if (name.includes('player')) {
        width = 60;
        height = 50;
        color = '#39FF14'; // Player: neon green
    } else if (name.includes('ufo')) {
        width = 50;
        height = 30;
        color = '#FF14A3'; // UFOs: neon pink
    } else if (name.includes('boss')) {
        width = name.includes('Lvl10') ? 150 : 100;
        height = name.includes('Lvl10') ? 120 : 80;
        color = '#FF0000'; // Boss: red
    } else if (name.includes('explosion')) {
        width = 50;
        height = 50;
        color = '#FFFF00'; // Explosions: yellow
    } else if (name.includes('background')) {
        width = 800;
        height = 600;
        color = '#000033';
        isBackground = true;
    } else if (name === 'diamond') {
        width = 40;
        height = 40;
        color = '#00FFFF'; // Cyan
    } else if (name === 'extralife') {
        width = 40;
        height = 40;
        color = '#FF3E61'; // Heart red
    } else if (name === 'asteroid') {
        width = 40;
        height = 40;
        color = '#39FF14'; // Neon green
    }
    
    // Lag fallback-bildet
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    
    if (isBackground) {
        // Create a starfield for backgrounds
        ctx.fillStyle = color;
        ctx.fillRect(0, 0, width, height);
        
        // Add stars
        ctx.fillStyle = '#FFFFFF';
        for (let i = 0; i < 100; i++) {
            const x = Math.random() * width;
            const y = Math.random() * height;
            const size = Math.random() * 2 + 1;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
        }
    } else {
        // Simple colored rectangle for other assets
        ctx.fillStyle = color;
        ctx.fillRect(0, 0, width, height);
        
        // Add some details
        ctx.strokeStyle = '#FFFFFF';
        ctx.lineWidth = 2;
        ctx.strokeRect(2, 2, width - 4, height - 4);
        
        // Add asset type text for debugging
        ctx.fillStyle = '#000000';
        ctx.font = '10px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(name, width / 2, height / 2);
    }
    
    // Lagre fallback-bildet
    gameImages[name] = canvas;
}

// Forenklet fallback for lyder
function createFallbackSound(name) {
    console.log(`Creating fallback sound for: ${name}`);
    
    // Enkel fallback-lyd som bare logger til konsollen
    gameSounds[name] = {
        play: function() {
            console.log(`[Sound effect: ${name}]`);
        }
    };
}
        function initEventListeners() {
            console.log("Initializing event listeners");
            
            // Keyboard event listeners
            window.addEventListener('keydown', (e) => {
                keys[e.key] = true;
                handleKeyPress(e);
            });

            window.addEventListener('keyup', (e) => {
                keys[e.key] = false;
            });

            // Button event listeners
            document.getElementById('retryBtn').addEventListener('click', () => restartGame());
            document.getElementById('exitBtn').addEventListener('click', () => {
                if (screenRotationTimer) {
                    clearInterval(screenRotationTimer);
                }
                location.reload();
            });
            document.getElementById('highscoresBtn').addEventListener('click', () => showHighscores());
            document.getElementById('backToGameOverBtn').addEventListener('click', () => showScreen('gameOver'));
            document.getElementById('submitScoreBtn').addEventListener('click', () => submitHighscore());
            // Legg til berøringsstøtte for mobilenheter
            function setupTouchListeners() {
    // Legg til touch event listeners på de spesifikke skjermene
    document.getElementById('startScreen').addEventListener('touchstart', handleTouch, { passive: false });
    document.getElementById('introScreen').addEventListener('touchstart', handleTouch, { passive: false });
    document.getElementById('levelCompleteScreen').addEventListener('touchstart', handleTouch, { passive: false });
    document.getElementById('victoryScreen').addEventListener('touchstart', handleTouch, { passive: false });
    document.getElementById('highscoresScreen').addEventListener('touchstart', handleTouch, { passive: false });
}
        }

        function setupMobileControls() {
            const mobileControls = document.getElementById('mobileControls');
            mobileControls.style.display = 'flex';

            const moveLeftBtn = document.getElementById('moveLeftBtn');
            const moveRightBtn = document.getElementById('moveRightBtn');
            const fireBtn = document.getElementById('fireBtn');

            // Left button
            moveLeftBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys['ArrowLeft'] = true;
            });
            moveLeftBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys['ArrowLeft'] = false;
            });

            // Right button
            moveRightBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys['ArrowRight'] = true;
            });
            moveRightBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys['ArrowRight'] = false;
            });

            // Fire button
            fireBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys[' '] = true;
            });
            fireBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[' '] = false;
            });
        }

        // Oppdatert levelComplete funksjon med animert poengtelling
        function levelComplete() {
    // Stopp gameloop først
    if (gameLoop) {
        cancelAnimationFrame(gameLoop);
        gameLoop = null;
    }
    
    // Sett gameState til levelComplete
    gameState = 'levelComplete';
    
    console.log("Level complete! Starting score animation");
    
    // Calculate bonuses
    const currentTime = Date.now();
    const levelTime = currentTime - levelStartTime;
    const parTime = levelParTimes[level] || 30000;
    
    let timeBonus = 0;
    if (level < 6) {
        // For levels 1-5, give a base bonus plus extra for fast completion
        const baseBonus = 50;
        if (levelTime < parTime) {
            const multiplier = 6 - level;
            timeBonus = baseBonus + Math.floor((parTime - levelTime) / 1000) * 10 * multiplier;
        } else {
            timeBonus = baseBonus;
        }
    } else {
        // For levels 6+, only give bonus for beating par time
        if (levelTime < parTime) {
            timeBonus = Math.floor((parTime - levelTime) / 1000) * 10;
        }
    }
    
    const lifeBonus = lives * 50;
    const totalBonus = timeBonus + lifeBonus;
    
    // Variabler for animasjon
    const originalScore = score;
    let displayedTimeBonus = 0;
    let displayedLifeBonus = 0;
    let displayedTotalBonus = 0;
    let displayedScore = originalScore;
    
    // Hastighet for animering
    const animationSpeedTime = Math.max(2, timeBonus / 200);
    const animationSpeedLife = Math.max(3, lifeBonus / 150);
    const animationSpeedTotal = Math.max(5, totalBonus / 150);
    
    // Faser for animasjon
    let countingTimeBonus = true;
    let countingLifeBonus = false;
    let countingTotalBonus = false;
    let countingScore = false;
    let finished = false;
    
    // Oppdater level complete screen
    document.getElementById('completedLevel').textContent = level;
    document.getElementById('currentScore').textContent = displayedScore;
    document.getElementById('timeBonus').textContent = displayedTimeBonus;
    document.getElementById('lifeBonus').textContent = displayedLifeBonus;
    document.getElementById('totalBonus').textContent = displayedTotalBonus;
    
    // Show the level complete screen
    document.getElementById('levelCompleteScreen').classList.remove('hidden');
    
    // Definerer en enkelt counter-lyd instans
    let counterSound = null;
    let soundIsPlaying = false;
    let lastSoundTime = 0;
    
    // Lydfunksjon som kun spiller én lyd om gangen
    function playCountSound() {
        const currentTime = Date.now();
        
        // Spill kun lyd hvis det har gått minst 750ms siden siste lyd
        // og det ikke allerede spilles en lyd
        if (currentTime - lastSoundTime > 750 && !soundIsPlaying) {
            try {
                // Opprett én ny counter-lyd
                if (gameSounds.counter) {
                    // Stopp tidligere lyd hvis den fortsatt spiller
                    if (counterSound) {
                        try {
                            counterSound.pause();
                            counterSound.currentTime = 0;
                        } catch (e) {
                            // Ignorerer feil ved stopping av lyd
                        }
                    }
                    
                    // Lag ny lyd med kort varighet
                    counterSound = new Audio('assets/sounds/counter.wav');
                    counterSound.volume = 0.8;
                    
                    // Begrens varigheten til maks 300ms
                    counterSound.addEventListener('timeupdate', function() {
                        if (this.currentTime > 0.3) {
                            this.pause();
                            this.currentTime = 0;
                            soundIsPlaying = false;
                        }
                    });
                    
                    // Håndter avspillings-slutt
                    counterSound.addEventListener('ended', function() {
                        soundIsPlaying = false;
                    });
                    
                    // Spill lyden
                    soundIsPlaying = true;
                    counterSound.play().catch(e => {
                        console.warn("Failed to play counter sound:", e);
                        soundIsPlaying = false;
                    });
                }
                
                lastSoundTime = currentTime;
            } catch (e) {
                console.log("Error playing count sound:", e);
                soundIsPlaying = false;
            }
        }
    }
    
    // Animer poeng
    function animateScores() {
        const currentTime = Date.now();
        
        // Animer tidsbonus
        if (countingTimeBonus) {
            if (displayedTimeBonus < timeBonus) {
                displayedTimeBonus += animationSpeedTime;
                if (displayedTimeBonus > timeBonus) {
                    displayedTimeBonus = timeBonus;
                }
                
                // Spill tellerlyd
                playCountSound();
            } else {
                countingTimeBonus = false;
                countingLifeBonus = true;
                
                // Kort pause før neste tellefase
                setTimeout(() => {
                    if (counterSound) {
                        counterSound.pause();
                        counterSound.currentTime = 0;
                    }
                    soundIsPlaying = false;
                }, 300);
            }
        }
        
        // Animer livsbonus
        if (countingLifeBonus) {
            if (displayedLifeBonus < lifeBonus) {
                displayedLifeBonus += animationSpeedLife;
                if (displayedLifeBonus > lifeBonus) {
                    displayedLifeBonus = lifeBonus;
                }
                
                // Spill tellerlyd
                playCountSound();
            } else {
                countingLifeBonus = false;
                countingTotalBonus = true;
                
                // Kort pause før neste tellefase
                setTimeout(() => {
                    if (counterSound) {
                        counterSound.pause();
                        counterSound.currentTime = 0;
                    }
                    soundIsPlaying = false;
                }, 300);
            }
        }
        
        // Animer totalbonus
        if (countingTotalBonus) {
            if (displayedTotalBonus < totalBonus) {
                displayedTotalBonus += animationSpeedTotal;
                if (displayedTotalBonus > totalBonus) {
                    displayedTotalBonus = totalBonus;
                }
                
                // Spill tellerlyd
                playCountSound();
            } else {
                countingTotalBonus = false;
                countingScore = true;
                
                // Kort pause før neste tellefase
                setTimeout(() => {
                    if (counterSound) {
                        counterSound.pause();
                        counterSound.currentTime = 0;
                    }
                    soundIsPlaying = false;
                }, 300);
            }
        }
        
        // Animer total score
        if (countingScore) {
            const scoreIncrement = Math.max(10, (originalScore + totalBonus - displayedScore) / 20);
            
            if (displayedScore < originalScore + totalBonus) {
                displayedScore += scoreIncrement;
                if (displayedScore > originalScore + totalBonus) {
                    displayedScore = originalScore + totalBonus;
                }
                
                // Spill tellerlyd
                playCountSound();
            } else {
                // Cleanup
                if (counterSound) {
                    counterSound.pause();
                    counterSound.currentTime = 0;
                }
                soundIsPlaying = false;
                
                // Litt forsinkelse før vi markerer animasjonen som ferdig
                setTimeout(() => {
                    finished = true;
                }, 500);
            }
        }
        
        // Oppdater UI
        document.getElementById('currentScore').textContent = Math.floor(displayedScore);
        document.getElementById('timeBonus').textContent = Math.floor(displayedTimeBonus);
        document.getElementById('lifeBonus').textContent = Math.floor(displayedLifeBonus);
        document.getElementById('totalBonus').textContent = Math.floor(displayedTotalBonus);
        
        // Håndter tastetrykk for å hoppe over animasjon
        const skipAnim = function(e) {
            if (e.key === 'Enter' || e.key === ' ') {
                displayedTimeBonus = timeBonus;
                displayedLifeBonus = lifeBonus;
                displayedTotalBonus = totalBonus;
                displayedScore = originalScore + totalBonus;
                
                // Oppdater UI med endelige verdier
                document.getElementById('currentScore').textContent = displayedScore;
                document.getElementById('timeBonus').textContent = displayedTimeBonus;
                document.getElementById('lifeBonus').textContent = displayedLifeBonus;
                document.getElementById('totalBonus').textContent = displayedTotalBonus;
                
                // Stopp animasjonen
                countingTimeBonus = false;
                countingLifeBonus = false;
                countingTotalBonus = false;
                countingScore = false;
                finished = true;
                
                // Stopp lyden
                if (counterSound) {
                    counterSound.pause();
                    counterSound.currentTime = 0;
                }
                soundIsPlaying = false;
                
                // Fjern event listener
                window.removeEventListener('keydown', skipAnim);
            }
        };
        
        // Legg til event listener for å hoppe over animasjon
        window.addEventListener('keydown', skipAnim);
        
        // Fortsett animasjon eller avslutt
        if (!finished) {
            requestAnimationFrame(animateScores);
        } else {
            // Oppdater faktisk score
            score += totalBonus;
            console.log(`Level ${level} completed. Bonus points: ${totalBonus}`);
            
            // Fjern event listener
            window.removeEventListener('keydown', skipAnim);
        }
    }
    
    // Start animasjonen
    animateScores();
}

        // Oppdatert startLevelCountdown funksjon for å sikre riktig nedtelling
        function startLevelCountdown() {
            console.log("Starting level countdown");
            
            // Sett spillstatus til levelStart
            gameState = 'levelStart';
            
            // Vis level-start skjermen
            document.getElementById('levelStartScreen').classList.remove('hidden');
            document.getElementById('levelNumber').textContent = level;
            
            // Sett nedtellingen
            levelStartCountdown = 3;
            document.getElementById('countdownTimer').textContent = levelStartCountdown;
            
            // Create UFOs for the current level
            createUfos();
            
            // Rydd opp i eksisterende timer hvis en finnes
            if (countdownTimer) {
                clearInterval(countdownTimer);
            }
            
            // Start nedtelling
            countdownTimer = setInterval(() => {
                levelStartCountdown--;
                document.getElementById('countdownTimer').textContent = levelStartCountdown;
                
                if (levelStartCountdown <= 0) {
                    clearInterval(countdownTimer);
                    
                    // Start the actual gameplay
                    startLevelGameplay();
                }
            }, 1000);
        }

        // For å håndtere tastetrykk under level complete
        function handleKeyPress(e) {
    console.log(`Key pressed: ${e.key} in game state: ${gameState}`);
    
    // Sjekk først om highscore input er åpen og aktiv
    const highscoreInput = document.getElementById('highscoreInput');
    const nameInput = document.getElementById('playerNameInput');
    
    // Hvis vi er i input-modus, avbryt all vanlig tastenavigasjon
    if (highscoreInput && !highscoreInput.classList.contains('hidden') && 
        document.activeElement === nameInput) {
        // Tillat bare Enter eller Escape for å sende/avbryte
        if (e.key === 'Enter') {
            // Sende skår
            submitHighscore();
        } else if (e.key === 'Escape') {
            // Eventuelt avbryt, eller bare la vanlig inputboks-atferd håndtere dette
        }
        // Ikke prosesser andre taster for spillnavigasjon
        return;
    }
    
    // Vanlig spillnavigasjon fortsetter kun hvis vi ikke er i input-modus
    switch(gameState) {
    case 'start':
        // Aksepter alle taster i stedet for bare Enter og Space
        showIntroScreen();
        break;
    case 'intro':
        if (!introTextComplete) {
            // Skip til slutten av teksten med hvilken som helst tast
            completeIntroText();
        } else {
            // Start spillet med hvilken som helst tast
            startGame();
        }
        break;
    case 'levelStart':
        // Fortsatt ingen mulighet til å hoppe over dette
        break;
    case 'playing':
        // Spillkontrollene håndteres i spillets hovedløkke
        break;
    case 'levelComplete':
        // Hvilken som helst tast for å fortsette til neste nivå
        nextLevel();
        break;
    case 'gameOver':
        // Beholder spesifikke taster for ulike handlinger
        if (e.key === '1' || e.key === 'r' || e.key === 'R') {
            restartGame();
        } else if (e.key === '2' || e.key === 'Escape') {
            location.reload();
        } else if (e.key === 'h' || e.key === 'H') {
            showHighscores();
        }
        break;
    case 'credits':
        // Hvilken som helst tast går tilbake til highscores
        showHighscores();
        break;
    case 'highscores':
        // Hvilken som helst tast går tilbake til game over-skjermen
        showScreen('gameOver');
        break;
    case 'victory':
        // Any key to continue (allerede implementert)
        endGame();
        break;
}
}
function handleTouch(e) {
    document.body.style.backgroundColor = 'red'; // Quick visual test
    console.log(`Touch event detected on screen: ${gameState}`);
    
    // Forhindre default touch-oppførsel
    e.preventDefault();
    
    // Samme logikk som handleKeyPress, men for touch
    switch(gameState) {
        case 'start':
            showIntroScreen();
            break;
        case 'intro':
            if (!introTextComplete) {
                completeIntroText();
            } else {
                startGame();
            }
            break;
        case 'levelComplete':
            nextLevel();
            break;
        case 'credits':
            showHighscores();
            break;
        case 'highscores':
            showScreen('gameOver');
            break;
        case 'victory':
            endGame();
            break;
    }
}     

        // Definer playBackgroundMusic funksjon globalt
        function playBackgroundMusic(level) {
    console.log(`Setting up background music for level ${level}`);
    
    // Bestem hvilken musikkfil som skal brukes basert på nivå
    let musicPath;
    if (level === 0) {
        musicPath = 'assets/sounds/Evil Invaders.mp3';
    } else if (level > 0 && level <= 10) {
        musicPath = `assets/sounds/background_music${level}.mp3`;
    } else {
        console.warn(`Invalid level ${level} for background music`);
        return;
    }
    
    // Hvis samme sang allerede spilles, ikke gjør noe
    if (currentMusicTrack === musicPath && backgroundMusic && !backgroundMusic.paused) {
        console.log("Same music already playing - continuing");
        return;
    }
    
    // Stopp eksisterende musikk
    if (backgroundMusic && !backgroundMusic.paused) {
        backgroundMusic.pause();
    }
    
    // Oppdater gjeldende spor
    currentMusicTrack = musicPath;
    
    // Reset
    backgroundMusic = new Audio();
    backgroundMusic.currentTime = 0;
    backgroundMusic.loop = true;
    backgroundMusic.volume = 0.3;
    
    console.log(`Loading music from: ${musicPath}`);
    
    // Set the source and load
    backgroundMusic.src = musicPath;
    
    // Play function with error handling
    const playMusic = () => {
        console.log("Playing background music...");
        
        backgroundMusic.play().then(() => {
            console.log("Background music started successfully");
        }).catch(e => {
            console.warn("Failed to play background music:", e);
            
            // Create a fallback button if playback fails
            if (!document.getElementById('musicPlayButton')) {
                const playButton = document.createElement('button');
                playButton.id = 'musicPlayButton';
                playButton.innerText = '🔊 ENABLE MUSIC';
                playButton.style.position = 'absolute';
                playButton.style.top = '10px';
                playButton.style.right = '10px';
                playButton.style.zIndex = '1000';
                playButton.style.padding = '5px 10px';
                playButton.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                playButton.style.color = '#39FF14';
                playButton.style.border = '2px solid #39FF14';
                playButton.style.borderRadius = '5px';
                playButton.style.cursor = 'pointer';
                
                playButton.addEventListener('click', () => {
                    backgroundMusic.play().catch(err => console.warn("Still unable to play music:", err));
                    playButton.style.display = 'none';
                });
                
                document.body.appendChild(playButton);
            }
        });
    };
    
    // Try to play immediately
    backgroundMusic.addEventListener('canplaythrough', () => {
        playMusic();
    }, { once: true });
    
    // Load the audio
    backgroundMusic.load();
    
    // Backup if canplaythrough doesn't fire within 2 seconds
    setTimeout(() => {
        if (backgroundMusic.paused) {
            playMusic();
        }
    }, 2000);
}

let introMorseSound = null;
let morseIsPlaying = false;
let introStartTime = 0;
let totalIntroTextLength = 0;

function showIntroScreen() {
    console.log("Showing intro screen");
    showScreen('intro');
    
    // Forbedre tittel på intro-skjermen
    const introTitle = document.querySelector('#introScreen h1');
    if (introTitle) {
        introTitle.className = 'neon-pink';
        introTitle.style.textShadow = '0 0 5px #fff, 0 0 10px #fff, 0 0 15px #FF14A3, 0 0 20px #FF14A3';
        introTitle.style.marginBottom = '20px';
        introTitle.style.fontSize = '3rem';
    }
    
    // Resten av intro-koden...
    introTextTimer = 0;
    currentIntroLine = 0;
    currentIntroChar = 0;
    introTextComplete = false;
    
    // Hide the start prompt initially
    document.getElementById('startPrompt').classList.add('hidden');
    
    // Beregn total lengde av introteksten
    totalIntroTextLength = introText.reduce((total, line) => total + line.length, 0);
    
    // Sett starttid
    introStartTime = Date.now();
    
    // Start the intro text animation
    animateIntroText();
}

function animateIntroText() {
    if (gameState !== 'intro') return;

    requestAnimationFrame(animateIntroText);
    
    const currentTime = Date.now();
    
    // Beregn total tid som skal brukes (19 sekunder)
    const totalDuration = 16000; // 16 sekunder i millisekunder
    
    // Dynamisk beregne typing-hastighet basert på ønsket varighet
    const elapsedTime = currentTime - introStartTime;
    const progress = elapsedTime / totalDuration;
    
    // Totalt antall tegn som skulle vært skrevet ut innen nå
    const expectedChars = Math.floor(progress * totalIntroTextLength);
    
    // Totalt antall tegn som faktisk er skrevet ut
    let totalWrittenChars = 0;
    for (let i = 0; i < currentIntroLine; i++) {
        totalWrittenChars += introText[i].length;
    }
    totalWrittenChars += currentIntroChar;
    
    // Juster typehastigheten dynamisk
    if (expectedChars > totalWrittenChars && !introTextComplete) {
        // Vi er bak skjema - skriv raskere
        if (currentTime - introTextTimer > typingSpeed / 1.5) {
            introTextTimer = currentTime;
            typeNextChar();
        }
    } else if (expectedChars < totalWrittenChars && !introTextComplete) {
        // Vi er foran skjema - skriv saktere 
        if (currentTime - introTextTimer > typingSpeed * 1.2) {
            introTextTimer = currentTime;
            typeNextChar();
        }
    } else {
        // Vi er i rute
        if (currentTime - introTextTimer > typingSpeed) {
            introTextTimer = currentTime;
            typeNextChar();
        }
    }
    
    // Håndter morse-lyd (spilles kontinuerlig under hele animasjonen)
    if (!morseIsPlaying && !introTextComplete && elapsedTime < totalDuration) {
        try {
            // Start morselyden ved behov
            if (typingSound && typingSoundReady) {
                console.log("Starting morse sound for intro text");
                typingSound.volume = 0.05;
                typingSound.play().catch(e => {
                    console.warn("Could not play typing sound:", e);
                });
                morseIsPlaying = true;
            }
        } catch (e) {
            console.warn("Error with morse sound:", e);
        }
    }
    
    // Stopp morselyden når animasjonen er ferdig
    if ((introTextComplete || elapsedTime >= totalDuration) && morseIsPlaying) {
        try {
            if (typingSound) {
                typingSound.pause();
                typingSound.currentTime = 0;
            }
            morseIsPlaying = false;
        } catch (e) {
            console.warn("Error stopping morse sound:", e);
        }
    }
}

// Hjelpefunksjon for å skrive neste karakter
function typeNextChar() {
    if (currentIntroLine < introText.length) {
        const currentLine = introText[currentIntroLine];
        const lineElement = document.getElementById(`storyLine${currentIntroLine + 1}`);
        
        if (currentIntroChar < currentLine.length) {
            // Add one character
            lineElement.textContent = currentLine.substring(0, currentIntroChar + 1);
            currentIntroChar++;
        } else {
            // Move to next line
            currentIntroLine++;
            currentIntroChar = 0;
            
            // Check if we've completed all lines
            if (currentIntroLine >= introText.length) {
                introTextComplete = true;
                
                // Stopp morselyden
                if (typingSound) {
                    typingSound.pause();
                    typingSound.currentTime = 0;
                }
                morseIsPlaying = false;
                
                // Show the start prompt
                setTimeout(() => {
                    document.getElementById('startPrompt').classList.remove('hidden');
                }, 1000);
            }
        }
    }
}


        function completeIntroText() {
            console.log("Completing intro text");
            // Display all intro text immediately
            for (let i = 0; i < introText.length; i++) {
                document.getElementById(`storyLine${i + 1}`).textContent = introText[i];
            }
            
            introTextComplete = true;
            currentIntroLine = introText.length;
            currentIntroChar = 0;
            
            // Show the start prompt
            document.getElementById('startPrompt').classList.remove('hidden');
        }

        function startGame() {
            console.log("Starting game");
            // Initialize game variables
            level = 1;
            score = 0;
            lives = 5;
            playerX = (SCREEN_WIDTH - PLAYER_WIDTH) / 2;
            playerY = SCREEN_HEIGHT - PLAYER_HEIGHT - 10;
            
            // Reset power-ups and weapons
            autoFireEnabled = false;
            laserSpeed = BULLET_SPEED;
            laserCount = 1;
            
            // Clear all game objects
            bullets = [];
            ufos = [];
            lavaDrops = [];
            powerups = [];
            extraLifeDrops = [];
            explosions = [];
            asteroids = [];
            
            // Reset boss-related variables
            bossShieldActive = false;
            bossShieldHealth = 0;
            bossAttackTimer = 0;
            bossAttackPattern = 0;
            largeUfoCreated = false;
            largeUfo2Created = false;
            levelExtraLifeDropped = false;
            
            // Show level start countdown
            startLevelCountdown();
        }

        function startLevelGameplay() {
            console.log("Starting level gameplay");
            // Sikre at game state er riktig
            showScreen('playing');
            gameState = 'playing';
            
            // Set level start time for bonus calculation
            levelStartTime = Date.now();
            
            // Reset level-specific flags
            levelExtraLifeDropped = false;
            
            // Create any level-specific power-ups
            if (level === 3 || level === 5 || level === 9) {
                createPowerup();
            }
            
            // Update difficulty based on level
            updateDifficulty();
            
            // Play background music for this level
            playBackgroundMusic(level);
            
            // Start the game loop
            lastTime = Date.now();
            gameLoop = requestAnimationFrame(update);
        }

        function updateDifficulty() {
            // Adjust difficulty parameters based on level
            let difficultyMultiplier = 1 + (level * 0.1);
            
            // Lava speed increases with level (max 4)
            let newLavaSpeed = Math.min(2 + (level * 0.2), 4);
            
            // Lava drop chance increases with level (max 2 in 1000)
            lavaDragDrop = Math.min(0.5 + (level * 0.1), 2);
            
            // UFO speed increases with level (max 3.5)
            let newUfoSpeed = Math.min(2 + (level * 0.15), 3.5);
            
            // Update UFO speeds
            ufos.forEach(ufo => {
                if (!ufo.isLarge) {
                    ufo.speed = newUfoSpeed;
                }
            });
        }

        function createUfos() {
    console.log("Creating UFOs");
    ufos = [];
    
    // Grunnleggende UFO-rader (nivå 1-5 har 4 rader)
    const baseRows = UFO_ROWS; // 4
    
    // Ekstra UFO-rader basert på nivå (nivå 6-10)
    let extraRows = 0;
    if (level >= 6) {
        extraRows = level - 5; // Nivå 6=1 ekstra rad, Nivå 7=2 ekstra rader, osv.
    }
    
    const totalRows = baseRows + extraRows;
    
    // Juster plassering basert på nivå
    const levelOffset = Math.min(level - 1, 3) * 10; // Økt Y-offset for hvert nivå, maks 30px
    
    // Vanlige UFO-rader (de originale 4 radene)
    for (let row = 0; row < baseRows; row++) {
        for (let col = 0; col < UFO_COLS; col++) {
            const ufoX = 50 + col * (UFO_WIDTH + 10);
            const ufoY = 50 + row * (UFO_HEIGHT + 10) + levelOffset;
            
            // Sett helse basert på rad, fra topp til bunn: 4, 3, 2, 1
            const ufoHealth = 4 - row;
            
            ufos.push({
                x: ufoX,
                y: ufoY,
                width: UFO_WIDTH,
                height: UFO_HEIGHT,
                health: ufoHealth > 0 ? ufoHealth : 1, // Sikre minimum 1 liv
                speed: UFO_SPEED,
                direction: 1,
                isLarge: false,
                row: row,
                col: col,
                image: `ufo${row % 4 + 1}`,
                isNewRow: false
            });
        }
    }
    
    // Ikke legg til ekstra rader på startbrettet - de blir lagt til dynamisk
    // De ekstra radene blir lagt til i updateUfos når det er få UFO-er igjen
}

// Legg til ny funksjon for å skape nye UFO-rader underveis i spillet:
function createNewUfoRow(rowIndex, totalNewRows) {
    console.log(`Creating UFO row ${rowIndex+1} of ${totalNewRows}`);
    
    // Beregn helsen til nye UFO-er (5, 6, 7, 8, 9 for hver nye rad)
    const baseHealth = 2; // Startverdi for helse
    const health = baseHealth + rowIndex; // 0-basert indeks gir 5, 6, 7, 8, 9 liv
    
    // Beregn startposisjon - litt over toppen av skjermen
    // Radene med høyere indeks starter høyere opp for å unngå overlapping
    const startY = -20 - (rowIndex * (UFO_HEIGHT + 10));
    
    // Legg til den nye raden
    for (let col = 0; col < UFO_COLS; col++) {
        const ufoX = 50 + col * (UFO_WIDTH + 10);
        const ufoY = startY;
        
        ufos.push({
            x: ufoX,
            y: ufoY,
            width: UFO_WIDTH,
            height: UFO_HEIGHT,
            health: health,
            speed: UFO_SPEED + 0.5,
            direction: 1,
            isLarge: false,
            row: -rowIndex - 1, // Negative for å indikere at det er en ekstra rad
            col: col,
            image: `ufo${rowIndex % 4 + 1}`, // Varier bildet for hver rad
            isNewRow: true,
            newRowBatch: rowIndex + 1, // Indikerer hvilken batch denne raden tilhører
            creationTime: Date.now() // Tidsstempel for når raden ble opprettet
        });
    }
    
    // Spill en special lyd for ny rad (kun for den første raden hvis det er flere)
    if (rowIndex === 0 && gameSounds.powerup) {
        gameSounds.powerup.play();
    }
}
        function createLargeUfo(bossLevel) {
            console.log(`Creating boss for level ${bossLevel}`);
            // Remove any remaining regular UFOs
            ufos = ufos.filter(ufo => ufo.isLarge);
            
            // Determine boss properties based on level
            let bossWidth, bossHeight, bossHealth, bossSpeed;
            
            if (bossLevel === 5) {
                bossWidth = 100;
                bossHeight = 80;
                bossHealth = 50;
                bossSpeed = 3;
            } else { // level 10
                bossWidth = 150;
                bossHeight = 120;
                bossHealth = 200;
                bossSpeed = 4;
            }
            
            // Create boss UFO
            ufos.push({
                x: (SCREEN_WIDTH - bossWidth) / 2,
                y: 100,
                width: bossWidth,
                height: bossHeight,
                health: bossHealth,
                speed: bossSpeed,
                direction: 1,
                verticalDirection: 1,
                isLarge: true,
                attackTimer: Date.now(),
                spawnTimer: Date.now(),
                image: bossLevel === 5 ? 'bossLvl5' : 'bossLvl10'
            });
            
            if (bossLevel === 5) {
                largeUfoCreated = true;
            } else {
                largeUfo2Created = true;
            }
        }

        function createPowerup() {
            console.log("Creating powerup");
            powerups.push({
                x: Math.random() * (SCREEN_WIDTH - 40),
                y: 0,
                width: 40,
                height: 40
            });
        }

        function createExtraLife() {
            console.log("Creating extra life");
            extraLifeDrops.push({
                x: Math.random() * (SCREEN_WIDTH - 40),
                y: 0,
                width: 40,
                height: 40
            });
        }

        function applyPowerup() {
            console.log(`Applying powerup for level ${level}`);
            if (level === 3) {
                laserSpeed += 2; // Faster laser
                autoFireEnabled = true; // Enable autofire
                // Use player level 3 image
            } else if (level === 5) {
                laserCount = 2; // Double laser
                // Use player level 6 image
            } else if (level === 9) {
                laserCount = 4; // Quad laser
                // Use player level 9 image
            }
        }

        function createBullet(x, y) {
            bullets.push({
                x: x,
                y: y,
                width: BULLET_WIDTH,
                height: BULLET_HEIGHT,
                particles: []
            });
        }

        function dropLava(x, y, color) {
            lavaDrops.push({
                x: x,
                y: y,
                width: LAVA_WIDTH,
                height: LAVA_HEIGHT,
                speed: LAVA_SPEED,
                color: color || '#FF8000', // Default to neon orange
                pulse: Math.random(),
                growing: true,
                rotation: Math.random() * 360,
                rotationSpeed: Math.random() * 10 - 5,
                isFragment: false
            });
        }

        function createAsteroid() {
            const side = Math.random() < 0.33 ? 'left' : (Math.random() < 0.5 ? 'right' : 'top');
            const asteroidSize = 40;
            let x, y, speedX, speedY;
            
            if (side === 'left') {
                x = -asteroidSize;
                y = Math.random() * (SCREEN_HEIGHT / 2);
                speedX = Math.random() * 2 + 1;
                speedY = Math.random() * 1 + 1;
            } else if (side === 'right') {
                x = SCREEN_WIDTH + asteroidSize;
                y = Math.random() * (SCREEN_HEIGHT / 2);
                speedX = -(Math.random() * 2 + 1);
                speedY = Math.random() * 1 + 1;
            } else { // top
                x = Math.random() * (SCREEN_WIDTH - 50);
                y = -asteroidSize;
                speedX = Math.random() * 2 - 1;
                speedY = Math.random() * 1 + 2;
            }
            
            asteroids.push({
                x: x,
                y: y,
                width: asteroidSize,
                height: asteroidSize,
                speedX: speedX,
                speedY: speedY,
                rotation: 0,
                rotationSpeed: Math.random() * 4 - 2,
                color: COLORS.NEON_GREEN
            });
        }

        // Fikset createBossExplosion funksjon
        function createBossExplosion(boss) {
    // Sikre at vi har gyldige verdier
    if (!boss) {
        console.error("Invalid boss object in createBossExplosion");
        return;
    }
    
    const bossX = boss.x + boss.width / 2;
    const bossY = boss.y + boss.height / 2;
    const bossWidth = boss.width;
    const bossHeight = boss.height;
    const bossLevel = level === 5 ? 5 : 10;
    
    console.log(`Creating boss explosion for level ${bossLevel}`);
    
    // Bestem farger basert på boss-nivå
    const primaryColor = bossLevel === 5 ? COLORS.NEON_GREEN : COLORS.NEON_PINK;
    const secondaryColor = COLORS.NEON_YELLOW;
    const tertiaryColor = bossLevel === 5 ? COLORS.CYAN : COLORS.PURPLE;
    
    // Stopp the game loop during the explosion sequence
    if (gameLoop) {
        cancelAnimationFrame(gameLoop);
        gameLoop = null;
    }
    
    // Reset all key states to prevent accidental dismissal
    keys = {};
    
    // VIKTIG: Sett game state til et mellomliggende state for å forhindre level complete
    gameState = 'bossExplosion';
    
    // Viktig: Vi bruker eksisterende canvas i stedet for å opprette nye
    // Dette sikrer at animasjonene vises direkte på det eksisterende spillbrettet
    const explosionCanvas = overlayCanvas; // Bruk det eksisterende overlay-canvaset
    const explosionCtx = overlayCtx;
    
    // Kopier det nåværende spillbrettet til overlay
    explosionCtx.drawImage(gameCanvas, 0, 0);
    
    // Spill en enkelt eksplosjonsslyd først
    try {
        if (gameSounds.explosion) {
            gameSounds.explosion.play();
        }
    } catch (e) {
        // Ignorer feil
    }
    
    // Spill avbrytende eksplosjonslyder
    let soundCount = 0;
    const maxSounds = 5; // Økt for mer dramatikk
    
    const playStaggedSound = () => {
        if (soundCount < maxSounds) {
            try {
                if (gameSounds.explosion) {
                    gameSounds.explosion.play();
                }
                soundCount++;
                setTimeout(playStaggedSound, 300); // Mer forsinkelse mellom lyder
            } catch (e) {
                // Ignorer feil
            }
        }
    };
    
    // Start de avbrutte lydene etter en forsinkelse
    setTimeout(playStaggedSound, 300);
    
    // Opprett halvt-gjennomsiktig overlay for bakgrunn
    const overlayDiv = document.createElement('div');
    overlayDiv.id = 'bossExplosionOverlay';
    overlayDiv.style.position = 'absolute';
    overlayDiv.style.top = '0';
    overlayDiv.style.left = '0';
    overlayDiv.style.width = '100%';
    overlayDiv.style.height = '100%';
    overlayDiv.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
    overlayDiv.style.zIndex = '5'; // Under canvas men over bakgrunn
    document.getElementById('gameContainer').appendChild(overlayDiv);
    
    // Opprett animerte eksplosjonseffekter
    let explosionStep = 0;
    const totalSteps = 60; // Lengre animasjon
    
    function animateBossExplosion() {
        // Tegn eksisterende spilltilstand på nytt
        explosionCtx.clearRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
        explosionCtx.drawImage(gameCanvas, 0, 0);
        
        // Tegn sjokkbølge
        if (explosionStep < 30) {
            const radius = explosionStep * bossWidth / 10;
            explosionCtx.beginPath();
            explosionCtx.arc(bossX, bossY, radius, 0, Math.PI * 2);
            explosionCtx.strokeStyle = primaryColor;
            explosionCtx.lineWidth = 5;
            explosionCtx.globalAlpha = 1 - (explosionStep / 30);
            explosionCtx.stroke();
            explosionCtx.globalAlpha = 1;
        }
        
        // Tegn tilfeldige eksplosjoner
        for (let i = 0; i < 3; i++) {
            const offsetX = (Math.random() - 0.5) * bossWidth * 2 * (explosionStep / 20);
            const offsetY = (Math.random() - 0.5) * bossHeight * 2 * (explosionStep / 20);
            const size = Math.random() * 40 + 10;
            const color = [primaryColor, secondaryColor, tertiaryColor][Math.floor(Math.random() * 3)];
            
            explosionCtx.beginPath();
            explosionCtx.arc(bossX + offsetX, bossY + offsetY, size, 0, Math.PI * 2);
            explosionCtx.fillStyle = color;
            explosionCtx.globalAlpha = 0.7;
            explosionCtx.fill();
            explosionCtx.globalAlpha = 1;
        }
        
        // Opprett fragmenter
        if (explosionStep % 3 === 0 && explosionStep < 40) {
        for (let i = 0; i < 8; i++) { // Økt fra 5 til 8 fragmenter
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 15 + 5; // Økt hastighet
            const lifetime = Math.random() * 280 + 260; // Lengre levetid
            const fragmentSize = Math.random() * 15 + 8; // Større fragmenter
            const fragmentX = bossX + (Math.random() - 0.5) * 30; // Mer variasjon
            const fragmentY = bossY + (Math.random() - 0.5) * 30;
            
            // Velg fragmentfarge
            let fragmentColor;
            if (Math.random() < 0.7) {
                fragmentColor = primaryColor;
            } else if (Math.random() < 0.5) {
                fragmentColor = secondaryColor;
            } else {
                fragmentColor = tertiaryColor;
            }
            
            lavaDrops.push({
                x: fragmentX,
                y: fragmentY,
                width: fragmentSize,
                height: fragmentSize,
                speed: 0,
                velocityX: Math.cos(angle) * speed,
                velocityY: Math.sin(angle) * speed,
                pulse: Math.random() + 0.8,
                growing: Math.random() < 0.5,
                rotation: Math.random() * 360,
                rotationSpeed: Math.random() * 50 - 25,
                lifetime: lifetime,
                isFragment: true,
                color: fragmentColor,
                level: bossLevel
            });
        }
    }
    
    // Sterkere blinkeffekter
    if (explosionStep === 5 || explosionStep === 15 || explosionStep === 25) {
        explosionCtx.fillStyle = 'rgba(255, 255, 255, 0.9)'; // Mer opak
        explosionCtx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
    }
        
        // Legg til "BOSS DEFEATED" tekst ved steg 30
        if (explosionStep >= 30) {
            explosionCtx.font = '40px monospace';
            explosionCtx.textAlign = 'center';
            explosionCtx.fillStyle = primaryColor;
            explosionCtx.shadowColor = 'white';
            explosionCtx.shadowBlur = 15;
            explosionCtx.fillText('BOSS DEFEATED', SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 - 20);
            
            if (explosionStep >= 40) {
                explosionCtx.font = '24px monospace';
                explosionCtx.fillStyle = secondaryColor;
                explosionCtx.fillText('PRESS SPACE OR ENTER TO CONTINUE', SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 + 30);
            }
        }
        
        explosionStep++;
        
        // Fortsett animasjon eller avslutt den
        if (explosionStep < totalSteps) {
            requestAnimationFrame(animateBossExplosion);
        } else {
            // Sett opp lytter for spesifikt tastetrykk (Kun mellomrom eller Enter)
            const handleKeyPress = function(e) {
                if (e.key === ' ' || e.key === 'Enter') {
                    // Rydde opp
                    overlayDiv.remove();
                    explosionCtx.clearRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                    window.removeEventListener('keydown', handleKeyPress);
                    
                    // KRITISK ENDRING: Fortsett til level complete eller seier,
                    // men kun når spilleren er klar til å fortsette
                    if (level === 10 && bossLevel === 10) {
                        victory();
                    } else {
                        levelComplete();
                    }
                }
            };
            
            // Legg til en liten forsinkelse før lytter for tastetrykk aktiveres
            setTimeout(() => {
                window.addEventListener('keydown', handleKeyPress);
            }, 500);
            
            // Auto-fortsett etter 10 sekunder hvis ingen tastetrykk (lengre forsinkelse)
            setTimeout(() => {
                if (document.getElementById('bossExplosionOverlay')) {
                    overlayDiv.remove();
                    explosionCtx.clearRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                    window.removeEventListener('keydown', handleKeyPress);
                    
                    if (level === 10 && bossLevel === 10) {
                        victory();
                    } else {
                        levelComplete();
                    }
                }
            }, 10000);
        }
    }
    
    // Start eksplosjonsanimasjonen
    animateBossExplosion();
}
        function createExplosion(x, y, isPlayer = false, scale = 1, colorMod = null, durationMultiplier = 1) {
            explosions.push({
                x: x,
                y: y,
                index: 0,
                timer: Date.now(),
                isPlayer: isPlayer,
                scale: scale,
                colorMod: colorMod,
                durationMultiplier: durationMultiplier,
                isBossExplosion: scale > 1
            });
        }

        function update(currentTime) {
            // Calculate delta time
            deltaTime = (currentTime - lastTime) / 1000; // convert to seconds
            lastTime = currentTime;
            
            // Clear the canvas
            gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            
            // Draw background
            drawBackground();
            
            // Update game objects
            updatePlayer();
            updateBullets();
            updateUfos();
            updateLava();
            updatePowerups();
            updateExtraLives();
            updateExplosions();
            updateAsteroids();
            
            // Draw game objects
            drawAsteroids();
            drawUfos();
            drawLava();
            drawPowerups();
            drawExtraLives();
            drawBullets();
            drawPlayer();
            drawExplosions();
            
            // Draw UI
            drawUI();
            
            // Check level completion
            checkLevelCompletion();
            
            // Request next frame
            if (gameState === 'playing') {
                gameLoop = requestAnimationFrame(update);
            }
        }

        function drawBackground() {
            // Use the background image for the current level
            const bgImage = gameImages[`background${level}`];
            if (bgImage) {
                gameCtx.drawImage(bgImage, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
            } else {
                // Fallback - create a starfield
                gameCtx.fillStyle = '#000033';
                gameCtx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                
                // Draw stars
                gameCtx.fillStyle = '#FFFFFF';
                for (let i = 0; i < 100; i++) {
                    const x = Math.random() * SCREEN_WIDTH;
                    const y = Math.random() * SCREEN_HEIGHT;
                    const size = Math.random() * 2 + 0.5;
                    gameCtx.beginPath();
                    gameCtx.arc(x, y, size, 0, Math.PI * 2);
                    gameCtx.fill();
                }
            }
        }
        function updatePlayer() {
            // Player movement
            if (keys['ArrowLeft'] && playerX > 0) {
                playerX -= PLAYER_SPEED;
            }
            if (keys['ArrowRight'] && playerX < SCREEN_WIDTH - PLAYER_WIDTH) {
                playerX += PLAYER_SPEED;
            }
            
            // Shooting
            const currentTime = Date.now();
            if ((keys[' '] || autoFireEnabled) && currentTime - lastShot > BULLET_COOLDOWN) {
                if (laserCount === 1) {
                    // Single laser
                    createBullet(playerX + PLAYER_WIDTH / 2 - BULLET_WIDTH / 2, playerY);
                } else if (laserCount === 2) {
                    // Double laser
                    const offset = 10;
                    createBullet(playerX + PLAYER_WIDTH / 2 - BULLET_WIDTH / 2 - offset, playerY);
                    createBullet(playerX + PLAYER_WIDTH / 2 - BULLET_WIDTH / 2 + offset, playerY);
                } else if (laserCount === 4) {
                    // Quad laser
                    const offset = 20;
                    createBullet(playerX + PLAYER_WIDTH / 2 - BULLET_WIDTH / 2 - offset, playerY);
                    createBullet(playerX + PLAYER_WIDTH / 2 - BULLET_WIDTH / 2 - offset / 2, playerY);
                    createBullet(playerX + PLAYER_WIDTH / 2 - BULLET_WIDTH / 2 + offset / 2, playerY);
                    createBullet(playerX + PLAYER_WIDTH / 2 - BULLET_WIDTH / 2 + offset, playerY);
                }
                
                lastShot = currentTime;
                if (gameSounds.shoot) {
                    gameSounds.shoot.play();
                }
            }
        }

        function drawPlayer() {
            // Use appropriate player image based on level
            let playerImage;
            if (level >= 9) {
                playerImage = gameImages.playerLvl9;
            } else if (level >= 6) {
                playerImage = gameImages.playerLvl6;
            } else if (level >= 3) {
                playerImage = gameImages.playerLvl3;
            } else {
                playerImage = gameImages.player;
            }
            
            gameCtx.drawImage(playerImage, playerX, playerY, PLAYER_WIDTH, PLAYER_HEIGHT);
        }

        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // Move bullet
                bullet.y -= laserSpeed;
                
                // Remove if off screen
                if (bullet.y < 0) {
                    bullets.splice(i, 1);
                    continue;
                }
                
                // Check collision with UFOs
                for (let j = ufos.length - 1; j >= 0; j--) {
                    const ufo = ufos[j];
                    
                    if (checkCollision(bullet, ufo)) {
                        // Remove bullet
                        bullets.splice(i, 1);
                        
                        // Handle UFO hit
                        handleUfoHit(ufo);
                        
                        // Break out of inner loop since bullet is removed
                        break;
                    }
                }
            }
        }

        function drawBullets() {
            for (const bullet of bullets) {
                // Draw laser with gradient effect
                const gradient = gameCtx.createLinearGradient(
                    bullet.x + bullet.width / 2,
                    bullet.y,
                    bullet.x + bullet.width / 2,
                    bullet.y + bullet.height
                );
                gradient.addColorStop(0, '#FFFFFF');
                gradient.addColorStop(1, '#FFFF66');
                
                gameCtx.fillStyle = gradient;
                gameCtx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                
                // Add glow effect
                gameCtx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
                gameCtx.lineWidth = 2;
                gameCtx.strokeRect(bullet.x - 1, bullet.y - 1, bullet.width + 2, bullet.height + 2);
            }
        }

        function handleUfoHit(ufo) {
    ufo.health--;
    
    // Opprett en mindre treffeffekt
    createExplosion(ufo.x + ufo.width / 2, ufo.y + ufo.height / 2, false, 0.5);
    
    // Sjekk om UFO er ødelagt
    if (ufo.health <= 0) {
        // Fjern UFO
        const ufoIndex = ufos.indexOf(ufo);
        if (ufoIndex > -1) {
            ufos.splice(ufoIndex, 1);
        }
        
        // Spill eksplosjonslyd
        if (gameSounds.explosion) {
            gameSounds.explosion.play();
        }
        
        // Legg til poeng
        if (ufo.isLarge) {
            score += 200; // Boss gir 200 poeng
            
            // Opprett flere eksplosjoner for boss
            createBossExplosion(ufo);
        } else {
            // Vanlig UFO gir poeng basert på helsen
            let basePoints = 10;
            
            // Nye rader med høyere helse gir flere poeng
            if (ufo.isNewRow) {
                basePoints = 15 + (level - 6) * 5; // Øker med level
            }
            
            score += basePoints;
            
            // Opprett en vanlig eksplosjon
            createExplosion(ufo.x + ufo.width / 2, ufo.y + ufo.height / 2);
            
            // Sjanse for å slippe ekstra liv
            if (Math.random() < 0.01) {
                extraLifeDrops.push({
                    x: ufo.x + ufo.width / 2 - 20,
                    y: ufo.y + ufo.height / 2 - 20,
                    width: 40,
                    height: 40
                });
            }
        }
    }
}
function updateUfos() {
    const currentTime = Date.now();
    
    // Filtrer ut vanlige UFO-er (ikke bosser) for å telle hvor mange som er igjen
    const regularUfos = ufos.filter(ufo => !ufo.isLarge);
    const remainingUfos = regularUfos.length;
    
    // Telle kun de originale UFO-ene (ikke nye rader)
    const originalUfos = regularUfos.filter(ufo => !ufo.isNewRow).length;
    
    // Sjekk hvor mange nye rader som allerede er lagt til
    const newRowsCreated = Math.max(0, ...regularUfos.filter(ufo => ufo.isNewRow).map(ufo => ufo.newRowBatch || 0));
    
    // For level 6-10, sjekk om vi skal legge til nye rader
    if (level >= 6 && level <= 10) {
        // Antall ekstra rader som skal legges til for dette nivået
        const extraRowsForLevel = level - 5; // Level 6=1, 7=2, 8=3, 9=4, 10=5
        
        // Sjekk om vi har originale UFO-er igjen, og om vi ikke allerede har lagt til nye rader
        if (originalUfos <= UFO_COLS && // kun én original rad igjen
            newRowsCreated === 0 && // ingen nye rader lagt til ennå
            !window.addedNewRowsForLevel) { // flagg for å hindre flere tillegg
            
            // Legg til alle nye rader på én gang
            for (let i = 0; i < extraRowsForLevel; i++) {
                createNewUfoRow(i, extraRowsForLevel);
            }
            
            // Sett flagg for å hindre at vi legger til flere rader
            window.addedNewRowsForLevel = true;
            
            console.log(`Added ${extraRowsForLevel} new UFO rows for level ${level}`);
        }
    }
    
    // Sjekk om vi skal opprette en boss-UFO
    if (level === 5 && !largeUfoCreated && remainingUfos <= 1) {
        createLargeUfo(5);
    } else if (level === 10 && !largeUfo2Created && (remainingUfos <= 5 || (currentTime - levelStartTime > 60000))) {
        createLargeUfo(10);
    }
    
    // Øk hastigheten på UFOene basert på hvor mange som er igjen
    let speedBonus = 0;
    let visualMultiplier = 1.0;
    
    if (remainingUfos <= 5) {
        speedBonus = 3.0;
        visualMultiplier = 2.5;
    } else if (remainingUfos <= 10) {
        speedBonus = 2.0;
        visualMultiplier = 2.0;
    } else if (remainingUfos <= 20) {
        speedBonus = 1.0;
        visualMultiplier = 1.5;
    }
    
    // Oppdater hver UFO
    for (let i = ufos.length - 1; i >= 0; i--) {
        const ufo = ufos[i];
        
        if (ufo.isLarge) {
    // Boss-UFO-bevegelse (uendret)
    updateLargeUfoMovement(ufo);
} else {
    // Vanlig UFO-bevegelse
    const levelBaseSpeed = UFO_SPEED + (level - 1) * 0.3;
    const currentSpeed = levelBaseSpeed + speedBonus;
    
    // Hvis det er en ny rad, la den først falle nedover til riktig posisjon
    if (ufo.isNewRow) {
        // Bestemme målposisjon for den nye raden (over de eksisterende)
        const batchNumber = ufo.newRowBatch || 0; // Hvilken batch av nye rader denne tilhører
        const targetY = 50 + Math.abs(ufo.row) * (UFO_HEIGHT + 10);
        
        if (ufo.y < targetY) {
            // Beveg seg nedover til målet
            ufo.y += 2;
        } else {
            // Stopp ved målposisjonen
            ufo.y = targetY;
            
            // Når den har nådd målposisjonen, fjern isNewRow-flagget så den følger vanlig bevegelse
            if (Date.now() - ufo.creationTime > 5000) { // Gi den litt tid på posisjonen først
                ufo.isNewRow = false;
            }
        }
    }
    
    // Vanlig horisontal bevegelse
    ufo.x += currentSpeed * ufo.direction;
    
    // Bytt retning og beveg nedover når du treffer kanten
    if (ufo.x + ufo.width >= SCREEN_WIDTH || ufo.x <= 0) {
        ufo.direction *= -1;
        
        // Her er endringen - også nye rader beveger seg nedover 
        // men med tilpasset hastighet basert på nivå
        const verticalStep = ufo.isNewRow ? 
            Math.max(5, ufo.height / (12 - level)) : // Tilpasset hastighet for nye rader
            ufo.height / 2; // Original hastighet for gamle rader
            
        ufo.y += verticalStep;
    }
            
            // Slipp lava tilfeldig
            if (Math.random() < (lavaDragDrop / 1000) * visualMultiplier) {
                dropLava(ufo.x + ufo.width / 2, ufo.y + ufo.height);
            }
            
            // Sjekk om UFO har nådd bunnen av skjermen
            if (ufo.y + ufo.height >= SCREEN_HEIGHT - 10) {
                ufos.splice(i, 1);
                lives--;
                
                // Opprett eksplosjon
                createExplosion(ufo.x + ufo.width / 2, SCREEN_HEIGHT - 20);
                
                // Spill treff-lyd
                if (gameSounds.hit) {
                    gameSounds.hit.play();
                }
            }
        }
        
        // Sjekk kollisjon med spiller
        if (checkCollision(ufo, {
            x: playerX,
            y: playerY,
            width: PLAYER_WIDTH,
            height: PLAYER_HEIGHT
        })) {
            // Fjern UFO
            ufos.splice(i, 1);
            
            // Spilleren mister et liv
            lives--;
            
            // Opprett eksplosjon ved spillerposisjonen
            createExplosion(playerX + PLAYER_WIDTH / 2, playerY + PLAYER_HEIGHT / 2, true);
            
            // Spill treff-lyd
            if (gameSounds.hit) {
                gameSounds.hit.play();
            }
        }
    }
    
    
    
    // Periodisk asteroidespawning for boss-nivåer
    if ((level === 5 || level === 10) && currentTime - asteroidTimer > asteroidSpawnInterval) {
        createAsteroid();
        asteroidTimer = currentTime;
    }
}
        function updateLargeUfoMovement(ufo) {
            const currentTime = Date.now();
            
            // Horizontal movement
            ufo.x += ufo.speed * ufo.direction;
            
            // Change direction when hitting screen edge
            if (ufo.x + ufo.width >= SCREEN_WIDTH) {
                ufo.x = SCREEN_WIDTH - ufo.width;
                ufo.direction *= -1;
            } else if (ufo.x <= 0) {
                ufo.x = 0;
                ufo.direction *= -1;
            }
            
            // Vertical movement
            ufo.y += ufo.speed / 2 * ufo.verticalDirection;
            
            // Change vertical direction when hitting boundaries
            if (ufo.y + ufo.height >= SCREEN_HEIGHT - 100) {
                ufo.y = SCREEN_HEIGHT - 100 - ufo.height;
                ufo.verticalDirection = -1;
            } else if (ufo.y <= 50) {
                ufo.y = 50;
                ufo.verticalDirection = 1;
            }
            
            // Boss attacks every 3 seconds
            if (currentTime - ufo.attackTimer > 3000) {
                // Cycle through attack patterns
                bossAttackPattern = (bossAttackPattern + 1) % 3;
                
                // Determine attack color based on boss level
                const attackColor = level === 5 ? COLORS.NEON_GREEN : COLORS.NEON_PINK;
                
                // Execute attack based on pattern
                if (bossAttackPattern === 0) {
                    // Burst attack
                    for (let i = 0; i < 3; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const offsetX = Math.cos(angle) * 30;
                        const offsetY = Math.sin(angle) * 30;
                        dropLava(ufo.x + ufo.width / 2 + offsetX, ufo.y + ufo.height + offsetY, attackColor);
                    }
                } else if (bossAttackPattern === 1) {
                    // Line attack
                    for (let i = -2; i <= 2; i++) {
                        dropLava(ufo.x + ufo.width / 2 + (i * 30), ufo.y + ufo.height, attackColor);
                    }
                } else if (bossAttackPattern === 2) {
                    // Cross attack
                    for (let i = -2; i <= 2; i++) {
                        dropLava(ufo.x + ufo.width / 2 + (i * 30), ufo.y + ufo.height + (i * 30), attackColor);
                        dropLava(ufo.x + ufo.width / 2 - (i * 30), ufo.y + ufo.height + (i * 30), attackColor);
                    }
                }
                
                ufo.attackTimer = currentTime;
            }
        }

        function drawUfos() {
            for (const ufo of ufos) {
                // Draw UFO
                let ufoImage;
                if (ufo.isLarge) {
                    ufoImage = gameImages[level === 5 ? 'bossLvl5' : 'bossLvl10'];
                } else {
                    ufoImage = gameImages[ufo.image] || gameImages.ufo1;
                }
                
                gameCtx.drawImage(ufoImage, ufo.x, ufo.y, ufo.width, ufo.height);
                
                // Draw health bar for boss UFOs
                if (ufo.isLarge) {
                    drawBossHealthBar(ufo);
                }
            }
        }

        function drawBossHealthBar(ufo) {
            const barWidth = ufo.width * 1.2;
            const barHeight = 16;
            const barX = ufo.x + (ufo.width - barWidth) / 2;
            const barY = ufo.y - 25;
            
            // Determine max health and colors based on boss level
            const maxHealth = level === 10 ? 200 : 100;
            const primaryColor = level === 5 ? COLORS.NEON_GREEN : COLORS.NEON_PINK;
            
            // Calculate health ratio
            const healthRatio = Math.max(0, Math.min(ufo.health / maxHealth, 1.0));
            const currentBarWidth = barWidth * healthRatio;
            
            // Draw background
            gameCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            gameCtx.fillRect(barX, barY, barWidth, barHeight);
            
            // Draw health bar with gradient
            const gradient = gameCtx.createLinearGradient(barX, barY, barX + currentBarWidth, barY);
            gradient.addColorStop(0, primaryColor);
            gradient.addColorStop(1, COLORS.NEON_YELLOW);
            
            gameCtx.fillStyle = gradient;
            gameCtx.fillRect(barX, barY, currentBarWidth, barHeight);
            
            // Draw border
            gameCtx.strokeStyle = COLORS.WHITE;
            gameCtx.lineWidth = 2;
            gameCtx.strokeRect(barX, barY, barWidth, barHeight);
            
            // Draw health percentage
            const healthPercent = Math.floor(healthRatio * 100);
            gameCtx.fillStyle = healthPercent > 70 ? COLORS.NEON_GREEN : 
                                (healthPercent > 30 ? COLORS.NEON_YELLOW : COLORS.RED);
            gameCtx.font = '12px monospace';
            gameCtx.textAlign = 'center';
            gameCtx.fillText(`${healthPercent}%`, barX + barWidth / 2, barY + barHeight / 2 + 4);
        }

        function updateLava() {
            for (let i = lavaDrops.length - 1; i >= 0; i--) {
                const lava = lavaDrops[i];
                
                if (lava.isFragment) {
                    // Update fragment movement
                    lava.x += lava.velocityX;
                    lava.y += lava.velocityY;
                    
                    // Add gravity
                    lava.velocityY += 0.1;
                    
                    // Update rotation
                    lava.rotation += lava.rotationSpeed;
                    
                    // Reduce lifetime
                    lava.lifetime--;
                    if (lava.lifetime <= 0 || lava.y > SCREEN_HEIGHT || lava.x < 0 || lava.x > SCREEN_WIDTH) {
                        lavaDrops.splice(i, 1);
                    }
                } else {
                    // Regular lava movement
                    lava.y += lava.speed;
                    
                    // Remove if off screen
                    if (lava.y > SCREEN_HEIGHT) {
                        lavaDrops.splice(i, 1);
                        continue;
                    }
                    
                    // Check collision with player
                    if (checkCollision(lava, {
                        x: playerX,
                        y: playerY,
                        width: PLAYER_WIDTH,
                        height: PLAYER_HEIGHT
                    })) {
                        // Remove lava
                        lavaDrops.splice(i, 1);
                        
                        // Player loses a life
                        lives--;
                        
                        // Create explosion at player position
                        createExplosion(playerX + PLAYER_WIDTH / 2, playerY + PLAYER_HEIGHT / 2, true);
                        
                        // Play hit sound
                        if (gameSounds.hit) {
                            gameSounds.hit.play();
                        }
                    }
                    
                    // Update pulsing effect
                    if (lava.growing) {
                        lava.pulse += 0.05;
                        if (lava.pulse >= 1.3) {
                            lava.growing = false;
                        }
                    } else {
                        lava.pulse -= 0.05;
                        if (lava.pulse <= 0.7) {
                            lava.growing = true;
                        }
                    }
                }
            }
        }

        function drawLava() {
    for (const lava of lavaDrops) {
        const centerX = lava.x + lava.width / 2;
        const centerY = lava.y + lava.height / 2;
        
        if (lava.isFragment) {
            // Fragment tegnes som små glødende biter
            const radius = lava.width / 2;
            
            gameCtx.save();
            gameCtx.translate(centerX, centerY);
            gameCtx.rotate(lava.rotation * Math.PI / 180);
            
            // Tegn fragment som glødende partikkel
            gameCtx.beginPath();
            gameCtx.ellipse(0, 0, radius, radius * 0.5, 0, 0, Math.PI * 2);
            
            // Glød-effekt
            gameCtx.shadowBlur = 15;
            gameCtx.shadowColor = lava.color || COLORS.NEON_PINK;
            
            // Fill
            gameCtx.fillStyle = lava.color || COLORS.NEON_PINK;
            gameCtx.fill();
            
            // Hvit kjerne for intensitet
            gameCtx.beginPath();
            gameCtx.arc(0, 0, radius * 0.3, 0, Math.PI * 2);
            gameCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            gameCtx.fill();
            
            gameCtx.restore();
        } else {
            // Regulær lava tegnes som skummel glødende dråper
            const baseRadius = Math.max(4, lava.width * 1.2 * lava.pulse);
            
            gameCtx.save();
            gameCtx.translate(centerX, centerY);
            gameCtx.rotate(lava.rotation * Math.PI / 180);
            
            // Glød-effekt
            gameCtx.shadowBlur = 20;
            gameCtx.shadowColor = COLORS.ORANGE;
            
            // Tegn dråpen som en tåreformet figur
            gameCtx.beginPath();
            
            // Topp av dråpen (spiss)
            gameCtx.moveTo(0, -baseRadius * 1.5);
            
            // Høyre side av dråpen
            gameCtx.quadraticCurveTo(
                baseRadius, -baseRadius * 0.5, 
                baseRadius, 0
            );
            
            // Bunn av dråpen (buet)
            gameCtx.quadraticCurveTo(
                baseRadius, baseRadius * 1.2, 
                0, baseRadius
            );
            
            // Venstre side av dråpen
            gameCtx.quadraticCurveTo(
                -baseRadius, baseRadius * 1.2, 
                -baseRadius, 0
            );
            
            // Lukk til toppen
            gameCtx.quadraticCurveTo(
                -baseRadius, -baseRadius * 0.5, 
                0, -baseRadius * 1.5
            );
            
            // Fyll med gradient for å skape en glødende effekt
            const gradient = gameCtx.createRadialGradient(0, 0, 0, 0, 0, baseRadius * 1.5);
            gradient.addColorStop(0, '#FFFFFF');
            gradient.addColorStop(0.2, '#FFFF00');
            gradient.addColorStop(0.4, '#FF8800');
            gradient.addColorStop(0.8, '#FF3300');
            gradient.addColorStop(1, '#AA0000');
            
            gameCtx.fillStyle = gradient;
            gameCtx.fill();
            
            // Legg til glødende kontur
            gameCtx.strokeStyle = COLORS.NEON_YELLOW;
            gameCtx.lineWidth = 1;
            gameCtx.stroke();
            
            // Legg til små flammer som kommer ut av lavaen
            const flameCount = 3;
            for (let i = 0; i < flameCount; i++) {
                const flameAngle = (i / flameCount) * Math.PI * 2 + (Date.now() * 0.005 % (Math.PI * 2));
                const flameX = Math.cos(flameAngle) * baseRadius * 0.8;
                const flameY = Math.sin(flameAngle) * baseRadius * 0.8;
                const flameSize = baseRadius * 0.5 * (0.5 + 0.5 * Math.sin(Date.now() * 0.01 + i));
                
                gameCtx.beginPath();
                gameCtx.moveTo(flameX, flameY);
                
                // Tegn flamme
                for (let j = 0; j < 3; j++) {
                    const subAngle = flameAngle + (j - 1) * 0.2;
                    const ctrlX = flameX + Math.cos(subAngle) * flameSize * 1.5;
                    const ctrlY = flameY + Math.sin(subAngle) * flameSize * 1.5;
                    const endX = flameX + Math.cos(flameAngle) * flameSize * 0.8;
                    const endY = flameY + Math.sin(flameAngle) * flameSize * 0.8;
                    
                    gameCtx.quadraticCurveTo(ctrlX, ctrlY, endX, endY);
                }
                
                // Fyll flammen med gradient
                const flameGradient = gameCtx.createRadialGradient(flameX, flameY, 0, flameX, flameY, flameSize);
                flameGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                flameGradient.addColorStop(0.4, 'rgba(255, 255, 0, 0.7)');
                flameGradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                
                gameCtx.fillStyle = flameGradient;
                gameCtx.fill();
            }
            
            gameCtx.restore();
        }
    }
}
        function updatePowerups() {
            for (let i = powerups.length - 1; i >= 0; i--) {
                const powerup = powerups[i];
                
                // Move powerup down
                powerup.y += POWERUP_SPEED;
                
                // Remove if off screen
                if (powerup.y > SCREEN_HEIGHT) {
                    powerups.splice(i, 1);
                    continue;
                }
                
                // Check collision with player
                if (checkCollision(powerup, {
                    x: playerX,
                    y: playerY,
                    width: PLAYER_WIDTH,
                    height: PLAYER_HEIGHT
                })) {
                    // Remove powerup
                    powerups.splice(i, 1);
                    
                    // Apply powerup effect
                    applyPowerup();
                    
                    // Play powerup sound
                    if (gameSounds.powerup) {
                        gameSounds.powerup.play();
                    }
                }
            }
        }

        function drawPowerups() {
    for (const powerup of powerups) {
        // Bruk canvas for å tegne et bedre power-up symbol istedenfor diamantbildet
        const centerX = powerup.x + powerup.width / 2;
        const centerY = powerup.y + powerup.height / 2;
        const size = powerup.width * 0.7;
        
        gameCtx.save();
        
        // Lag en pulserende effekt
        const pulseScale = 1.0 + 0.2 * Math.sin(Date.now() * 0.005);
        
        // Tegn en stjerneformet power-up
        gameCtx.translate(centerX, centerY);
        gameCtx.rotate(Date.now() * 0.001); // Roter over tid
        
        // Glødende bakgrunn
        gameCtx.shadowBlur = 15;
        gameCtx.shadowColor = COLORS.CYAN;
        
        // Stjerne med 6 spisser
        gameCtx.beginPath();
        for (let i = 0; i < 12; i++) {
            const angle = Math.PI * 2 * i / 12;
            const radius = (i % 2 === 0) ? size * 0.5 * pulseScale : size * 0.2 * pulseScale;
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            
            if (i === 0) {
                gameCtx.moveTo(x, y);
            } else {
                gameCtx.lineTo(x, y);
            }
        }
        gameCtx.closePath();
        
        // Gradient-fylling
        const gradient = gameCtx.createRadialGradient(0, 0, size * 0.1, 0, 0, size * 0.5);
        gradient.addColorStop(0, '#FFFFFF');
        gradient.addColorStop(0.5, '#00FFFF');
        gradient.addColorStop(1, '#0080FF');
        
        gameCtx.fillStyle = gradient;
        gameCtx.fill();
        
        // Legge til glødende kant
        gameCtx.strokeStyle = '#FFFFFF';
        gameCtx.lineWidth = 2;
        gameCtx.stroke();
        
        // Legge til senterpunkt 
        gameCtx.beginPath();
        gameCtx.arc(0, 0, size * 0.1, 0, Math.PI * 2);
        gameCtx.fillStyle = '#FFFFFF';
        gameCtx.fill();
        
        gameCtx.restore();
    }
}

        function updateExtraLives() {
            for (let i = extraLifeDrops.length - 1; i >= 0; i--) {
                const extraLife = extraLifeDrops[i];
                
                // Move extra life down
                extraLife.y += EXTRALIFE_SPEED;
                
                // Remove if off screen
                if (extraLife.y > SCREEN_HEIGHT) {
                    extraLifeDrops.splice(i, 1);
                    continue;
                }
                
                // Check collision with player
                if (checkCollision(extraLife, {
                    x: playerX,
                    y: playerY,
                    width: PLAYER_WIDTH,
                    height: PLAYER_HEIGHT
                })) {
                    // Remove extra life
                    extraLifeDrops.splice(i, 1);
                    
                    // Add a life
                    lives++;
                    
                    // Play powerup sound
                    if (gameSounds.powerup) {
                        gameSounds.powerup.play();
                    }
                }
            }
        }

        function drawExtraLives() {
    for (const extraLife of extraLifeDrops) {
        const centerX = extraLife.x + extraLife.width / 2;
        const centerY = extraLife.y + extraLife.height / 2;
        const size = extraLife.width * 0.7;
        
        // Pulsering basert på tid
        const pulseIntensity = 0.2 * Math.sin(Date.now() * 0.006) + 1.0;
        
        gameCtx.save();
        
        // Sett glødende effekt
        gameCtx.shadowBlur = 15;
        gameCtx.shadowColor = '#FF3E61';
        
        // Tegn hjerte
        gameCtx.translate(centerX, centerY);
        gameCtx.scale(pulseIntensity, pulseIntensity);
        
        gameCtx.beginPath();
        
        // Tegn et hjerte med path
        const heartPath = (size) => {
            gameCtx.beginPath();
            gameCtx.moveTo(0, size * 0.3);
            
            // Venstre kurve
            gameCtx.bezierCurveTo(
                -size * 0.55, -size * 0.3, 
                -size * 0.85, size * 0.3, 
                0, size * 0.8
            );
            
            // Høyre kurve
            gameCtx.bezierCurveTo(
                size * 0.85, size * 0.3, 
                size * 0.55, -size * 0.3, 
                0, size * 0.3
            );
        };
        
        // Tegn glødende omriss
        heartPath(size + 3);
        gameCtx.fillStyle = 'rgba(255, 62, 97, 0.3)';
        gameCtx.fill();
        
        // Tegn hovedhjertet
        heartPath(size);
        
        // Gradientfylling
        const gradient = gameCtx.createRadialGradient(0, size * 0.2, 0, 0, size * 0.2, size);
        gradient.addColorStop(0, '#FF3E61');
        gradient.addColorStop(0.7, '#FF0040');
        gradient.addColorStop(1, '#C00030');
        
        gameCtx.fillStyle = gradient;
        gameCtx.fill();
        
        // Legg til en glødende hvit highlight i toppen
        gameCtx.beginPath();
        gameCtx.ellipse(-size * 0.25, -size * 0.1, size * 0.15, size * 0.1, Math.PI / 4, 0, Math.PI * 2);
        gameCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        gameCtx.fill();
        
        gameCtx.restore();
    }
    
    
}
        function updateExplosions() {
            const currentTime = Date.now();
            
            for (let i = explosions.length - 1; i >= 0; i--) {
                const explosion = explosions[i];
                
                // Calculate frame duration based on multiplier
                const frameDuration = 50 * (explosion.durationMultiplier || 1);
                
                // Update animation frame
                if (currentTime - explosion.timer > frameDuration) {
                    explosion.index++;
                    explosion.timer = currentTime;
                    
                    // Keep last frame longer for boss explosions
                    if (explosion.isBossExplosion && explosion.index >= 4) {
                        explosion.durationMultiplier *= 2;
                    }
                    
                    // Remove explosion when animation is complete
                    if (explosion.index >= 5) {
                        explosions.splice(i, 1);
                    }
                }
            }
        }

        function drawExplosions() {
            for (const explosion of explosions) {
                if (explosion.index < 5) {
                    // Use explosion frame based on index
                    const explosionImage = gameImages[`explosion${explosion.index + 1}`];
                    
                    if (explosionImage) {
                        const scale = explosion.scale || 1;
                        const width = 50 * scale;
                        const height = 50 * scale;
                        const x = explosion.x - width / 2;
                        const y = explosion.y - height / 2;
                        
                        gameCtx.save();
                        
                        // Apply color modification if specified
                        if (explosion.colorMod) {
                            // This is a simplified version of color modification
                            // In a real implementation, we would use composite operations
                            gameCtx.globalAlpha = 0.8;
                            gameCtx.drawImage(explosionImage, x, y, width, height);
                            
                            gameCtx.globalCompositeOperation = 'source-atop';
                            gameCtx.fillStyle = explosion.colorMod;
                            gameCtx.globalAlpha = 0.5;
                            gameCtx.fillRect(x, y, width, height);
                            
                            gameCtx.globalCompositeOperation = 'source-over';
                            gameCtx.globalAlpha = 1.0;
                        } else {
                            gameCtx.drawImage(explosionImage, x, y, width, height);
                        }
                        
                        gameCtx.restore();
                    }
                }
            }
        }

        function updateAsteroids() {
            for (let i = asteroids.length - 1; i >= 0; i--) {
                const asteroid = asteroids[i];
                
                // Move asteroid
                asteroid.x += asteroid.speedX;
                asteroid.y += asteroid.speedY;
                
                // Update rotation
                asteroid.rotation += asteroid.rotationSpeed;
                
                // Remove if off screen
                if (asteroid.y > SCREEN_HEIGHT || asteroid.x < -asteroid.width || asteroid.x > SCREEN_WIDTH + asteroid.width) {
                    asteroids.splice(i, 1);
                    continue;
                }
                
                // Check collision with player
                if (checkCollision(asteroid, {
                    x: playerX,
                    y: playerY,
                    width: PLAYER_WIDTH,
                    height: PLAYER_HEIGHT
                })) {
                    // Remove asteroid
                    asteroids.splice(i, 1);
                    
                    // Player loses a life
                    lives--;
                    
                    // Create explosion at player position
                    createExplosion(playerX + PLAYER_WIDTH / 2, playerY + PLAYER_HEIGHT / 2, true);
                    
                    // Play hit sound
                    if (gameSounds.hit) {
                        gameSounds.hit.play();
                    }
                    
                    continue;
                }
                
                // Check collision with bullets
                for (let j = bullets.length - 1; j >= 0; j--) {
                    const bullet = bullets[j];
                    
                    if (checkCollision(asteroid, bullet)) {
                        // Remove bullet and asteroid
                        bullets.splice(j, 1);
                        asteroids.splice(i, 1);
                        
                        // Add score
                        score += 15;
                        
                        // Create explosion
                        createExplosion(asteroid.x + asteroid.width / 2, asteroid.y + asteroid.height / 2);
                        
                        // Play explosion sound
                        if (gameSounds.explosion) {
                            gameSounds.explosion.play();
                        }
                        
                        break;
                    }
                }
            }
        }

        function drawAsteroids() {
            for (const asteroid of asteroids) {
                gameCtx.save();
                
                // Translate to center of asteroid for rotation
                gameCtx.translate(
                    asteroid.x + asteroid.width / 2,
                    asteroid.y + asteroid.height / 2
                );
                
                // Rotate
                gameCtx.rotate(asteroid.rotation * Math.PI / 180);
                
                // Draw asteroid
                if (gameImages.asteroid) {
                    gameCtx.drawImage(
                        gameImages.asteroid,
                        -asteroid.width / 2,
                        -asteroid.height / 2,
                        asteroid.width,
                        asteroid.height
                    );
                } else {
                    // Fallback: draw a polygon shape
                    const radius = asteroid.width / 2;
                    gameCtx.beginPath();
                    
                    // Draw irregular shape
                    for (let i = 0; i < 12; i++) {
                        const angle = Math.PI * 2 * i / 12;
                        const pointRadius = radius * (0.8 + Math.sin(i * 2.5) * 0.2);
                        const x = Math.cos(angle) * pointRadius;
                        const y = Math.sin(angle) * pointRadius;
                        
                        if (i === 0) {
                            gameCtx.moveTo(x, y);
                        } else {
                            gameCtx.lineTo(x, y);
                        }
                    }
                    
                    gameCtx.closePath();
                    
                    // Fill with neon green
                    gameCtx.fillStyle = COLORS.NEON_GREEN;
                    gameCtx.fill();
                    
                    // Add glow
                    gameCtx.shadowBlur = 10;
                    gameCtx.shadowColor = COLORS.NEON_GREEN;
                    gameCtx.strokeStyle = COLORS.WHITE;
                    gameCtx.lineWidth = 2;
                    gameCtx.stroke();
                    gameCtx.shadowBlur = 0;
                    
                    // Add some details (craters)
                    for (let i = 0; i < 3; i++) {
                        const craterX = (Math.random() - 0.5) * radius;
                        const craterY = (Math.random() - 0.5) * radius;
                        const craterSize = Math.random() * 5 + 3;
                        
                        gameCtx.beginPath();
                        gameCtx.arc(craterX, craterY, craterSize, 0, Math.PI * 2);
                        gameCtx.fillStyle = 'rgba(0, 100, 0, 0.8)';
                        gameCtx.fill();
                    }
                }
                
                gameCtx.restore();
            }
        }

        function drawUI() {
    // Score med kraftigere neon-effekt
    gameCtx.fillStyle = COLORS.NEON_YELLOW;
    gameCtx.font = 'bold 24px monospace';  // Større font
    gameCtx.textAlign = 'left';
    gameCtx.shadowBlur = 15;  // Sterkere glow
    gameCtx.shadowColor = COLORS.NEON_YELLOW;
    gameCtx.fillText(`Score: ${score}`, 15, 30);
    
    // Level med sterkere neon-effekt
    gameCtx.fillStyle = COLORS.NEON_PINK;
    gameCtx.shadowBlur = 15;  // Sterkere glow
    gameCtx.shadowColor = COLORS.NEON_PINK;
    gameCtx.fillText(`Level: ${level}`, 15, 60);
    
    // Lives med sterkere neon-effekt
    gameCtx.fillStyle = COLORS.NEON_GREEN;
    gameCtx.shadowBlur = 15;  // Sterkere glow
    gameCtx.shadowColor = COLORS.NEON_GREEN;
    gameCtx.fillText('Lives:', 15, 90);
    
    // Fjern shadow-effekten for resten av tegningen
    gameCtx.shadowBlur = 0;
    
    // Tegn hjertene litt lengre til høyre
    for (let i = 0; i < 5; i++) {
        if (i < lives) {
            // Active life med sterkere glødende effekt
            gameCtx.save();
            gameCtx.shadowBlur = 15;  // Sterkere glow
            gameCtx.shadowColor = '#FF3E61';
            gameCtx.drawImage(gameImages.extralife, 95 + i * 25, 70, 20, 20);  // Flyttet fra 70 til 80
            gameCtx.restore();
        } else {
            // Inactive life
            gameCtx.globalAlpha = 0.3;
            gameCtx.drawImage(gameImages.extralife, 95 + i * 25, 70, 20, 20);  // Flyttet fra 70 til 80
            gameCtx.globalAlpha = 1.0;
        }
    }
    
    // Vis ekstra liv-indikator hvis spilleren har mer enn 5 liv
    if (lives > 5) {
        const extraLives = lives - 5;
        gameCtx.save();
        
        const textX = 80 + 5 * 25 + 5;  // Justert posisjonen
        const textY = 85;
        
        gameCtx.shadowBlur = 15;  // Sterkere glow
        gameCtx.shadowColor = '#FF3E61';
        gameCtx.font = 'bold 18px monospace';  // Litt større font
        gameCtx.fillStyle = '#FF3E61';
        gameCtx.textAlign = 'left';
        gameCtx.fillText(`+${extraLives}`, textX, textY);
        
        gameCtx.restore();
    }
}

        function checkCollision(obj1, obj2) {
            return (
                obj1.x < obj2.x + obj2.width &&
                obj1.x + obj1.width > obj2.x &&
                obj1.y < obj2.y + obj2.height &&
                obj1.y + obj1.height > obj2.y
            );
        }

        // Viktig fiks: Erstatt den eksisterende checkLevelCompletion funksjonen med denne:
        function checkLevelCompletion() {
    // Check if player has lost all lives
    if (lives <= 0) {
        gameOver();
        return;
    }
    
    // Ignorer level completion check hvis vi allerede er i boss explosion eller andre slutttilstander
    if (gameState !== 'playing') {
        return;
    }
    
    // Check if all UFOs are destroyed
    if (ufos.length === 0) {
        console.log("All UFOs defeated - showing level victory animation");
        
        // For level 5 og 10, håndterer vi fullføring i boss explosion handler
        // For andre nivåer, fortsett til level complete direkte
        if ((level === 5 && largeUfoCreated) || (level === 10 && largeUfo2Created)) {
            // Boss levels er håndtert av createBossExplosion som vil kalle levelComplete
            return;
        }
        
        // Stop gameloop first
        if (gameLoop) {
            cancelAnimationFrame(gameLoop);
            gameLoop = null;
        }
        
        // Reset all key states to prevent accidental dismissal
        keys = {};
        
        // Create a temporary victory message overlay
        const victoryOverlay = document.createElement('div');
        victoryOverlay.style.position = 'absolute';
        victoryOverlay.style.top = '0';
        victoryOverlay.style.left = '0';
        victoryOverlay.style.width = '100%';
        victoryOverlay.style.height = '100%';
        victoryOverlay.style.display = 'flex';
        victoryOverlay.style.justifyContent = 'center';
        victoryOverlay.style.alignItems = 'center';
        victoryOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        victoryOverlay.style.zIndex = '15';
        victoryOverlay.style.flexDirection = 'column';
        
        // Add victory text
        const victoryText = document.createElement('div');
        victoryText.textContent = 'LEVEL CLEARED!';
        victoryText.style.fontSize = '5rem';
        victoryText.style.color = '#FF14A3'; // NEON_PINK
        victoryText.style.textShadow = '0 0 10px #fff, 0 0 20px #fff, 0 0 30px #FF14A3, 0 0 40px #FF14A3';
        victoryText.style.animation = 'textPulse 1.5s infinite';
        victoryOverlay.appendChild(victoryText);
        
        // Add level number
        const levelText = document.createElement('div');
        levelText.textContent = `LEVEL ${level} COMPLETE`;
        levelText.style.marginTop = '10px';
        levelText.style.fontSize = '2rem';
        levelText.style.color = '#FFFF66'; // NEON_YELLOW
        levelText.style.textShadow = '0 0 5px #fff, 0 0 10px #FFFF66';
        victoryOverlay.appendChild(levelText);
        
        // Add "press space/enter" text
        const pressKeyText = document.createElement('div');
        pressKeyText.textContent = 'PRESS SPACE OR ENTER TO CONTINUE';
        pressKeyText.style.marginTop = '40px';
        pressKeyText.style.fontSize = '1.5rem';
        pressKeyText.style.color = '#fff';
        pressKeyText.style.textShadow = '0 0 5px #fff, 0 0 10px #39FF14';
        pressKeyText.style.animation = 'pulse 1.5s infinite';
        victoryOverlay.appendChild(pressKeyText);
        
        // Add overlay to the game container
        document.getElementById('gameContainer').appendChild(victoryOverlay);
        
        // Play a victory sound if available
        if (gameSounds.powerup) {
            gameSounds.powerup.play();
        }
        
        // Set up event listener for specific key press (Space or Enter only)
        const handleKeyPress = function(e) {
            if (e.key === ' ' || e.key === 'Enter') {
                // Remove overlay
                victoryOverlay.remove();
                
                // Remove event listener
                window.removeEventListener('keydown', handleKeyPress);
                
                // Go to level complete screen
                levelComplete();
            }
        };
        
        // Wait a short time before enabling key listener to prevent accidental skipping
        setTimeout(() => {
            // Listen for Space or Enter key press
            window.addEventListener('keydown', handleKeyPress);
            
            // Update the instruction text to show it's now active
            pressKeyText.style.opacity = '1';
        }, 500);
        
        // Auto-continue after 10 seconds if no key press (longer delay)
        setTimeout(() => {
            if (document.getElementById('gameContainer').contains(victoryOverlay)) {
                victoryOverlay.remove();
                window.removeEventListener('keydown', handleKeyPress);
                levelComplete();
            }
        }, 10000);
        
        // Update game state to prevent multiple calls
        gameState = 'levelVictory';
    }
}


        function nextLevel() {
    console.log("Advancing to next level");
    
    // Skjul level complete screen først
    document.getElementById('levelCompleteScreen').classList.add('hidden');
    
    // Clear all game objects
    bullets = [];
    lavaDrops = [];
    powerups = [];
    extraLifeDrops = [];
    explosions = [];
    asteroids = [];
    
    // Reset level-specific flags
    levelExtraLifeDropped = false;
    largeUfoCreated = level >= 5; // Sett til true kun hvis vi allerede har passert boss-nivået
    largeUfo2Created = level >= 10; // Sett til true kun hvis vi allerede har passert siste boss
    
    // Viktig: Nullstill flagget for nye rader
    window.addedNewRowsForLevel = false;
    
    // Move to next level
    level++;
    
    console.log("Starting level " + level);
    
    if (level <= MAX_LEVEL) {
        // Start next level
        startLevelCountdown();
    } else {
        // Game completed!
        victory();
    }
}
function victory() {
    console.log("Game completed! Victory!");
    
    // Stop game loop if it's still running
    if (gameLoop) {
        cancelAnimationFrame(gameLoop);
        gameLoop = null;
    }
    
    // Set game state explicitly
    gameState = 'victory';
    
    // Clear any remaining game objects
    bullets = [];
    lavaDrops = [];
    powerups = [];
    extraLifeDrops = [];
    explosions = [];
    asteroids = [];
    
    // Add final bonus for completing the game
    const finalBonus = lives * 100;
    score += finalBonus;
    
    // Create a special victory effect
    const victoryOverlay = document.createElement('div');
    victoryOverlay.style.position = 'absolute';
    victoryOverlay.style.top = '0';
    victoryOverlay.style.left = '0';
    victoryOverlay.style.width = '100%';
    victoryOverlay.style.height = '100%';
    victoryOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    victoryOverlay.style.display = 'flex';
    victoryOverlay.style.flexDirection = 'column';
    victoryOverlay.style.justifyContent = 'center';
    victoryOverlay.style.alignItems = 'center';
    victoryOverlay.style.zIndex = '20';
    
    // Create victory title
    const victoryTitle = document.createElement('h1');
    victoryTitle.textContent = 'GAME COMPLETED!';
    victoryTitle.style.fontSize = '4rem';
    victoryTitle.style.color = '#39FF14'; // NEON_GREEN
    victoryTitle.style.textShadow = '0 0 10px #fff, 0 0 20px #fff, 0 0 30px #39FF14, 0 0 40px #39FF14';
    victoryTitle.style.marginBottom = '30px';
    victoryTitle.style.animation = 'textPulse 1.5s infinite';
    victoryOverlay.appendChild(victoryTitle);
    
    // Create some celebration effects (confetti-like elements)
    const confettiContainer = document.createElement('div');
    confettiContainer.style.position = 'absolute';
    confettiContainer.style.top = '0';
    confettiContainer.style.left = '0';
    confettiContainer.style.width = '100%';
    confettiContainer.style.height = '100%';
    confettiContainer.style.overflow = 'hidden';
    confettiContainer.style.pointerEvents = 'none';
    victoryOverlay.appendChild(confettiContainer);
     

    
    // Create animated confetti
    for (let i = 0; i < 100; i++) {
        const confetti = document.createElement('div');
        const size = Math.random() * 15 + 5;
        const isRectangle = Math.random() > 0.5;
        const colors = ['#39FF14', '#FF14A3', '#FFFF66', '#00FFFF']; // Neon colors
        
        confetti.style.position = 'absolute';
        confetti.style.width = isRectangle ? `${size}px` : `${size * 0.6}px`;
        confetti.style.height = `${size}px`;
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.left = `${Math.random() * 100}%`;
        confetti.style.top = `-${size}px`;
        confetti.style.borderRadius = isRectangle ? '2px' : '50%';
        confetti.style.boxShadow = `0 0 5px ${confetti.style.backgroundColor}`;
        
        // Random animation duration and delay
        const animDuration = Math.random() * 3 + 2;
        const animDelay = Math.random() * 2;
        
        confetti.style.animation = `fall ${animDuration}s linear ${animDelay}s infinite`;
        confettiContainer.appendChild(confetti);
    }
    
    // Create bonus text
    const bonusText = document.createElement('div');
    bonusText.textContent = `FINAL BONUS: ${finalBonus}`;
    bonusText.style.fontSize = '2rem';
    bonusText.style.color = '#FFFF66'; // NEON_YELLOW
    bonusText.style.textShadow = '0 0 5px #fff, 0 0 10px #FFFF66';
    bonusText.style.margin = '15px 0';
    victoryOverlay.appendChild(bonusText);
    
    // Create score text
    const scoreText = document.createElement('div');
    scoreText.textContent = `FINAL SCORE: ${score}`;
    scoreText.style.fontSize = '2.5rem';
    scoreText.style.color = '#FF14A3'; // NEON_PINK
    scoreText.style.textShadow = '0 0 5px #fff, 0 0 10px #FF14A3';
    scoreText.style.margin = '15px 0';
    victoryOverlay.appendChild(scoreText);
    
    // Create prompt text
    const promptText = document.createElement('div');
    promptText.textContent = 'PRESS ANY KEY TO CONTINUE';
    promptText.style.fontSize = '1.5rem';
    promptText.style.color = '#fff';
    promptText.style.textShadow = '0 0 5px #fff';
    promptText.style.marginTop = '40px';
    promptText.style.animation = 'pulse 1.5s infinite';
    victoryOverlay.appendChild(promptText);
    
    // Add the overlay to the game container
    document.getElementById('gameContainer').appendChild(victoryOverlay);
    
    // Play victory sound if available
    if (gameSounds.powerup) {
        gameSounds.powerup.play();
        setTimeout(() => {
            if (gameSounds.powerup) gameSounds.powerup.play();
        }, 500);
    }
    
    
    playBackgroundMusic(0);
    // Set up event listener for any key press
    const handleKeyPress = function() {
        // Remove overlay
        victoryOverlay.remove();
        
        // Remove event listener
        window.removeEventListener('keydown', handleKeyPress);
        
        // VIkTIG ENDRING: Gå direkte til Game Over/Highscore i stedet for 'victory' screen
        endGame();
    };
    
    // Listen for any key press
    window.addEventListener('keydown', handleKeyPress);
    
    // Auto-continue after 10 seconds if no key press
    setTimeout(() => {
        if (document.getElementById('gameContainer').contains(victoryOverlay)) {
            victoryOverlay.remove();
            window.removeEventListener('keydown', handleKeyPress);
            endGame();
        }
    }, 10000);
}

// Modifiser endGame-funksjonen for å inkludere credits
function endGame() {
    console.log("Ending game");
    // Check if score qualifies for highscore
    const isHighscore = highscores.length < 10 || score > highscores[highscores.length - 1].score;
    
    if (isHighscore) {
        // Show highscore input
        document.getElementById('highscoreInput').classList.remove('hidden');
        document.getElementById('playerNameInput').focus();
        
        // Show game over screen
        showScreen('gameOver');
    } else {
        // Show highscores directly
        showHighscores();
    }
}

function startScreenRotation() {
    // Stopp eksisterende timer hvis den finnes
    if (screenRotationTimer) {
        clearInterval(screenRotationTimer);
    }
    
    // Start med game over-skjermen
    currentRotationScreen = 'gameOver';
    showScreen('gameOver');
    
    // Spill Evil Invaders.mp3 hvis den ikke allerede spilles
    if (!backgroundMusic || backgroundMusic.paused || 
        !backgroundMusic.src.endsWith('Evil Invaders.mp3')) {
        playBackgroundMusic(0);
    }
    
    // Funksjon for å rotere til neste skjerm
    function rotateToNextScreen() {
        // Sjekk om highscore input er synlig - vent lenger i så fall
        const highscoreInput = document.getElementById('highscoreInput');
        if (highscoreInput && !highscoreInput.classList.contains('hidden')) {
            // Highscore-skjemaet er synlig, vent 30 sekunder
            screenRotationTimer = setTimeout(rotateToNextScreen, 30000);
            return;
        }
        
        // Roter til neste skjerm basert på gjeldende skjerm
        if (currentRotationScreen === 'gameOver') {
            currentRotationScreen = 'highscores';
            showHighscores();
            // Venter 10 sekunder på highscore-skjermen
            screenRotationTimer = setTimeout(rotateToNextScreen, 10000);
        } else if (currentRotationScreen === 'highscores') {
            currentRotationScreen = 'credits';
            showCredits();
            // Venter 5 sekunder på credits-skjermen
            screenRotationTimer = setTimeout(rotateToNextScreen, 5000);
        } else {
            currentRotationScreen = 'gameOver';
            showScreen('gameOver');
            // Venter 5 sekunder på game over-skjermen
            screenRotationTimer = setTimeout(rotateToNextScreen, 5000);
        }
    }
    
    // Start rotasjonen - vent 5 sekunder på den første game over-skjermen
    // (eller 30 sekunder hvis highscore-input er synlig)
    screenRotationTimer = setTimeout(rotateToNextScreen, 5000);
}

function gameOver() {
    console.log("Game over!");
    cancelAnimationFrame(gameLoop);
    
    // Last inn de nyeste highscores først
    loadHighscores();
    
    // Deretter sjekk om scoren kvalifiserer, med en kort forsinkelse
    // for å sikre at highscores er lastet
    setTimeout(() => {
        // Sjekk om score kvalifiserer som highscore
        const isHighscore = checkHighscore(score);
        
        if (isHighscore) {
            // Sørg for at animasjonene er definert
            if (!document.getElementById('highscore-animation-style')) {
                const style = document.createElement('style');
                style.id = 'highscore-animation-style';
                style.textContent = `
                    @keyframes textPulse {
                        0% { text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #39FF14, 0 0 20px #39FF14; opacity: 1; }
                        50% { text-shadow: 0 0 2px #fff, 0 0 5px #39FF14; opacity: 0.7; }
                        100% { text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #39FF14, 0 0 20px #39FF14; opacity: 1; }
                    }
                    
                    .highscore-animation {
                        font-size: 1.5rem;
                        text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #39FF14, 0 0 20px #39FF14;
                        animation: textPulse 0.8s infinite alternate;
                        margin-bottom: 15px;
                        letter-spacing: 2px;
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Vis highscore input
            document.getElementById('highscoreInput').classList.remove('hidden');
            
            // Framhev NEW HIGHSCORE! teksten med animasjon
            const highscoreText = document.querySelector('#highscoreInput .neon-text');
            highscoreText.textContent = 'GLOBAL HIGHSCORE!';
            highscoreText.classList.add('highscore-animation');
            
            // Spill en spesiell lyd for ny highscore
            if (gameSounds.powerup) {
                gameSounds.powerup.play();
            }
            
            // Fokuser på input-feltet
            setTimeout(() => {
                document.getElementById('playerNameInput').focus();
            }, 200);
        } else {
            // Ikke en highscore, bare vis highscores-skjermen
            showHighscores();
            startScreenRotation();
        }
        
        // Vis game over screen
        showScreen('gameOver');
    }, 500);
}

function submitHighscore() {
    const playerName = document.getElementById('playerNameInput').value.trim() || 'PLAYER';
    const timestamp = new Date().toISOString();
    
    // Sanitiser spillernavnet (fjern uønskede tegn)
    const sanitizedName = playerName.replace(/[^a-zA-ZæøåÆØÅ0-9\s]/gi, '').substring(0, 15);

    
    // Opprett highscore-objekt
    const highscoreData = {
        name: sanitizedName,
        score: score,
        level: level,
        date: timestamp,
        // Valgfritt: legg til hvilket nivå spilleren nådde
        // og hvilken versjon av spillet som ble spilt
        gameVersion: "1.0"
    };
    
    console.log("Submitting highscore:", highscoreData);
    
    // Lagre til Firebase
    db.collection("highscores").add(highscoreData)
        .then((docRef) => {
            console.log("Highscore saved with ID:", docRef.id);
            
            // Last inn oppdaterte highscores
            loadHighscores();
            
            // Skjul input-skjema
            document.getElementById('highscoreInput').classList.add('hidden');
            
            isNewHighscore = false;
            
            // Vis highscores-skjerm
            showHighscores();
            
            // Start skjermrotasjon
            startScreenRotation();
        })
        .catch((error) => {
            console.error("Error adding highscore:", error);
            
            // Fallback til lokal lagring hvis Firebase feiler
            highscores.push(highscoreData);
            highscores.sort((a, b) => b.score - a.score);
            highscores = highscores.slice(0, 20);
            localStorage.setItem('evilInvadersHighscores', JSON.stringify(highscores));
            
            // Skjul input-skjema
            document.getElementById('highscoreInput').classList.add('hidden');
            
            isNewHighscore = false;
            
            // Vis highscores-skjerm
            showHighscores();
            
            // Start skjermrotasjon
            startScreenRotation();
        });
}
        function showHighscores() {
    console.log("Showing highscores screen");
    
    // Oppdater highscores-listen
    if (typeof displayHighscores === 'function') {
        displayHighscores();
    } else {
        // Fallback hvis displayHighscores ikke er definert...
    }
    
    // Vis highscores-skjermen
    showScreen('highscores');
    
    // Nå, la oss oppdatere overskriften med neon-effekt
    const highscoreTitle = document.querySelector('#highscoresScreen h1');
    if (highscoreTitle) {
        highscoreTitle.className = 'neon-pink';
        highscoreTitle.style.textShadow = '0 0 5px #fff, 0 0 10px #fff, 0 0 15px #FF14A3, 0 0 20px #FF14A3';
        highscoreTitle.style.animation = 'textPulse 1.5s infinite';
        highscoreTitle.style.marginBottom = '30px';
        highscoreTitle.style.fontSize = '3rem';
    }
}

// Nå, la oss definere displayHighscores på nytt for å være sikker
function displayHighscores() {
    console.log("Displaying highscores");
    
    // Sørg for at animasjonene er definert først
    addFloatingAnimation();
    
    const highscoreList = document.getElementById('highscoreList');
    if (!highscoreList) {
        console.error("Highscore list element not found!");
        return;
    }
    
    highscoreList.innerHTML = '';
    
    // Create header
    const header = document.createElement('div');
    header.className = 'highscore-item';
    header.innerHTML = '<span>RANK</span><span>NAME</span><span>SCORE</span><span>LEVEL</span>';
    header.style.color = COLORS.NEON_GREEN;
    header.style.textShadow = `0 0 8px ${COLORS.NEON_GREEN}, 0 0 12px ${COLORS.NEON_GREEN}`;
    header.style.marginBottom = '10px';
    header.style.borderBottom = `2px solid ${COLORS.NEON_GREEN}`;
    header.style.fontWeight = 'bold';
    header.style.display = 'grid';
    header.style.gridTemplateColumns = '0.7fr 2fr 1fr 0.7fr';
    highscoreList.appendChild(header);
    
    // Neon farger for topp 20
    const neonColors = [
        COLORS.NEON_PINK,    // 1st plass - Neon rosa
        COLORS.NEON_YELLOW,  // 2nd plass - Neon gul
        COLORS.NEON_GREEN,   // 3rd plass - Neon grønn
        COLORS.CYAN,         // 4th plass - Cyan
        COLORS.NEON_YELLOW,  // 5th plass - Neon gul
        COLORS.NEON_PINK,    // osv.
        COLORS.NEON_GREEN,
        COLORS.CYAN,
        COLORS.NEON_YELLOW,
        COLORS.NEON_PINK,
        // For plassene 11-20
        '#FF9966', // Lysoransje
        '#66FFFF', // Lysere cyan
        '#CCFF99', // Lysegrønn
        '#FF99CC', // Lysrosa
        '#99CCFF', // Lyseblå
        '#FFCC99', // Fersken
        '#CCFFFF', // Svært lys cyan
        '#FFFFCC', // Svært lys gul
        '#FFCCFF', // Svært lys rosa
        '#CCCCFF'  // Svært lys lilla
    ];
    
    // Finn om spilleren nettopp har lagt inn en highscore
    let playerName = '';
    if (document.getElementById('playerNameInput')) {
        playerName = document.getElementById('playerNameInput').value.trim() || 'PLAYER';
    }
    
    // Legg til hver highscore
    highscores.forEach((scoreEntry, index) => {
        if (index >= 20) return; // Bare vis topp 20
        
        const item = document.createElement('div');
        item.className = 'highscore-item';
        
        // Oppdater styling for grid
        item.style.display = 'grid';
        item.style.gridTemplateColumns = '0.7fr 2fr 1fr 0.7fr';
        item.style.padding = '8px 0';
        item.style.marginBottom = '5px';
        item.style.borderBottom = '1px solid rgba(255, 255, 255, 0.2)';
        
        // Sett forsinkelse for animasjon
        item.style.setProperty('--delay', index.toString());
        
        // Format rank
        let rankText;
        if (index === 0) rankText = '1ST';
        else if (index === 1) rankText = '2ND';
        else if (index === 2) rankText = '3RD';
        else rankText = `${index + 1}TH`;
        
        // Set neon color basert på plassering
        const neonColor = neonColors[index % neonColors.length];
        item.style.color = neonColor;
        
        // Forbedret tekstskygge-effekt
        item.style.textShadow = `0 0 5px ${neonColor}, 0 0 10px ${neonColor}, 0 0 15px rgba(255,255,255,0.5)`;
        
        // Sjekk om dette er spillerens nye highscore
        const isNewHighscore = scoreEntry.name === playerName && scoreEntry.score === score;
        
        // Legg til NEW-merke for ny score, og vis level
        const levelText = scoreEntry.level ? `${scoreEntry.level}` : '-';
        
        if (isNewHighscore) {
            item.classList.add('float-item');
            item.innerHTML = `
                <span>${rankText}</span>
                <span>${scoreEntry.name} <span class="new-badge">NEW!</span></span>
                <span>${scoreEntry.score.toLocaleString()}</span>
                <span>${levelText}</span>
            `;
        } else {
            item.innerHTML = `
                <span>${rankText}</span>
                <span>${scoreEntry.name}</span>
                <span>${scoreEntry.score.toLocaleString()}</span>
                <span>${levelText}</span>
            `;
        }
        
        highscoreList.appendChild(item);
    });
    
    // Hvis ingen highscores, vis melding
    if (highscores.length === 0) {
        const noScores = document.createElement('div');
        noScores.textContent = 'LOADING GLOBAL HIGHSCORES...';
        noScores.style.color = COLORS.NEON_YELLOW;
        noScores.style.textShadow = `0 0 5px ${COLORS.NEON_YELLOW}, 0 0 10px ${COLORS.NEON_YELLOW}`;
        noScores.style.textAlign = 'center';
        noScores.style.marginTop = '20px';
        highscoreList.appendChild(noScores);
    }
    
    // Legg til oppdateringstid
    const updateTime = document.createElement('div');
    updateTime.textContent = 'Last updated: ' + new Date().toLocaleTimeString();
    updateTime.style.fontSize = '12px';
    updateTime.style.color = '#999';
    updateTime.style.textAlign = 'right';
    updateTime.style.marginTop = '15px';
    updateTime.style.padding = '0 10px';
    highscoreList.appendChild(updateTime);
}

// Sørg for at addFloatingAnimation er definert
function addFloatingAnimation() {
    // Sjekk om stilen allerede finnes
    if (document.getElementById('floating-animation-style')) {
        return;
    }
    
    const style = document.createElement('style');
    style.id = 'floating-animation-style';
    style.textContent = `
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
            100% { transform: translateY(0px); }
        }
        
        @keyframes glow {
            0% { text-shadow: 0 0 5px currentColor, 0 0 10px currentColor; }
            50% { text-shadow: 0 0 10px currentColor, 0 0 20px currentColor, 0 0 30px rgba(255,255,255,0.5); }
            100% { text-shadow: 0 0 5px currentColor, 0 0 10px currentColor; }
        }
        
        .highscore-item {
            animation: float 3s ease-in-out infinite;
            animation-delay: calc(var(--delay) * 0.5s);
        }
        
        .float-item {
            animation: float 3s ease-in-out infinite, glow 2s ease-in-out infinite;
        }
        
        .new-badge {
            background-color: #39FF14;
            color: #000;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.8em;
            margin-left: 5px;
            animation: pulse 0.8s infinite alternate;
        }
        
        @keyframes pulse {
            0% { opacity: 0.7; }
            100% { opacity: 1; }
        }
    `;
    document.head.appendChild(style);
}

        function drawLava() {
    for (const lava of lavaDrops) {
        const centerX = lava.x + lava.width / 2;
        const centerY = lava.y + lava.height / 2;
        
        if (lava.isFragment) {
            // Fragment tegnes som små glødende biter
            const radius = lava.width / 2;
            
            gameCtx.save();
            gameCtx.translate(centerX, centerY);
            gameCtx.rotate(lava.rotation * Math.PI / 180);
            
            // Tegn fragment som glødende partikkel
            gameCtx.beginPath();
            gameCtx.ellipse(0, 0, radius, radius * 0.5, 0, 0, Math.PI * 2);
            
            // Glød-effekt
            gameCtx.shadowBlur = 15;
            gameCtx.shadowColor = lava.color || COLORS.NEON_PINK;
            
            // Fill
            gameCtx.fillStyle = lava.color || COLORS.NEON_PINK;
            gameCtx.fill();
            
            // Hvit kjerne for intensitet
            gameCtx.beginPath();
            gameCtx.arc(0, 0, radius * 0.3, 0, Math.PI * 2);
            gameCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            gameCtx.fill();
            
            gameCtx.restore();
        } else {
            // Regulær lava tegnes som skummel glødende dråper
            const baseRadius = Math.max(4, lava.width * 1.2 * lava.pulse);
            
            gameCtx.save();
            gameCtx.translate(centerX, centerY);
            gameCtx.rotate(lava.rotation * Math.PI / 180);
            
            // Glød-effekt
            gameCtx.shadowBlur = 20;
            gameCtx.shadowColor = COLORS.ORANGE;
            
            // Tegn dråpen som en tåreformet figur
            gameCtx.beginPath();
            
            // Topp av dråpen (spiss)
            gameCtx.moveTo(0, -baseRadius * 1.5);
            
            // Høyre side av dråpen
            gameCtx.quadraticCurveTo(
                baseRadius, -baseRadius * 0.5, 
                baseRadius, 0
            );
            
            // Bunn av dråpen (buet)
            gameCtx.quadraticCurveTo(
                baseRadius, baseRadius * 1.2, 
                0, baseRadius
            );
            
            // Venstre side av dråpen
            gameCtx.quadraticCurveTo(
                -baseRadius, baseRadius * 1.2, 
                -baseRadius, 0
            );
            
            // Lukk til toppen
            gameCtx.quadraticCurveTo(
                -baseRadius, -baseRadius * 0.5, 
                0, -baseRadius * 1.5
            );
            
            // Fyll med gradient for å skape en glødende effekt
            const gradient = gameCtx.createRadialGradient(0, 0, 0, 0, 0, baseRadius * 1.5);
            gradient.addColorStop(0, '#FFFFFF');
            gradient.addColorStop(0.2, '#FFFF00');
            gradient.addColorStop(0.4, '#FF8800');
            gradient.addColorStop(0.8, '#FF3300');
            gradient.addColorStop(1, '#AA0000');
            
            gameCtx.fillStyle = gradient;
            gameCtx.fill();
            
            // Legg til glødende kontur
            gameCtx.strokeStyle = COLORS.NEON_YELLOW;
            gameCtx.lineWidth = 1;
            gameCtx.stroke();
            
            // Legg til små flammer som kommer ut av lavaen
            const flameCount = 3;
            for (let i = 0; i < flameCount; i++) {
                const flameAngle = (i / flameCount) * Math.PI * 2 + (Date.now() * 0.005 % (Math.PI * 2));
                const flameX = Math.cos(flameAngle) * baseRadius * 0.8;
                const flameY = Math.sin(flameAngle) * baseRadius * 0.8;
                const flameSize = baseRadius * 0.5 * (0.5 + 0.5 * Math.sin(Date.now() * 0.01 + i));
                
                gameCtx.beginPath();
                gameCtx.moveTo(flameX, flameY);
                
                // Tegn flamme
                for (let j = 0; j < 3; j++) {
                    const subAngle = flameAngle + (j - 1) * 0.2;
                    const ctrlX = flameX + Math.cos(subAngle) * flameSize * 1.5;
                    const ctrlY = flameY + Math.sin(subAngle) * flameSize * 1.5;
                    const endX = flameX + Math.cos(flameAngle) * flameSize * 0.8;
                    const endY = flameY + Math.sin(flameAngle) * flameSize * 0.8;
                    
                    gameCtx.quadraticCurveTo(ctrlX, ctrlY, endX, endY);
                }
                
                // Fyll flammen med gradient
                const flameGradient = gameCtx.createRadialGradient(flameX, flameY, 0, flameX, flameY, flameSize);
                flameGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                flameGradient.addColorStop(0.4, 'rgba(255, 255, 0, 0.7)');
                flameGradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                
                gameCtx.fillStyle = flameGradient;
                gameCtx.fill();
            }
            
            gameCtx.restore();
        }
    }
}

function restartGame() {
    console.log("Restarting game");
    
    // Legg til denne koden for å stoppe rotasjonen
    if (screenRotationTimer) {
        clearInterval(screenRotationTimer);
        screenRotationTimer = null;
    }
    
    // Reset game variables
    level = 1;
    score = 0;
    lives = 5;
    
    // Start the game
    startGame();
}

        function endGame() {
            console.log("Ending game");
            // Check if score qualifies for highscore
            const isHighscore = highscores.length < 10 || score > highscores[highscores.length - 1].score;
            
            if (isHighscore) {
                // Show highscore input
                document.getElementById('highscoreInput').classList.remove('hidden');
                document.getElementById('playerNameInput').focus();
                
                // Show game over screen
                showScreen('gameOver');
            } else {
                // Show highscores directly
                showHighscores();
                startScreenRotation();

            }
        }
        function loadHighscores() {
    console.log("Loading highscores from Firebase");
    
    // Vis en laste-indikator
    const highscoreList = document.getElementById('highscoreList');
    if (highscoreList) {
        highscoreList.innerHTML = '<div style="text-align: center; color: #39FF14;">LASTER HIGHSCORES...</div>';
    }
    
    // Hent de 20 beste poengsummene, sortert etter score i synkende rekkefølge
    db.collection("highscores")
      .orderBy("score", "desc")
      .limit(20)
      .get()
      .then((querySnapshot) => {
          highscores = [];
          querySnapshot.forEach((doc) => {
              highscores.push(doc.data());
          });
          console.log("Loaded " + highscores.length + " highscores from Firebase");
          
          // Vis highscores hvis vi er på highscore-skjermen
          if (gameState === 'highscores') {
              displayHighscores();
          }
      })
      .catch((error) => {
          console.error("Error loading highscores:", error);
          // Fallback til lokal lagring hvis Firebase feiler
          const savedHighscores = localStorage.getItem('evilInvadersHighscores');
          if (savedHighscores) {
              try {
                  highscores = JSON.parse(savedHighscores);
              } catch (e) {
                  console.error("Error parsing local highscores:", e);
                  createDefaultHighscores();
              }
          } else {
              createDefaultHighscores();
          }
      });
}


            function createDefaultHighscores() {
                // Initialize with some default highscores
                highscores = [
                    { name: 'BOENZA', score: 5000 },
                    { name: 'MASTER', score: 4000 },
                    { name: 'SHOOTER', score: 3000 },
                    { name: 'DEFENDER', score: 2000 },
                    { name: 'ROOKIE', score: 1000 }
                ];              
                saveHighscores();
            }


        function checkHighscore(score) {
    // Hvis vi har mindre enn 20 highscores, eller scoren er høyere enn den laveste highscoren
    if (highscores.length < 20) return true;
    
    // Finn den laveste scoren i highscores
    const lowestScore = Math.min(...highscores.map(hs => hs.score));
    return score > lowestScore;
}
        function saveHighscores() {
            localStorage.setItem('evilInvadersHighscores', JSON.stringify(highscores));
        }

        function showScreen(screenName) {
    console.log(`Showing screen: ${screenName} (current state: ${gameState})`);
    
    // Save previous state for music handling
    const previousState = gameState;
    
    // Hide all screens first
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('introScreen').classList.add('hidden');
    document.getElementById('levelStartScreen').classList.add('hidden');
    document.getElementById('gameOverScreen').classList.add('hidden');
    document.getElementById('highscoresScreen').classList.add('hidden');
    document.getElementById('levelCompleteScreen').classList.add('hidden');
    document.getElementById('victoryScreen').classList.add('hidden');
    
    
    const creditsScreen = document.getElementById('creditsScreen');
    if (creditsScreen) {
        creditsScreen.classList.add('hidden');
    }
    // Show the specified screen
    if (screenName === 'start') {
        const startScreen = document.getElementById('startScreen');
        startScreen.classList.remove('hidden');
        gameState = 'start';
        
        // Add title background if it doesn't exist
        if (!document.getElementById('titleBackground')) {
            const titleBackground = document.createElement('img');
            titleBackground.id = 'titleBackground';
            titleBackground.src = 'assets/images/title_screen.jpg';
            titleBackground.alt = '';
            
            // Add to DOM before any other elements
            startScreen.insertBefore(titleBackground, startScreen.firstChild);
            
            // Error handling if image can't load
            titleBackground.onerror = function() {
                console.log("Could not load title background");
                titleBackground.style.display = 'none';
                
                // Show title heading if image can't load
                const heading = startScreen.querySelector('h1');
                if (heading) {
                    heading.style.display = 'block';
                }
            };
        }
        
        // Make sure the title is visible
        const heading = startScreen.querySelector('h1');
        if (heading) {
            heading.style.display = 'block';
        }
        
        // Make sure "PRESS ENTER" text is visible
        const pressEnter = startScreen.querySelector('.press-enter');
        if (pressEnter) {
            pressEnter.textContent = 'PRESS ENTER OR SPACE TO CONTINUE';
            pressEnter.classList.add('blink');
        }
    } else if (screenName === 'intro') {
        document.getElementById('introScreen').classList.remove('hidden');
        gameState = 'intro';
        
        // Continue music from start screen during intro
    } else if (screenName === 'levelStart') {
        document.getElementById('levelStartScreen').classList.remove('hidden');
        document.getElementById('levelNumber').textContent = level;
        gameState = 'levelStart';
    } else if (screenName === 'gameOver') {
        document.getElementById('gameOverScreen').classList.remove('hidden');
        gameState = 'gameOver';
        
        // Play title music on game over
        playBackgroundMusic(0);
    } else if (screenName === 'highscores') {
        document.getElementById('highscoresScreen').classList.remove('hidden');
        gameState = 'highscores';
    } else if (screenName === 'levelComplete') {
        document.getElementById('levelCompleteScreen').classList.remove('hidden');
        gameState = 'levelComplete';
    } else if (screenName === 'victory') {
        document.getElementById('victoryScreen').classList.remove('hidden');
        document.getElementById('finalBonus').textContent = lives * 100;
        document.getElementById('finalScore').textContent = score + (lives * 100);
        gameState = 'victory';
        
        // Play victory music (use title music for now)
        playBackgroundMusic(0);
    } else if (screenName === 'playing') {
        // Just update the game state for playing, no specific screen to show
        gameState = 'playing';
    }
    
    // Show mobile controls only during gameplay
    if (screenName === 'playing' && 'ontouchstart' in window) {
        document.getElementById('mobileControls').style.display = 'flex';
    } else {
        document.getElementById('mobileControls').style.display = 'none';
    }
}
    </script>
</body>
</html>
